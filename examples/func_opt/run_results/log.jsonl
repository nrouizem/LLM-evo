{"type": "seed", "generation": 0, "score": -0.1165799600421451, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11611092649400234, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11653468606527895, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11686255095992237, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11615673505002633, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11636355798691511, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11717210453934968, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11702632700325921, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11649323848541826, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.1165268105105497, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11773983796592802, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11664493498392403, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.1162726049660705, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11813874554354697, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.12085724296048284, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11837504099821672, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11644680146127939, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11797186604235321, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11638452747138217, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "seed", "generation": 0, "score": -0.11642656498588622, "text": "def build_func(x):    return np.exp(np.sin(x) + np.square(np.cos(x)))"}
{"type": "mutation", "generation": 1, "zscore": 0.9188777922674353, "text": "def build_func(x):\n    \"\"\"Reasoning: Compute cos(x) once, square it in-place to minimize temporaries, compute sin(x) separately,\n    and then exponentiate the sum. This reduces intermediate allocations and passes while preserving identical outputs\n    for float64 inputs on large arrays.\"\"\"\n    cosx = np.cos(x)\n    cosx *= cosx\n    sinx = np.sin(x)\n    return np.exp(sinx + cosx)", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.952893800888797, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: \n    - Compute sin(x) and cos(x) separately to allow in-place optimization.\n    - Reuse the cosine array by squaring in place (cos^2) to avoid an extra temporary array for cos^2.\n    - Add cos^2 to sin in place, then compute the exponential in-place to avoid an additional allocation.\n    - This preserves exact numerical results (within float64 precision) while reducing memory allocations and passes for large arrays.\n    \"\"\"\n    s = np.sin(x)\n    c = np.cos(x)\n    c *= c          # c now holds cos(x)^2\n    s += c          # s now holds sin(x) + cos(x)^2\n    np.exp(s, out=s)  # in-place exponential to avoid a new array\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.342322291008863, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute the result with minimal temporaries by reusing in-place operations.\n    Steps:\n    - Compute cos(x) into c, then square in place to obtain cos^2(x).\n    - Compute sin(x) into s.\n    - In-place add to accumulate sin(x) + cos^2(x) into s.\n    - In-place apply exp to get the final result.\n    Returns an array identical to the naive implementation up to float64 precision.\n    \"\"\"\n    c = np.cos(x)\n    c *= c  # now c holds cos(x)^2\n    s = np.sin(x)\n    np.add(s, c, out=s)  # s = sin(x) + cos(x)^2\n    np.exp(s, out=s)     # s = exp(s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.900666679018257, "text": "def build_func(x):\n    \"\"\"Reasoning: Minimize temporaries by using in-place operations: compute sin into s, cos into c, square c in-place, add, then exp in-place into s. This preserves exact values and reduces allocations for large arrays.\"\"\"\n    s = np.sin(x)\n    c = np.cos(x)\n    np.square(c, out=c)  # c = cos(x)**2\n    s += c                # s = sin(x) + cos(x)**2\n    np.exp(s, out=s)      # s = exp(s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.323107205275388, "text": "import numpy as np\n\ndef build_func(x):\n    cosx = np.cos(x)\n    cosx *= cosx\n    sinx = np.sin(x)\n    sinx += cosx\n    np.exp(sinx, out=sinx)\n    return sinx", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 5.081372242243167, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin into a scratch array, compute cos^2 into another scratch array, add them, then apply exp in-place. This minimizes temporaries and passes over data, avoiding Python loops.\n    \"\"\"\n    y = np.empty_like(x)\n    np.sin(x, out=y)\n    cos2 = np.cos(x)\n    cos2 *= cos2\n    y += cos2\n    np.exp(y, out=y)\n    return y", "operator": "cross"}
{"type": "mutation", "generation": 1, "zscore": 4.507781883840802, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Minimize temporaries and passes by using in-place operations.\n    - Compute sin(x) into a preallocated buffer to avoid a separate sin array.\n    - Compute cos(x) into another buffer and square in place to obtain cos^2(x) without extra allocations.\n    - Accumulate the two contributions and apply exp in place to minimize memory usage.\n    - Preserve exact float64 semantics by avoiding shape broadcasts and extra copies.\n    \"\"\"\n    s = np.empty_like(x)\n    np.sin(x, out=s)\n    c = np.cos(x)\n    c *= c\n    s += c\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.25721483202149, "text": "def build_func(x):\n    \"\"\"Reasoning: Preallocate two buffers to minimize temporaries, computing cos^2 into tmp and sin + cos^2 into acc, then apply exp in place, returning acc. This preserves exact FP results compared to naive evaluation order per-element and reduces allocations for large arrays (~1e7).\"\"\"\n    tmp = np.empty_like(x)\n    acc = np.empty_like(x)\n    np.cos(x, out=tmp)\n    np.square(tmp, out=tmp)\n    np.sin(x, out=acc)\n    np.add(acc, tmp, out=acc)\n    np.exp(acc, out=acc)\n    return acc", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.242612648680067, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: compute exp(sin(x) + cos(x)**2) efficiently by reusing two temporary buffers.\n    Steps:\n    - sin into tmp_sin\n    - cos into tmp_cos\n    - square tmp_cos in place to get cos^2\n    - add cos^2 to sin\n    - exponentiate in-place to produce final result\n    - return the in-place result to avoid extra allocations\n    This minimizes passes, transcendental calls, and temporaries while preserving float64 accuracy.\n    \"\"\"\n    tmp_sin = np.empty_like(x)\n    tmp_cos = np.empty_like(x)\n    np.sin(x, out=tmp_sin)\n    np.cos(x, out=tmp_cos)\n    tmp_cos *= tmp_cos\n    tmp_sin += tmp_cos\n    np.exp(tmp_sin, out=tmp_sin)\n    return tmp_sin", "operator": "cross"}
{"type": "mutation", "generation": 1, "zscore": 4.712951793116041, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: To compute exp(sin(x) + cos(x)**2) quickly for large arrays while preserving\n    numerical correctness, minimize memory allocations and passes. \n    - Compute sin(x) into a dedicated output buffer (one pass, no extra allocations).\n    - Compute cos(x) into a separate buffer, square it in place to obtain cos^2(x) (avoids\n      an extra allocation for cos^2), then accumulate into the sin buffer.\n    - Finally apply exp in place to reuse the same output buffer, avoiding a new array.\n    This approach reduces temporary arrays and memory traffic while preserving the exact\n    arithmetic order (up to floating point precision) needed to match the naive implementation.\n    \"\"\"\n    out = np.empty_like(x)\n    np.sin(x, out=out)          # out = sin(x)\n    cos_buf = np.empty_like(x)\n    np.cos(x, out=cos_buf)      # cos_buf = cos(x)\n    cos_buf *= cos_buf            # cos_buf = cos(x)^2\n    out += cos_buf                # out = sin(x) + cos(x)^2\n    np.exp(out, out=out)          # out = exp(sin(x) + cos(x)^2)\n    return out", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 26.72505527706165, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to reduce the computation to a single transcendental function.\n    This yields f(x) = exp(1 + sin(x) - sin(x)**2), which matches the naive implementation up to float64 precision\n    while avoiding an additional cos computation and reducing memory traffic for large arrays.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "insights"}
{"type": "mutation", "generation": 1, "zscore": 27.44898074397811, "text": "def build_func(x):\n    \"\"\"Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    enabling a single sine evaluation per element and reducing temporaries, improving performance on large arrays while preserving float64 semantics.\"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.125677191642569, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Minimize temporaries and passes by performing in-place style computation:\n    1) compute cos(x) into cosx, then square in place to obtain cos^2(x)\n    2) allocate a single output buffer 'out'\n    3) compute sin(x) into 'out', add cos^2(x) into 'out', then apply exp into 'out'\n    This avoids extra temporaries from separate sin, cos, and sum arrays, improving performance on large arrays.\n    \"\"\"\n    cosx = np.cos(x)\n    cosx *= cosx  # cos(x)^2\n    out = np.empty_like(x)\n    np.sin(x, out=out)          # out = sin(x)\n    np.add(out, cosx, out=out)  # out = sin(x) + cos(x)^2\n    np.exp(out, out=out)          # out = exp(sin(x) + cos(x)^2)\n    return out", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.333734002901373, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Minimize temporaries and Python overhead by:\n    - computing cos(x)^2 once (cosx2),\n    - computing sin(x) into an output buffer,\n    - adding cosx2 to that buffer in place,\n    - applying exp in place to produce the final result.\n    This avoids constructing multiple intermediate arrays and reduces memory traffic.\n    \"\"\"\n    cosx2 = np.cos(x)\n    cosx2 *= cosx2  # cos(x)^2\n    out = np.empty_like(x)\n    np.sin(x, out=out)  # out now contains sin(x)\n    out += cosx2        # out = sin(x) + cos(x)^2\n    np.exp(out, out=out) # out = exp(sin(x) + cos(x)^2)\n    return out", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.962980124078814, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use two temporary buffers to minimize memory allocations and maximize reuse.\n    - s holds sin(x)\n    - c holds cos(x) and is then squared in place to obtain cos(x)**2\n    - accumulate in place: s = sin(x) + cos(x)**2\n    - apply exp in place to s\n    This avoids creating extra intermediate arrays beyond the essential temporaries and keeps the result identical.\n    \"\"\"\n    s = np.sin(x)\n    c = np.cos(x)\n    np.square(c, out=c)\n    np.add(s, c, out=s)\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.535553565827837, "text": "def build_func(x):\n    cosx = np.cos(x)          # compute cos(x)\n    cos2 = cosx * cosx        # compute cos(x)^2\n    np.sin(x, out=cosx)       # overwrite cosx with sin(x)\n    cos2 += cosx                # add sin(x) to cos(x)^2\n    np.exp(cos2, out=cos2)     # compute exp(sin(x) + cos(x)^2) in place\n    return cos2", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 4.806998170966086, "text": "def build_func(x):\n    sinx = np.sin(x)\n    cosx = np.cos(x)\n    cosx *= cosx\n    sinx += cosx\n    np.exp(sinx, out=sinx)\n    return sinx", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 27.009552656113097, "text": "def build_func(x):\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 4.760433038243802, "text": "def build_func(x):\n    sin_buf = np.empty_like(x)\n    cos_buf = np.empty_like(x)\n\n    np.sin(x, out=sin_buf)\n    np.cos(x, out=cos_buf)\n    cos_buf *= cos_buf\n    sin_buf += cos_buf\n    np.exp(sin_buf, out=sin_buf)\n    return sin_buf", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 4.215963363806052, "text": "def build_func(x):\n    sin_buf = np.empty_like(x)\n    cos_buf = np.empty_like(x)\n    np.sin(x, out=sin_buf)\n    np.cos(x, out=cos_buf)\n    cos_buf *= cos_buf\n    sin_buf += cos_buf\n    np.exp(sin_buf, out=sin_buf)\n    return sin_buf", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 4.905631593773529, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: To minimize memory allocations and passes, compute sin and cos once,\n    square cos in-place, then accumulate the sum in a single array (reusing the\n    sin array) and apply exp in-place. This avoids creating temporary arrays for\n    the sum and the final result.\n    \"\"\"\n    s = np.sin(x)\n    c = np.cos(x)\n    c *= c\n    np.add(s, c, out=s)  # s now holds sin(x) + cos(x)^2\n    np.exp(s, out=s)     # s now holds exp(...)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.936975657039626, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: The na\u00efve approach creates separate temporaries for sin(x) and cos(x) and an extra\n    temporary for the sum before applying exp. This mutation reduces temporaries by:\n    - computing sin(x) into tmp\n    - computing cos(x) into c and squaring in place to obtain cos^2(x)\n    - accumulating in tmp (tmp += c)\n    - performing exp in place on tmp (np.exp(..., out=tmp))\n    This minimizes memory usage and avoids an extra intermediate array, potentially improving\n    performance on large arrays while preserving exact numerical results (within float64 precision).\n    \"\"\"\n    tmp = np.sin(x)\n    c = np.cos(x)\n    np.square(c, out=c)\n    tmp += c\n    np.exp(tmp, out=tmp)\n    return tmp", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": -8.055282918227794, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: To compute exp(sin(x) + cos(x)**2) efficiently for large arrays, compute sin(x) into a dedicated\n    output array using an in-place ufunc, compute cos(x)**2 into a separate temporary array, add them, then apply\n    exp in place. This minimizes temporaries to two large arrays and uses two passes over the data with\n    vectorized NumPy ops, avoiding Python loops.\n    \"\"\"\n    sin_out = np.empty_like(x)\n    np.sin(x, out=sin_out)           # sin(x)\n    cos2 = np.cos(x)\n    cos2 *= cos2                       # cos(x)**2\n    sin_out += cos2\n    np.exp(sin_out, out=sin_out)       # exp(...) in place\n    return sin_out", "operator": "cross"}
{"type": "mutation", "generation": 1, "zscore": -28.815428304763458, "text": "def build_func(x):\n    # Use cos^2(x) = (1 + cos(2x)) / 2 to reduce temporaries and improve speed\n    return np.exp(np.sin(x) + 0.5 + 0.5 * np.cos(2 * x))", "operator": "cross"}
{"type": "mutation", "generation": 1, "zscore": 5.216429263400204, "text": "def build_func(x):\n    # Reasoning: use two temporaries to minimize allocations while preserving exact results.\n    # Compute sin(x) into tmp, compute cos(x) into cos and square it in place,\n    # add to tmp, then apply exp in place to produce the final result.\n    tmp = np.empty_like(x)\n    np.sin(x, out=tmp)\n    cos = np.cos(x)\n    cos *= cos\n    tmp += cos\n    np.exp(tmp, out=tmp)\n    return tmp", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 0.7532988177645528, "text": "def build_func(x):\n    \"\"\"Reasoning: Improve performance by avoiding temporary arrays from np.square(...)\n    and by performing in-place squaring of cos(x) to reduce allocations. This keeps\n    two intermediate arrays (sin and cos^2) but avoids creating an extra temporary\n    for the squared cos, and uses vectorized ufuncs to maintain speed on large arrays.\n    The result remains np.exp(np.sin(x) + (np.cos(x))**2).\"\"\"\n    sinx = np.sin(x)\n    cosx = np.cos(x)\n    cosx *= cosx\n    return np.exp(sinx + cosx)", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.611192832951674, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: minimize temporaries and passes by:\n    - computing cos(x) into a dedicated buffer cos2 and squaring in place to obtain cos(x)**2\n    - computing sin(x) directly into the final output buffer\n    - adding cos(x)**2 to sin(x) in place\n    - exponentiating in place to obtain the final result\n    This uses only two intermediate arrays and preserves the exact mathExpression: exp(sin(x) + cos(x)**2)\n    \"\"\"\n    import numpy as np\n    out = np.empty_like(x)\n    cos2 = np.empty_like(x)\n\n    np.cos(x, out=cos2)      # cos(x) -> cos2\n    np.square(cos2, out=cos2) # cos2 = cos(x)**2\n\n    np.sin(x, out=out)        # out = sin(x)\n    out += cos2                 # out = sin(x) + cos(x)**2\n\n    np.exp(out, out=out)        # out = exp(sin(x) + cos(x)**2)\n    return out", "operator": "insights"}
{"type": "mutation", "generation": 1, "zscore": 4.9640194121545855, "text": "def build_func(x):\n    import numpy as np\n    out = np.empty_like(x)\n    cosbuf = np.empty_like(x)\n    np.sin(x, out=out)\n    np.cos(x, out=cosbuf)\n    np.square(cosbuf, out=cosbuf)\n    np.add(out, cosbuf, out=out)\n    np.exp(out, out=out)\n    return out", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 4.969937423899685, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: To reduce memory pressure and improve performance for large arrays, compute sin(x)\n    into an output buffer, compute cos(x) separately and square it in place to obtain cos^2(x),\n    then accumulate: out = sin(x) + cos^2(x). Finally apply exp in place to produce the result.\n    This minimizes temporary allocations (only two large arrays: out and cosx) and avoids Python loops.\n    \"\"\"\n    out = np.empty_like(x)\n    np.sin(x, out=out)\n    cosx = np.cos(x)\n    cosx *= cosx\n    out += cosx\n    np.exp(out, out=out)\n    return out", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.082859862126654, "text": "def build_func(x):\n    s = np.empty_like(x)\n    c = np.empty_like(x)\n    np.sin(x, out=s)\n    np.cos(x, out=c)\n    c *= c\n    np.add(s, c, out=s)\n    np.exp(s, out=s)\n    return s", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 4.878949288576321, "text": "def build_func(x):\n    \"\"\"Reasoning: \n    - Compute cos(x) into an intermediate array and square it in place to obtain cos^2(x) without\n      creating an extra temporary for cos^2.\n    - Compute sin(x) into a separate temporary array to avoid mutating the cos^2 array.\n    - Add sin(x) to cos^2(x) in place, then apply exp in place to minimize memory traffic and temporaries.\n    - This preserves exact numerical results (within float64 precision) and reduces temporary allocations\n      compared to the naive approach.\n    \"\"\"\n    cos2 = np.cos(x)\n    np.square(cos2, out=cos2)  # cos2 now holds cos^2(x)\n    sinx = np.sin(x)           # separate temporary for sin(x)\n    cos2 += sinx                 # sin(x) + cos^2(x)\n    np.exp(cos2, out=cos2)       # exp(...) in place\n    return cos2", "operator": "insights"}
{"type": "mutation", "generation": 1, "zscore": 4.844146635285697, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Minimize temporary allocations by performing sin into a preallocated output array and cos into another preallocated array, then in-place accumulate and exponentiate. This reduces peak memory and avoids Python loops while preserving exact float64 results.\n    \"\"\"\n    y = np.empty_like(x)\n    np.sin(x, out=y)\n    c = np.empty_like(x)\n    np.cos(x, out=c)\n    c *= c  # cos^2\n    y += c  # sin(x) + cos^2(x)\n    np.exp(y, out=y)\n    return y", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.839008222444354, "text": "def build_func(x):\n    sinx = np.empty_like(x)\n    cosx = np.empty_like(x)\n    np.sin(x, out=sinx)\n    np.cos(x, out=cosx)\n    cosx *= cosx\n    sinx += cosx\n    np.exp(sinx, out=sinx)\n    return sinx", "operator": "explore"}
{"type": "mutation", "generation": 1, "zscore": 4.63749410117141, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) and cos(x) using two separate passes, then form sin(x) + cos(x)**2\n    and apply exp to get the exact same results as the naive implementation while reusing\n    buffers to avoid unnecessary allocations.\n    \"\"\"\n    s = np.empty_like(x)\n    c = np.empty_like(x)\n    np.sin(x, out=s)\n    np.cos(x, out=c)\n    np.square(c, out=c)       # c now holds cos(x)**2\n    np.add(s, c, out=s)       # s now holds sin(x) + cos(x)**2\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 5.217442088368207, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use in-place, fused computations to minimize temporaries:\n    1) compute sin(x) and cos(x) into separate arrays,\n    2) square cos in place,\n    3) accumulate sin + cos^2 into the same array,\n    4) exponentiate in place to avoid extra array creation.\n    This preserves exact numerical results for float64 within FP precision.\n    \"\"\"\n    s = np.sin(x)\n    c = np.cos(x)\n    np.multiply(c, c, out=c)  # c = cos(x)^2\n    np.add(s, c, out=s)       # s = sin(x) + cos(x)^2\n    np.exp(s, out=s)            # s = exp(s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.931977955662882, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: to speed up large-array computation, compute sin into a scratch array 't',\n    compute cos into a separate array 'c', square 'c' in place to get cos^2, then\n    accumulate: t = sin(x) + cos(x)^2, finally apply exp in place to reuse memory.\n    This minimizes temporary allocations and passes while preserving exact output\n    within float64 precision.\n    \"\"\"\n    t = np.empty_like(x)\n    np.sin(x, out=t)\n    c = np.cos(x)\n    c *= c\n    t += c\n    np.exp(t, out=t)\n    return t", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 4.99360941774131, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use two preallocated buffers to store sin(x) and cos(x) results separately, performing\n    all arithmetic in-place to minimize allocations and passes. Steps:\n    - s = sin(x) into an output buffer\n    - c = cos(x) into another buffer, then square in place: c = cos(x)**2\n    - s += c  (sin + cos^2)\n    - exp in place: s = exp(s)\n    This preserves exact float64 results relative to the naive implementation while reducing\n    memory traffic and avoiding Python loops.\n    \"\"\"\n    s = np.empty_like(x)\n    c = np.empty_like(x)\n    np.sin(x, out=s)\n    np.cos(x, out=c)\n    c *= c\n    s += c\n    np.exp(s, out=s)\n    return s", "operator": "insights"}
{"type": "mutation", "generation": 1, "zscore": 5.272894467921484, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: minimize temporaries by preallocating two scratch arrays and compute sin and cos\n    into them, square cos in place, then accumulate and apply exp in place. This reduces\n    memory allocations compared to naive approach while preserving numerical equivalence.\n    \"\"\"\n    sinx = np.empty_like(x)\n    cosx = np.empty_like(x)\n    np.sin(x, out=sinx)\n    np.cos(x, out=cosx)\n    cosx *= cosx\n    sinx += cosx\n    np.exp(sinx, out=sinx)\n    return sinx", "operator": "insights"}
{"type": "mutation", "generation": 1, "zscore": 4.997739894381548, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Improve speed by minimizing intermediates and passes while preserving exact results.\n    Strategy:\n    - Compute cos(x) once into a working buffer (cosx).\n    - Square in-place to obtain cos^2(x).\n    - Compute sin(x) into a separate buffer (sinx).\n    - Add sinx to cosx in-place to get sin(x) + cos^2(x).\n    - Apply exp in-place to the same buffer to avoid extra allocations.\n    This yields the same mathematical result as np.exp(np.sin(x) + np.square(np.cos(x))) with fewer temporaries and\n    memory overhead, which is beneficial for large arrays.\n    \"\"\"\n    cosx = np.cos(x)\n    np.square(cosx, out=cosx)          # cosx := cos(x)^2\n    sinx = np.sin(x)                   # sinx := sin(x)\n    np.add(sinx, cosx, out=cosx)       # cosx := sin(x) + cos(x)^2\n    np.exp(cosx, out=cosx)             # cosx := exp(sin(x) + cos(x)^2)\n    return cosx", "operator": "mutate"}
{"type": "mutation", "generation": 1, "zscore": 0.4606581878095521, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Replace the explicit np.square call with a simple elementwise multiplication to avoid an extra function call, while keeping sin and cos evaluations and numerical fidelity to the naive implementation.\n    \"\"\"\n    s = np.sin(x)\n    c = np.cos(x)\n    return np.exp(s + c * c)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 27.293588099831553, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    reducing one transcendental evaluation (cos) and avoiding extra temporaries. This matches the naive\n    implementation to float64 precision while improving performance on large arrays by using a single\n    sin computation and a single exp.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "insights"}
{"type": "mutation", "generation": 2, "zscore": 30.74950380944932, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) into a preallocated buffer to avoid extra allocations, then\n    reuse that buffer for the entire computation: f(x) = exp(1 + sin(x) - sin(x)**2).\n    Steps:\n    - s = sin(x) (in-place into preallocated array)\n    - s = 1 + s - s*s (via in-place operations)\n    - s = exp(s) (in-place)\n    - return s\n    \"\"\"\n    s = np.empty_like(x)\n    np.sin(x, out=s)\n    s -= s * s\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.676902039040638, "text": "def build_func(x):\n    \"\"\"Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    enabling a single sine evaluation per element and reducing temporaries, improving performance on large arrays while preserving float64 semantics.\"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 27.361580804140814, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to reduce the computation to a single\n    transcendental function. This yields f(x) = exp(1 + sin(x) - sin(x)**2), which matches the naive\n    implementation up to float64 precision while avoiding an additional cos computation and reducing\n    memory traffic for large arrays.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 25.956750168780932, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Reduce to a single transcendental call by exploiting cos^2(x) = 1 - sin^2(x),\n    giving exp(1 + sin(x) - sin(x)**2). This uses only one sin evaluation and avoids\n    computing cos(x), minimizing memory traffic and passes on large arrays.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 30.836602611873516, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Reduce temporaries and memory traffic by computing sin(x) directly into a preallocated buffer and performing\n    in-place arithmetic with the minimal number of passes. f(x) = exp(1 + sin(x) - sin(x)**2) is computed as:\n    - s = sin(x) stored in-place\n    - s = sin(x) - sin(x)**2 via in-place s -= s*s\n    - s = 1 + s\n    - s = exp(s) in place\n    This avoids creating multiple intermediate arrays and keeps memory footprint low for large arrays.\n    \"\"\"\n    s = np.empty_like(x)\n    np.sin(x, out=s)\n    s -= s * s\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 23.573656181244587, "text": "def build_func(x):\n    \"\"\"\n    Efficient rewrite: use cos^2(x) = 1 - sin^2(x) to avoid an extra transcendental evaluation.\n    f(x) = exp(1.0 + sin(x) - sin(x)**2)\n    This yields identical float64 results to the naive implementation while reducing work for large arrays.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "insights"}
{"type": "mutation", "generation": 2, "zscore": 26.91839883410294, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). This reduces to a single sin evaluation\n    and a couple of arithmetic ops, minimizing temporaries and passes over large arrays\n    while preserving float64 semantics.\n    \"\"\"\n    import numpy as np\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.753783371788927, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). This reduces to a single sin evaluation and a single exp,\n    minimizing temporaries and memory traffic while preserving float64 results.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.727467139582515, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a memory-efficient variant that computes sin(x) once and builds the exponent\n    using an in-place buffer to minimize temporaries. It avoids any cos computations and ensures\n    exactfloat64-compatible results with the naive expression.\n    \"\"\"\n    s = np.sin(x)\n    exp_arg = 1.0 + s\n    np.subtract(exp_arg, s * s, out=exp_arg)\n    return np.exp(exp_arg)", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": 30.889785487672416, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    This reduces the number of transcendental evaluations to one (sin) and minimizes memory traffic by using\n    two preallocated buffers for intermediate results, preserving float64 precision.\n    \"\"\"\n    s = np.empty_like(x)\n    t = np.empty_like(x)\n    np.sin(x, out=s)           # s = sin(x)\n    np.multiply(s, s, out=t)   # t = sin(x)^2\n    s -= t                     # s = sin(x) - sin(x)^2\n    s += 1.0                   # s = 1 + sin(x) - sin(x)^2\n    np.exp(s, out=s)           # s = exp(...)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.61128575369224, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to reduce the expression exp(sin(x) + cos(x)**2)\n    to exp(1 + sin(x) - sin(x)**2). This uses a single sine evaluation and a single exponential, minimizing temporaries\n    and passes while preserving the exact float64 semantics of the naive implementation.\n    \"\"\"\n    import numpy as np\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.975404991309127, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    enabling a single sine evaluation per element and reducing temporaries, improving performance on large arrays while preserving float64 semantics.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "insights"}
{"type": "mutation", "generation": 2, "zscore": 26.522124741857848, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to reduce the computation to a single\n    transcendental function evaluation. Compute s = sin(x) and return exp(1 + s - s^2).\n    This preserves float64 semantics and minimizes temporaries and passes over data.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.62575134924653, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin(x)^2 to reduce to a single transcendental\n    function evaluation. This avoids computing cos and its square, lowering\n    temporaries and passes while preserving float64 semantics since\n    exp(sin(x) + cos(x)^2) = exp(1 + sin(x) - sin(x)^2).\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.995973415252735, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin(x)^2 to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1.0 + sin(x) - sin(x)**2). This reduces to a single sine evaluation and avoids\n    computing cos entirely, minimizing temporaries and passes while preserving float64 semantics.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 33.197853642052955, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place computation to minimize allocations:\n    - Compute sin(x) in place to reuse the original input array memory and avoid a separate sin result array.\n    - Compute sin^2 into a temporary array t, then form the exact expression 1 + sin(x) - sin(x)^2 and apply exp in place.\n    - This implements exp(sin(x) + cos(x)**2) via the identity cos^2 = 1 - sin^2, while using only a single transcendental function (sin).\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": -29.4994191353392, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = (1 + cos(2x)) / 2 to rewrite the exponent as 0.5 + sin(x) + 0.5*cos(2x),\n    so f(x) = exp(0.5 + sin(x) + 0.5*cos(2x)). This provides a different formulation from the sin-only\n    or sin^2-based approaches and relies on a single exp call with a compact combination of trigs.\n    \"\"\"\n    return np.exp(np.sin(x) + 0.5 * np.cos(2 * x) + 0.5)", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": 33.184968659230734, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Break from the common patterns by performing the computation in-place on the input buffer with a single dedicated scratch array to minimize allocations and passes. This preserves exact mathematics while avoiding Python-level loops.\n    \"\"\"\n    # Step 1: s = sin(x) in-place\n    np.sin(x, out=x)\n    # Step 2: s^2 into scratch\n    x2 = np.empty_like(x)\n    np.multiply(x, x, out=x2)\n    # Step 3: x = 1 + s - s^2\n    x -= x2\n    x += 1.0\n    # Step 4: exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": 27.16854949051568, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as\n    exp(1 + sin(x) - sin(x)**2). Compute sin(x) once and apply the remaining arithmetic in a\n    vectorized fashion to minimize passes and temporaries.\n    \"\"\"\n    s = np.empty_like(x)\n    np.sin(x, out=s)\n    return np.exp(1.0 + s - s * s)", "operator": "insights"}
{"type": "mutation", "generation": 2, "zscore": 30.967098147821826, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2)\n    into exp(1 + sin(x) - sin(x)**2). Compute sin(x) once, then compute sin^2 into a temporary,\n    subtract it in-place, add 1, and finally apply exp in-place to minimize memory traffic.\n    \"\"\"\n    s = np.sin(x)\n    t = s * s  # sin(x)**2\n    s -= t\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 27.53022078438645, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as\n    exp(1 + sin(x) - sin(x)**2), enabling a single sine evaluation per element and reducing temporaries.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.889680676325767, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to reduce to a single transcendental function.\n    This yields f(x) = exp(1 + sin(x) - sin(x)**2), which matches the naive implementation up to\n    float64 precision while avoiding an extra cos computation and reducing memory traffic for large arrays.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 30.88382639965763, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos(x)**2 = 1 - sin(x)**2 to transform exp(sin(x) + cos(x)**2) into exp(1 + sin(x) - sin(x)**2).\n    This reduces the number of transcendental evaluations (only sin and exp) and minimizes temporaries,\n    while preserving exact float64 semantics for large arrays.\n    \"\"\"\n    s = np.sin(x)\n    s -= s * s\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 27.24277473495334, "text": "def build_func(x):\n    \"\"\"\n    Use the identity cos^2(x) = 1 - sin^2(x) to reduce to a single sine evaluation:\n    f(x) = exp(1 + sin(x) - sin(x)**2). This minimizes transcendental evaluations and temporaries\n    for large arrays, while preserving float64 results.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.502173843567608, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    enabling a single sine evaluation per element and reducing temporaries, improving performance on large arrays while preserving float64 semantics.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.868455350899765, "text": "def build_func(x):\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "insights"}
{"type": "mutation", "generation": 2, "zscore": 26.971440254494453, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)^2 = 1 - sin(x)^2 to rewrite the exponent:\n        exp(sin(x) + cos(x)^2) = exp(1 + sin(x) - sin(x)^2).\n    This requires only a single sin computation and a couple of arithmetic\n    operations, reducing computational cost and memory traffic while preserving\n    float64 semantics to within typical FP rounding.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 28.622683127476467, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity cos^2(x) = 1 - sin^2(x) to rewrite the exponent as 1 + sin(x) - sin(x)^2, requiring only a single sin evaluation and minimizing temporaries. This yields exact mathematical equivalence to exp(sin(x) + cos(x)**2) and is faster on large arrays.\n    \"\"\"\n    s = np.sin(x)\n    s -= s * s\n    s += 1.0\n    return np.exp(s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": -37.4682439904681, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: This approach deliberately departs from the common pattern of computing sin(x) separately\n    and then combining with cos^2(x). Instead, it leverages the identity e^{i x} = cos(x) + i sin(x):\n    compute w = exp(i x) in one vectorized call, then sin(x) = Im(w) and cos(x) = Re(w). By accumulating\n    cos^2(x) into the imaginary part in-place (Im(w) += Re(w)^2), we obtain the exponent argument\n    sin(x) + cos^2(x) without performing additional per-element transcendental evaluations or extra\n    temporary arrays for sin and cos. Finally, apply exp to this real argument.\n    This yields a fundamentally different computational path than the standard sin/cos+exp route,\n    offering a distinct performance profile on large arrays.\n    \"\"\"\n    w = np.exp(1j * x)           # w = cos(x) + i*sin(x)\n    w.imag += w.real * w.real    # sin(x) + cos(x)^2 stored in the imaginary part\n    return np.exp(w.imag)         # exp(sin(x) + cos(x)^2)", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": 30.94175467395037, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to reduce to a single transcendental func.\n    This yields f(x) = exp(1 + sin(x) - sin(x)**2) which matches the naive implementation within float64 precision\n    while avoiding the cos computation and reducing memory traffic for large arrays.\n    \"\"\"\n    s = np.sin(x)\n    s -= s * s\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 26.525261523487504, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    This reduces to a single sine evaluation and a single exponentiation, minimizing temporaries and memory traffic\n    while preserving float64 semantics.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 27.223275675629676, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    enabling a single transcendental evaluation per element and reducing temporaries, improving performance on large arrays while preserving float64 semantics.\n    \"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 30.026301880033607, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: The naive expression exp(sin(x) + cos(x)**2) can be rewritten using cos^2(x) = 1 - sin^2(x)\n    as exp(1 + sin(x) - sin(x)**2). This reduces the computation to a single sine evaluation per element\n    and a single exponentiation, minimizing transcendental calls and temporaries for large arrays.\n    We compute s = sin(x), then s2 = s * s, then s = 1.0 + s - s2, and finally exp(s) in-place.\n    \"\"\"\n    s = np.sin(x)\n    s2 = s * s\n    s = 1.0 + s - s2\n    np.exp(s, out=s)\n    return s", "operator": "cross"}
{"type": "mutation", "generation": 2, "zscore": -37.4783627283082, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) via a single complex exponential to derive both sin(x)\n    and cos(x) in one pass. Let z = exp(i*x) => Re(z) = cos(x), Im(z) = sin(x).\n    Then sin(x) + cos(x)**2 = Im(z) + Re(z)**2.\n    We mutate the imaginary part of z in place to hold sin(x) + cos(x)**2, then exponentiate.\n    This yields the exact same results as the naive implementation with potentially fewer passes.\n    \"\"\"\n    z = np.exp(1j * x)      # z = e^{i x} -> cos(x) + i sin(x)\n    t = z.imag              # t initially holds sin(x)\n    t += z.real * z.real    # t = sin(x) + cos(x)^2\n    return np.exp(t)", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": 29.92167520098187, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2, which rewrites\n    the exponent as a squared distance in the sin-space. This yields a single exp evaluation per\n    element, avoids explicit cos computations, and provides a fundamentally different approach\n    from the common sin + sin^2 pattern while preserving exact float64 results.\n    \"\"\"\n    s = np.sin(x)\n    s -= 0.5\n    s *= s\n    np.exp(-s, out=s)\n    s *= np.exp(1.25)\n    return s", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": 30.660573419879416, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite the target as exp(1 + sin(x) - sin(x)^2).\n    This reduces to a single sine evaluation and a single exponent evaluation, with in-place updates to\n    minimize temporaries and passes for large arrays.\n    \"\"\"\n    s = np.sin(x)      # compute sin(x)\n    s -= s * s          # s = sin(x) - sin(x)^2\n    s += 1.0            # s = 1 + sin(x) - sin(x)^2\n    np.exp(s, out=s)    # exp in place\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 30.912720712459404, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1.0 + sin(x) - sin(x)**2).\n    Compute sin(x) once, square it into a separate buffer to avoid an in-expression temporary,\n    then combine and apply exp in-place to minimize temporaries.\n    \"\"\"\n    s = np.sin(x)\n    buf = np.empty_like(x)\n    np.multiply(s, s, out=buf)  # buf = sin(x)^2\n    s -= buf                    # s = sin(x) - sin(x)^2\n    s += 1.0                    # s = 1 + sin(x) - sin^2(x)\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 30.953171113707757, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: This approach reduces the computation to a single sine evaluation per element\n    by using the identity cos^2(x) = 1 - sin^2(x). It then folds the remaining arithmetic\n    into an in-place operation to minimize temporaries and passes, yielding:\n    exp(1 + sin(x) - sin(x)^2) which matches exp(sin(x) + cos(x)**2) within float64 precision.\n    \"\"\"\n    s = np.sin(x)\n    s -= s * s\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "explore"}
{"type": "mutation", "generation": 2, "zscore": -34.33055145600581, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use a single complex exponential to obtain sin and cos from exp(i*x),\n    then in-place convert cos to cos^2 and assemble the exponent sin + cos^2 without\n    computing sin and cos separately. This reduces transcendental evaluations and\n    avoids extra temporaries, while preserving exact results (within float64).\n    \"\"\"\n    z = np.exp(1j * x)      # z = exp(i*x) = cos(x) + i*sin(x)\n    z.real *= z.real        # replace cos(x) with cos(x)^2 in-place\n    inner = z.imag + z.real # inner exponent: sin(x) + cos(x)^2\n    return np.exp(inner)", "operator": "explore"}
{"type": "mutation", "generation": 3, "zscore": 33.30384832561551, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin to minimize allocations, then compute sin^2 into a scratch array and form\n    1 + sin - sin^2 before applying exp in-place. This matches exp(sin(x) + cos(x)**2) using\n    cos^2 = 1 - sin^2.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)**2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.7408000936309, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin in-place, compute sin^2 into a dedicated scratch array to minimize allocations,\n    then form 1 + sin - sin^2 and apply exp in-place to avoid extra temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n    x -= scratch\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.28813742297176, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2)\n    into exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place to reuse the input buffer,\n    then compute sin^2 into a temporary, subtract it in-place, add 1, and finally apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)**2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 31.005639219903056, "text": "def build_func(x):\n    \"\"\"\n    Fast in-place computation using sin(x) in place and sin^2 used via in-place expression.\n    Rewrites exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) to reduce transcendental calls and memory.\n    \"\"\"\n    np.sin(x, out=x)\n    # x now holds sin(x)\n    x -= x * x  # x = sin(x) - sin(x)^2\n    x += 1.0    # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 3, "zscore": 33.170060258300865, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place computation to minimize allocations:\n    - Compute sin(x) in-place to reuse the input buffer memory.\n    - Compute sin^2 via x -= x * x (uses a temporary for x * x) to form 1 + sin(x) - sin(x)^2.\n    - Apply exp in-place to minimize memory traffic.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= x * x\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.81762393022938, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) in-place to reuse input memory, then compute sin^2 into a preallocated scratch array t\n    to avoid creating an intermediate temporary. Then form 1 + sin - sin^2 and apply exp in-place.\n    This minimizes allocations and passes while preserving exact math.\n    \"\"\"\n    np.sin(x, out=x)           # x now holds sin(x)\n    t = np.empty_like(x)        # scratch for sin^2\n    np.multiply(x, x, out=t)    # t = sin(x)^2\n    x -= t                      # x = sin(x) - sin(x)^2\n    x += 1.0                    # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)            # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 31.98053564643431, "text": "def build_func(x):\n    \"\"\"\n    In-place computation with a cached scratch array to minimize allocations.\n    Computes exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    \"\"\"\n    np.sin(x, out=x)\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    x2 = build_func._scratch\n    np.multiply(x, x, out=x2)  # x2 holds sin(x)^2\n    x -= x2                    # x = sin(x) - sin(x)^2\n    x += 1.0                   # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.15613508404377, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place approach to reduce temporaries and passes:\n    - Apply sin in-place to reuse input buffer.\n    - Compute sin^2 into a temporary via t = x * x, then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": -35.45380787608601, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use a complex-valued intermediate to fuse sin(x) and cos(x)^2 computations in a single buffer.\n    - w = exp(i * x) yields w.real = cos(x) and w.imag = sin(x)\n    - Exponent = sin(x) + cos(x)^2 = w.imag + w.real^2\n    - Update w.imag in place: w.imag += w.real * w.real\n    - Exponentiate in place: exp(w.imag)\n    - Return the in-place result: w.imag\n    This avoids creating separate sin and cos arrays and minimizes temporary allocations and passes.\n    \"\"\"\n    w = np.exp(1j * x)\n    w.imag += w.real * w.real\n    np.exp(w.imag, out=w.imag)\n    return w.imag", "operator": "explore"}
{"type": "mutation", "generation": 3, "zscore": 33.61158307650369, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) once, then compute sin^2 into a temporary,\n    subtract it in-place, add 1, and finally apply exp in-place to minimize memory traffic.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)**2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 3, "zscore": 31.880137166221974, "text": "def build_func(x):\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 3, "zscore": 29.753991027803362, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin to reuse input memory, then compute sin^2 in a temporary\n    to form 1 + sin(x) - sin(x)^2, and apply exp in-place. This minimizes passes\n    and allocations while preserving exact math in float64.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 32.98627726945308, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use in-place sin into x to reuse memory, then compute sin^2 into a temporary array,\n    then form 1 + sin - sin^2 and apply exp in place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.18203327354172, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use in-place computation by computing sin(x) once, then form 1 + sin(x) - sin(x)^2\n    via the identity cos^2(x) = 1 - sin^2(x), while minimizing passes and temporaries.\n    Finally, apply exp in-place to return the exact same results as the naive expression.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= x * x\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 32.81284358757111, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: After computing sin into x, compute sin * (1 - sin) in a single pass by first creating a temporary array\n    for (1 - sin(x)) and then multiplying by sin(x). This avoids explicitly forming sin(x)^2 and reduces the number of\n    passes over the data, improving performance on large arrays while preserving mathematical correctness.\n    \"\"\"\n    np.sin(x, out=x)\n    temp = 1.0 - x\n    x *= temp\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.229707093574206, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sine computation to reuse memory and minimize allocations.\n    - Compute sin(x) in-place to reuse the input buffer.\n    - Compute sin^2 into a scratch array to avoid mutating the sine values before squaring.\n    - Form the exponent as 1 + sin - sin^2 and apply exp in-place to minimize memory traffic.\n    - This yields exp(sin(x) + cos(x)**2) using the identity cos^2 = 1 - sin^2.\n    \"\"\"\n    np.sin(x, out=x)\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 32.29867491547097, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use sin once and sin^2 stored in a reusable scratch buffer to minimize allocations.\n    Then apply exp in-place to produce exp(1 + sin(x) - sin^2(x)) which equals exp(sin(x) + cos(x)**2).\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s = x\n    np.sin(s, out=s)\n    np.multiply(s, s, out=build_func._scratch)  # scratch = sin(x)^2\n    s -= build_func._scratch                    # s = sin(x) - sin(x)^2\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.42649553083721, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) via the identity cos^2(x) = 1 - sin^2(x),\n    yielding exp(1.0 + sin(x) - sin(x)**2). Compute sin(x) in-place, store sin^2 in a scratch\n    buffer, then combine and exponentiate in-place to minimize temporaries and passes.\n    \"\"\"\n    # s = sin(x) in-place\n    np.sin(x, out=x)\n    # t = s^2\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)\n    # s = 1 + s - s^2\n    x -= t\n    x += 1.0\n    # exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.178418933780506, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) in-place to reuse the input buffer, then compute sin^2 into a temporary array\n    to form 1 + sin(x) - sin(x)^2, and finally exponentiate in-place to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0   # 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.56472302360447, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then form sin(x) * (1 - sin(x)) in-place to get 1 + sin - sin^2,\n    and finally apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x *= (1.0 - x)\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 31.188946563615026, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x),\n    performing in-place updates to minimize temporaries and passes.\n    \"\"\"\n    s2 = np.empty_like(x)\n    np.sin(x, out=x)        # x now holds sin(x)\n    np.multiply(x, x, out=s2)  # s2 = sin(x)^2\n    x += 1.0                   # x = sin(x) + 1\n    x -= s2                    # x = 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)           # x = exp( ... )\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 3, "zscore": 31.095499059709862, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) once, then compute sin^2 into a temporary,\n    form the exponent, and apply exp in-place to minimize temporaries and memory traffic.\n    \"\"\"\n    s = np.sin(x)\n    t = s * s  # sin(x)**2\n    s -= t\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.74206957886099, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place, then compute sin^2 into a\n    single scratch buffer, combine, and apply exp in-place to minimize allocations\n    and passes on large arrays.\n    \"\"\"\n    # Step 1: s = sin(x) in-place\n    np.sin(x, out=x)\n    # Step 2: t = sin(x)^2\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)\n    # Step 3: x = 1 + sin(x) - sin(x)^2\n    x -= t\n    x += 1.0\n    # Step 4: exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.205574599146395, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) once in-place, compute sin(x)^2 in a temporary scratch buffer, then apply exp in-place\n    to minimize allocations and passes while preserving float64 precision.\n    \"\"\"\n    # Step 1: s = sin(x) in-place\n    np.sin(x, out=x)\n    # Step 2: t = sin(x)^2\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)\n    # Step 3: s = 1 + sin(x) - sin(x)^2\n    x -= t\n    x += 1.0\n    # Step 4: exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 32.14766436004353, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) via sin-first approach with a scratch buffer\n    for sin(x)**2 to minimize allocations. Reuse a function-scoped scratch array across calls\n    when possible to reduce per-call allocations on large inputs.\n    \"\"\"\n    # Reuse a persistent scratch buffer for sin^2 if possible\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    np.sin(x, out=x)                  # x now holds sin(x)\n    buf = build_func._scratch\n    np.multiply(x, x, out=buf)        # buf = sin(x)^2\n    x -= buf                           # x = sin(x) - sin(x)^2\n    x += 1.0                           # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)                   # x = exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.3096375821194, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place computation to minimize allocations:\n    - Compute sin(x) in-place to reuse the input buffer and avoid a separate array.\n    - Use the identity cos(x)^2 = 1 - sin(x)^2 to rewrite the exponent as 1 + sin(x) - sin(x)^2.\n    - Perform sin, then subtract sin^2 in-place, add 1, and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= x * x  # x = sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.752414687863926, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin in-place to reuse memory,\n    square it into a scratch array t, then form the exponent and exponentiate in place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.2657628122148, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place with a single scratch array to minimize allocations.\n    - Compute sin(x) into the input buffer (in-place)\n    - Compute sin(x)^2 into a scratch\n    - Do exponent argument = 1 + sin(x) - sin(x)^2\n    - Apply exp in-place\n    \"\"\"\n    np.sin(x, out=x)\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t                    # x = sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 3, "zscore": -34.1302665939136, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the complex-exponential trick to compute sin and cos in a single vectorized operation.\n    Let w = exp(i*x) = cos(x) + i*sin(x). Then sin(x) + cos(x)^2 = Im(w) + Re(w)^2.\n    Compute w = exp(1j * x), form arg = Re(w)^2 + Im(w), and return exp(arg).\n    This avoids explicit sin/cos calls and reduces passes over the data while staying purely NumPy-based.\n    \"\"\"\n    w = np.exp(1j * x)      # w = cos(x) + i*sin(x)\n    arg = w.real * w.real   # cos(x)^2\n    arg += w.imag            # + sin(x)\n    return np.exp(arg)        # exp(sin(x) + cos(x)^2)", "operator": "explore"}
{"type": "mutation", "generation": 3, "zscore": 33.06053492854082, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos(x)**2 = 1 - sin(x)**2 to reduce to a single sine calculation\n    and a single exponential, minimizing temporaries:\n    - Compute sin(x) in-place\n    - Compute sin(x)**2 into a temporary t\n    - Form exponent = 1 + sin(x) - sin(x)**2\n    - Exp in-place to produce final result\n    This approach reduces the number of transcendental evaluations and allocations while\n    preserving float64 numerical fidelity closely enough for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)**2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.243735410185074, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) once in-place, then compute sin^2 into a temporary, subtract it, add 1, and finally apply exp in-place\n    to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 3, "zscore": 33.11257941245674, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place computation to minimize allocations:\n    - Compute sin(x) in place to reuse the input buffer memory.\n    - Compute sin^2 into a temporary, then form 1 + sin(x) - sin(x)^2 and apply exp in place.\n    - This implements exp(sin(x) + cos(x)**2) via cos^2(x) = 1 - sin^2(x) while minimizing temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": -37.16776464790397, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the complex exponential trick to compute sin(x) and cos(x) in a single pass.\n    Let z = exp(i*x). Then Re(z) = cos(x), Im(z) = sin(x).\n    We form the exponent as sin(x) + cos(x)^2 = Im(z) + (Re(z))^2 by mutating the imaginary part in place.\n    Finally, apply exp to that real exponent. This avoids separate sin/cos evaluations and yields\n    the same result as exp(sin(x) + cos(x)**2) with fewer passes over the data.\n    \"\"\"\n    z = np.exp(1j * x)\n    z.imag += z.real * z.real\n    return np.exp(z.imag)", "operator": "explore"}
{"type": "mutation", "generation": 3, "zscore": 33.4893324990659, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a scratch array by x*x, combine and apply exp in-place to minimize allocations and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.228822545598476, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place, then form sin^2 into a temporary,\n    subtract, add 1, and apply exp in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)**2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.82532437575736, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin into input buffer to minimize allocations; compute sin^2 into a temporary array t,\n    then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.63547092003157, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin into the input buffer and use a dedicated scratch array to hold sin^2,\n    then form 1 + sin - sin^2 in-place and apply exp. This minimizes temporaries and passes while\n    preserving exp(sin(x) + cos(x)**2) via the identity cos^2(x) = 1 - sin^2(x).\n    \"\"\"\n    scratch = np.empty_like(x)\n    np.sin(x, out=x)             # x := sin(x)\n    np.multiply(x, x, out=scratch)  # scratch := sin^2(x)\n    np.subtract(x, scratch, out=x)  # x := sin(x) - sin^2(x)\n    x += 1.0                       # x := 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.160052899323986, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin(x) reduces allocations. Then compute sin^2 into a temporary\n    and form the exact exponent 1 + sin - sin^2, finally applying exp in-place.\n    This yields exp(sin(x) + cos(x)**2) by cos^2 = 1 - sin^2.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 3, "zscore": 33.10928374590293, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos^2(x))\n    as exp(1 + sin(x) - sin^2(x)). Compute sin(x) in-place into x to minimize allocations,\n    compute sin^2 into a scratch array, then combine and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)                 # x now holds sin(x)\n    scratch = np.empty_like(x)       # scratch for sin(x)^2\n    np.multiply(x, x, out=scratch)   # scratch = sin(x)^2\n    x += 1.0                         # x = 1 + sin(x)\n    x -= scratch                     # x = 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)                 # x = exp(...)  (in-place)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 3, "zscore": 31.144595723464448, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) once and reuse memory to form the exact expression exp(sin(x) + cos(x)**2) by\n    rewriting it as exp(1 + sin(x) - sin(x)**2). This minimizes allocations by using a preallocated\n    scratch array for sin^2 and performing in-place updates to the output buffer.\n    Steps:\n    - s = sin(x) (stored in preallocated buffer)\n    - t = s * s (sin^2) stored in a separate preallocated scratch buffer\n    - s = 1 + sin(x) - sin(x)^2\n    - s = exp(s) (in-place)\n    - return s\n    \"\"\"\n    s = np.empty_like(x)\n    t = np.empty_like(x)\n    np.sin(x, out=s)\n    np.multiply(s, s, out=t)  # t = sin(x)^2\n    s -= t\n    s += 1.0\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.182572493793835, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.0 + sin(x) - sin(x)**2).\n    Further rewrite as exp(1.25 - (sin(x) - 0.5)**2) to allow in-place computation\n    with a single in-place sine evaluation and no extra temporaries.\n    Steps:\n    - Compute sin(x) in-place\n    - Compute (sin(x) - 0.5)^2 in-place\n    - Convert to 1.25 - that value in-place\n    - Exponentiate in-place\n    This minimizes allocations and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)   # x := sin(x)\n    x -= 0.5             # x := sin(x) - 0.5\n    x *= x               # x := (sin(x) - 0.5)^2\n    x *= -1.0            # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.2195908212642, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x),\n    i.e., exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place to reuse memory, then compute\n    sin^2(x) into a per-call scratch buffer to avoid extra allocations, and apply exp in-place.\n    To minimize allocations across repeated calls, reuse a preallocated scratch buffer when possible.\n    \"\"\"\n    np.sin(x, out=x)\n    t = getattr(build_func, \"_scratch\", None)\n    if t is None or t.shape != x.shape:\n        t = np.empty_like(x)\n        build_func._scratch = t\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t                    # x = sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.41563359415123, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1.0 + sin(x) - sin(x)**2). Compute sin(x) in-place, compute sin^2 into a scratch\n    buffer, then form the exponent and exponentiate in-place to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 4, "zscore": 33.268520714409945, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin into input buffer; compute sin^2 into a scratch array t,\n    then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.30442158667296, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to compute exp(sin(x) + cos(x)**2)\n    with in-place operations and a single scratch buffer to minimize allocations.\n    \"\"\"\n    t = np.empty_like(x)\n    np.sin(x, out=x)        # x now holds sin(x)\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t                   # x = sin(x) - sin(x)^2\n    x += 1.0                 # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 4, "zscore": 33.4695779485331, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using cos^2 = 1 - sin^2; compute sin in-place and then adjust with a single in-expression for sin^2 to minimize temporaries, then exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= x * x\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.72574789918774, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place to reuse memory, square it into a scratch array t, then form the exponent and\n    exponentiate in place. This minimizes passes and allocations while preserving numerical equivalence\n    to the naive expression.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.22697018119346, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos(x)**2 = 1 - sin(x)**2 to reduce to a single sin evaluation.\n    Compute sin(x) in-place, compute sin^2 into a scratch array t, then form the exponent 1 + sin(x) - sin(x)^2\n    and exponentiate in-place to minimize allocations and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 4, "zscore": 33.51024244588828, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin in-place, compute sin^2 into a scratch\n    array t, then form the exponent and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.48876483872602, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) via the identity exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, reuse a preallocated scratch buffer for sin^2 to minimize allocations\n    across large arrays, then form the exponent and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)  # x now holds sin(x)\n    # Reuse a preallocated scratch buffer for sin^2\n    if not hasattr(build_func, \"_scratch_t\") or build_func._scratch_t.shape != x.shape:\n        build_func._scratch_t = np.empty_like(x)\n    t = build_func._scratch_t\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t                    # x = sin(x) - sin(x)^2\n    x += 1.0                  # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.489015441168256, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(1 + sin(x) - sin(x)**2) by evaluating sin(x) in-place and reusing a persistent scratch buffer for sin(x)**2 to minimize allocations and passes.\n    This leverages the identity cos(x)**2 = 1 - sin(x)**2 to avoid an explicit cos evaluation while preserving float64 precision within typical tolerances.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s = build_func._scratch\n    np.sin(x, out=x)         # x now holds sin(x)\n    np.multiply(x, x, out=s)   # s = sin(x)^2\n    x -= s                     # x = sin(x) - sin(x)^2\n    x += 1.0                   # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)           # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.2630542970842, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin into input buffer, then compute sin^2 using a temporary\n    array t = x * x to minimize allocations, combine to 1 + sin - sin^2,\n    and exponentiate in-place to minimize passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.25679335970566, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently by using cos^2(x) = 1 - sin^2(x),\n    i.e., exp(1 + sin(x) - sin(x)^2). Sin is computed in-place; sin^2 is stored in a\n    scratch buffer to minimize temporaries and passes.\n    \"\"\"\n    # Step 1: s = sin(x) in-place\n    np.sin(x, out=x)\n    # Step 2: t = sin(x)^2\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)\n    # Step 3: x = 1 + sin(x) - sin(x)^2\n    x -= t\n    x += 1.0\n    # Step 4: exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.25271965641908, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently by:\n    - Using cos^2(x) = 1 - sin^2(x) to express the exponent as 1 + sin(x) - sin(x)^2.\n    - Calculating sin(x) in-place to reuse memory.\n    - Squaring sin(x) into a reusable scratch buffer to form sin^2(x) without extra temporaries.\n    - Doing the final exponentiation in-place to minimize passes and allocations.\n    - Reusing a global scratch buffer across calls to avoid per-call allocations for large arrays.\n    \"\"\"\n    global _sin2_scratch\n    try:\n        t = _sin2_scratch\n        if t is None or t.shape != x.shape:\n            _sin2_scratch = np.empty_like(x)\n            t = _sin2_scratch\n    except NameError:\n        _sin2_scratch = np.empty_like(x)\n        t = _sin2_scratch\n\n    np.sin(x, out=x)        # x now holds sin(x)\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t                    # x = sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)          # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 4, "zscore": 32.580554625542945, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) into the input buffer to reuse memory, then compute sin^2 into a dedicated\n    scratch buffer to avoid extra temporaries. Form the exponent as 1 + sin(x) - sin^2(x) and apply exp\n    in-place. Reuse a preallocated scratch buffer to minimize allocations and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)              # x := sin(x)\n    np.multiply(x, x, out=scratch)  # scratch := sin(x)^2\n    x -= scratch                   # x := sin(x) - sin(x)^2\n    x += 1.0                       # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 4, "zscore": 33.87024172834152, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) via the identity cos^2(x) = 1 - sin^2(x),\n    yielding exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place, then compute sin^2 into\n    a scratch array to avoid creating additional temporaries, combine and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)            # x := sin(x)\n    t = np.empty_like(x)         # scratch for sin^2\n    np.multiply(x, x, out=t)     # t := sin(x)^2\n    x -= t                       # x := sin(x) - sin(x)^2\n    x += 1.0                     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": -34.43951452443393, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the complex-exponential trick to compute sin(x) and cos(x) in a single pass.\n    w = exp(i * x) yields w.real = cos(x), w.imag = sin(x).\n    Then exponent = sin(x) + cos(x)**2 = w.imag + w.real**2. Update w.imag in-place and compute exp on it.\n    Return w.imag as the final real-valued array.\n    \"\"\"\n    w = np.exp(1j * x)\n    w.imag += w.real * w.real\n    np.exp(w.imag, out=w.imag)\n    return w.imag", "operator": "explore"}
{"type": "mutation", "generation": 4, "zscore": -38.32603829563056, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use complex exponent to compute sin and cos in a fused manner.\n    - Build w as a complex copy of x (imaginary part 0), then multiply by 1j to obtain i*x.\n    - Compute w = exp(i*x) in place, so w.real = cos(x) and w.imag = sin(x).\n    - Update the exponent in place: w.imag += w.real * w.real  (i.e., sin(x) + cos(x)^2).\n    - Finally, compute exp(w.imag) into the output array x.\n    This minimizes passes and temporaries while preserving exact math.\n    \"\"\"\n    w = x.astype(np.complex128, copy=True)\n    w *= 1j\n    np.exp(w, out=w)\n    w.imag += w.real * w.real\n    np.exp(w.imag, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 4, "zscore": 33.24376920644319, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently by using cos^2(x) = 1 - sin^2(x),\n    so the exponent becomes 1 + sin(x) - sin(x)^2. Compute sin in-place to reuse memory,\n    then compute sin^2 into a temporary array t, combine, and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 4, "zscore": -31.66752789814045, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the complex exponential representation to fuse sin and cos computations.\n    For each x: z = exp(i*x) => Re(z) = cos(x), Im(z) = sin(x).\n    The target exponent is sin(x) + cos(x)^2 = Im(z) + (Re(z))^2.\n    Compute z in a single vectorized operation, then exponentiate the real exponent and store\n    the result back into x to minimize temporaries.\n    \"\"\"\n    z = np.exp(1j * x)\n    exp_arg = z.imag + z.real * z.real\n    np.exp(exp_arg, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 4, "zscore": 32.20626813438839, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: compute sin in-place, use a preallocated scratch buffer to hold sin^2 to minimize allocations,\n    then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    global _scratch\n    try:\n        scratch = _scratch\n        if scratch is None or scratch.shape != x.shape:\n            _scratch = np.empty_like(x)\n            scratch = _scratch\n    except NameError:\n        _scratch = np.empty_like(x)\n        scratch = _scratch\n\n    np.sin(x, out=x)\n    np.multiply(x, x, out=scratch)\n    x -= scratch\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.39325074688483, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a scratch array t (via t = x * x) to minimize allocations,\n    then form the exponent and apply exp in-place to preserve memory and performance.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.40897267040074, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place into the input buffer, accumulate sin^2 into a preallocated scratch array to avoid\n    repeated allocations, then form the exponent and apply exp in-place. Reuse a function-level scratch to\n    minimize allocations across calls.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)            # x := sin(x)\n    np.multiply(x, x, out=scratch)  # scratch := sin(x)^2\n    np.subtract(x, scratch, out=x)  # x := sin(x) - sin(x)^2\n    x += 1.0                    # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)            # x := exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": -37.20900198120643, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use a completely different paradigm: compute exp(sin(x) + cos(x)**2) via the complex exponential bridge.\n    Compute z = exp(i * x) so that z.real = cos(x) and z.imag = sin(x). Then the target exponent is sin(x) + cos^2(x) = z.imag + (z.real)^2.\n    We perform a single fused in-place update on the imaginary component to form the desired exponent, and finally apply exp to that real\n    exponent in-place to produce the result. This avoids separate sin/cos evaluations and leverages a single complex exponential as the\n    initial data carrier.\n    \"\"\"\n    z = np.exp(1j * x)\n    z.imag += z.real * z.real\n    return np.exp(z.imag)", "operator": "explore"}
{"type": "mutation", "generation": 4, "zscore": 32.644321787951334, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin into input buffer to reuse memory, then compute sin^2 into a preallocated scratch array to minimize allocations, then form and exponentiate in place.\n    \"\"\"\n    np.sin(x, out=x)\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n    np.multiply(x, x, out=t)  # t = sin(x)^2\n    x -= t                    # x = sin(x) - sin(x)^2\n    x += 1.0                  # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.9932898335954, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, compute sin^2 into a temporary array, then form the exponent and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t      # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.37580491651912, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place to reuse memory,\n    square it into a scratch-like array t, then form the exponent and exponentiate in-place\n    to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": -34.06425357450376, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) with a single complex exponential to get cos(x) and sin(x) in one pass,\n    then mutate the complex buffer in-place to form the exponent and finally apply exp to that real-valued exponent.\n    Steps:\n    - z = exp(i * x)      -> z.real = cos(x), z.imag = sin(x)\n    - z.real *= z.real      -> z.real = cos(x)^2 (in-place, no extra buffer)\n    - z.imag += z.real        -> z.imag = sin(x) + cos(x)^2\n    - np.exp(z.imag, out=z.imag) -> z.imag = exp(sin(x) + cos(x)^2)\n    - return z.imag\n    This minimizes passes and temporaries while delivering exact float64 results.\n    \"\"\"\n    z = np.exp(1j * x)\n    z.real *= z.real\n    z.imag += z.real\n    np.exp(z.imag, out=z.imag)\n    return z.imag", "operator": "explore"}
{"type": "mutation", "generation": 4, "zscore": 33.34886786405556, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a scratch array by x*x, combine and apply exp in-place to minimize allocations and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.32736432517324, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity 1 + sin(x) - sin(x)**2 = 1.25 - (sin(x) - 0.5)**2 to compute\n    exp(sin(x) + cos(x)**2) without computing cos, and perform all operations in-place to minimize allocations.\n    \"\"\"\n    np.sin(x, out=x)   # x now holds sin(x)\n    x -= 0.5             # x = sin(x) - 0.5\n    x *= x               # x = (sin(x) - 0.5)^2\n    x *= -1.0            # x = -(sin(x) - 0.5)^2\n    x += 1.25            # x = 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)     # x = exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.15487665167797, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos(x)**2 = 1 - sin(x)**2 to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a scratch array t,\n    then form the exponent and exponentiate in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.96767049521902, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1.0 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a scratch array t via t = x * x,\n    combine and apply exp in-place to minimize allocations and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t      # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.21825781405658, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin into input buffer; compute sin^2 into a temporary t,\n    then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": -34.55050063899831, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use Euler's formula: exp(i*x) = cos(x) + i*sin(x). Compute z = exp(i*x) in one pass,\n    then form the exponent as sin(x) + cos(x)^2 by updating the imaginary part: z.imag += z.real**2.\n    Finally, apply exp to that real exponent in-place. This minimizes passes over the data and avoids\n    separate sin/cos evaluations.\n    \"\"\"\n    z = np.exp(1j * x)\n    z.imag += z.real * z.real\n    np.exp(z.imag, out=z.imag)\n    return z.imag", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.82168277580683, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place compute sin(x) to reuse input memory, then compute sin(x)^2 into a temporary scratch\n    and form the exponent 1 + sin(x) - sin(x)^2, finally applying exp in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)      # x now holds sin(x)\n    t = x * x               # t = sin(x)^2\n    x -= t                  # x = sin(x) - sin(x)^2\n    x += 1.0                # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)        # x = exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.74222979225441, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use sin into input buffer; compute sin^2 into a scratch array via t = x * x\n    (avoiding an explicit np.multiply call with an extra temporary), then form 1 + sin - sin^2\n    and apply exp in-place to minimize allocations and passes while preserving exact math.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.1684101931956, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin in-place to reuse memory,\n    square it into a scratch array t, then form the exponent and apply exp in-place.\n    This minimizes temporaries and passes while preserving exact math.\n    \"\"\"\n    # s = sin(x) in-place\n    np.sin(x, out=x)\n    # t = sin(x)^2\n    t = x * x\n    # x = 1 + sin(x) - sin(x)^2\n    x -= t\n    x += 1.0\n    # exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.65698973088771, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin in-place to reuse memory,\n    square sin into a scratch array to avoid extra temporaries, then form the exponent\n    and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)          # x now holds sin(x)\n    t = np.empty_like(x)       # scratch for sin(x)^2\n    np.square(x, out=t)        # t = sin(x)^2\n    x -= t                      # x = sin(x) - sin(x)^2\n    x += 1.0                    # x = 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)            # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 32.45661513855856, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: compute exp(sin(x) + cos(x)**2) efficiently by rewriting as exp(1 + sin(x) - sin(x)**2),\n    evaluating sin in-place and using a persistent scratch buffer to store sin^2 to minimize allocations\n    on large arrays. This avoids per-call allocations for the temporary sin^2 array while preserving\n    exact floating-point results.\n    \"\"\"\n    # Reuse a persistent scratch buffer for sin^2; resize if needed\n    scr = getattr(build_func, \"_scratch\", None)\n    if scr is None or scr.shape != x.shape:\n        scr = np.empty_like(x)\n        build_func._scratch = scr\n\n    # s = sin(x) in-place\n    np.sin(x, out=x)\n    # t = s^2 in scratch\n    np.multiply(x, x, out=scr)\n    # x = 1 + s - s^2\n    x -= scr\n    x += 1.0\n    # exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.42717836403966, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin into input buffer to minimize allocations; compute sin^2 into a scratch array t,\n    then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x               # t = sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.38388833316696, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Efficiently compute exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x).\n    This yields exp(1 + sin(x) - sin^2(x)). Compute sin(x) in-place, then compute sin^2 into a scratch array\n    t = x * x, combine and exponentiate in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t       # sin(x) - sin(x)^2\n    x += 1.0     # 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.21200981054593, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x),\n    after computing sin(x) in-place to reuse memory. Then form 1 + sin(x) - sin(x)^2\n    by doing x -= x * x (which computes sin^2 and subtracts it from sin), followed by\n    x += 1.0 and in-place exp to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= x * x\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.92071800200556, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) for a 1-D float64 numpy array x\n    using a single sine and a single exponential with in-place operations\n    and a single temporary buffer.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 33.72997524780682, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a temporary array t via t = x * x,\n    combine and exponentiate in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t       # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.215516331741554, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by using cos^2(x) = 1 - sin^2(x),\n    giving exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place to reuse memory, then\n    compute sin^2 via x * x and subtract, add 1, then exp in-place to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)      # x := sin(x)\n    x -= x * x              # x := sin(x) - sin(x)^2\n    x += 1.0                # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 5, "zscore": 32.41761712618877, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use in-place sin computation and the identity cos^2(x) = 1 - sin^2(x) to rewrite\n    exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2). Reuse a cached scratch array for sin^2\n    to minimize allocations on large arrays.\n    \"\"\"\n    global _sin2_scratch\n    # Allocate or reuse scratch for sin^2\n    if '_sin2_scratch' not in globals() or _sin2_scratch.shape != x.shape:\n        _sin2_scratch = np.empty_like(x)\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # Compute sin(x)^2 into scratch\n    np.multiply(x, x, out=_sin2_scratch)\n    # exponent: 1 + sin(x) - sin(x)^2\n    x -= _sin2_scratch\n    x += 1.0\n    # exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.045745186485746, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use sin in-place and the identity cos^2(x) = 1 - sin^2(x) to rewrite\n    exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place,\n    compute sin^2(x) into a temporary, update the exponent in-place, and apply exp in-place.\n    This minimizes temporaries and passes while preserving numerical accuracy.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    t = x * x         # t := sin(x)^2\n    x -= t            # x := sin(x) - sin(x)^2\n    x += 1.0          # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)  # x := exp(x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 32.92833852682253, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 via a temporary array t = x * x, combine and exponentiate in-place\n    to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.33634833770553, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp( sin(x) + cos(x)**2 ) in-place with minimal temporaries.\n    Use identity cos^2(x) = 1 - sin^2(x) to obtain exponent = 1 + sin(x) - sin^2(x).\n    Compute sin(x) in-place, store sin^2(x) in a persistent scratch buffer to avoid per-call allocations,\n    then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    global _scratch\n    scratch = globals().get(\"_scratch\", None)\n    if scratch is None or scratch.shape != x.shape:\n        _scratch = np.empty_like(x)\n        scratch = _scratch\n\n    np.sin(x, out=x)                 # x := sin(x)\n    np.multiply(x, x, out=scratch)   # scratch := sin(x)^2\n    np.subtract(x, scratch, out=x)   # x := sin(x) - sin(x)^2\n    x += 1.0                         # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)                 # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.59734342700207, "text": "def build_func(x):\n    \"\"\"\n    Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a temporary via x * x, then combine and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t       # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 33.198014280556535, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a scratch array t via a dedicated out buffer,\n    combine and apply exp in-place to minimize allocations and passes on large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    t = np.empty_like(x)       # scratch for sin^2\n    np.multiply(x, x, out=t)   # t := sin(x)^2\n    x -= t                      # x := sin(x) - sin(x)^2\n    x += 1.0                    # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.3298642917758, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a persistent scratch buffer to minimize allocations,\n    combine and exponentiate in-place. A persistent scratch buffer is reused across calls for large arrays.\n    \"\"\"\n    scr = getattr(build_func, \"_scratch\", None)\n    if scr is None or scr.shape != x.shape:\n        scr = np.empty_like(x)\n        build_func._scratch = scr\n    np.sin(x, out=x)\n    np.multiply(x, x, out=scr)  # scr := sin(x)^2\n    x -= scr                    # x := sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.79730377062211, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a scratch array t via t = x * x,\n    combine and exponentiate in-place to minimize temporaries and passes on large arrays.\n    \"\"\"\n    np.sin(x, out=x)     # x := sin(x)\n    t = x * x              # t := sin(x)^2\n    x -= t                 # x := sin(x) - sin(x)^2\n    x += 1.0               # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)       # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.98261744290422, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a temporary array t, combine and exponentiate in-place\n    to minimize temporaries and passes while preserving exact math.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    t = x * x                   # t := sin(x)^2\n    x -= t                     # x := sin(x) - sin(x)^2\n    x += 1.0                   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)           # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.42627962801218, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place to reuse memory, then compute sin^2\n    into a temporary array t via t = x * x, combine and exponentiate in-place to minimize\n    temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t       # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.37482319887857, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a persistent scratch buffer to avoid per-call allocations,\n    combine and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n    np.multiply(x, x, out=t)  # t := sin^2\n    x -= t                     # x := sin - sin^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": -38.36605598786976, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a completely different paradigm by using the complex exponential\n    to obtain sin and cos without calling numpy sin/cos separately.\n\n    Steps:\n    - Build a complex array w where w = exp(i*x). This yields w.real = cos(x) and w.imag = sin(x).\n    - Fuse the exponent: update the imaginary part in-place to store sin(x) + cos(x)**2 by\n      doing w.imag += w.real * w.real.\n    - Finally compute exp of that real exponent and store it into the output array x.\n\n    This approach avoids explicit sin/cos calls and relies on a single complex exponential,\n    followed by a real exponential, while reusing memory in-place to minimize temporaries.\n    \"\"\"\n    w = x.astype(np.complex128, copy=True)\n    w *= 1j\n    np.exp(w, out=w)\n    w.imag += w.real * w.real\n    np.exp(w.imag, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 5, "zscore": 36.65674368807859, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) and then as exp(1.25 - (sin(x) - 0.5)**2),\n    enabling a single sin evaluation and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 5, "zscore": 33.37773162206424, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a scratch buffer, form the exponent, and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = np.empty_like(x)\n    np.square(x, out=t)  # t := sin(x)^2\n    x -= t               # x := sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.20956856228491, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x),\n    which yields exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place to reuse memory,\n    then compute sin^2 into a scratch array and apply exp in-place to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)            # x := sin(x)\n    t = np.empty_like(x)         # scratch for sin^2\n    np.multiply(x, x, out=t)     # t := sin(x)^2\n    x -= t                       # x := sin(x) - sin(x)^2\n    x += 1.0                     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.52939607121079, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos^2(x)) as exp(1 + sin(x) - sin(x)^2).\n    Compute sin(x) in-place, square it into a single pre-allocated scratch buffer, then form the exponent and exponentiate in-place.\n    A static scratch buffer is reused to minimize allocations across calls.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s = build_func._scratch\n    np.sin(x, out=x)\n    np.multiply(x, x, out=s)  # s := sin^2\n    x -= s\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.10396875292682, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place, then compute sin^2 into a\n    single temporary buffer t, combine, and exponentiate in-place to minimize temporaries\n    and passes over the large array.\n    \"\"\"\n    import numpy as np\n\n    np.sin(x, out=x)             # x := sin(x)\n    t = np.empty_like(x)           # scratch buffer for sin^2\n    np.multiply(x, x, out=t)       # t := sin(x)^2\n    x -= t                         # x := sin(x) - sin(x)^2\n    x += 1.0                       # x := 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 33.83450287619012, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place, then compute sin^2 into\n    a scratch array to combine and exponentiate in-place, minimizing passes and temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.73978540880593, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then combine sin(x) - sin(x)^2 in-place by x -= x * x (which uses a temporary for the product),\n    then add 1 and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= x * x\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.83567609511449, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1.0 + sin(x) - sin(x)**2). Compute sin(x) in-place, then compute sin^2 into\n    a scratch array to avoid creating additional temporaries, combine and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 5, "zscore": 33.657325302224166, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, store sin^2(x) in a preallocated scratch array t, then form the exponent\n    and exponentiate in-place to minimize temporaries and passes on large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.267214775983206, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a scratch array via t = x * x, combine and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 5, "zscore": 33.15879308535015, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a temporary array t, combine the terms, and apply exp in-place.\n    This minimizes passes and temporaries while staying in the real domain and using a single additional buffer.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    t = x * x         # t := sin(x)^2\n    x -= t            # x := sin(x) - sin(x)^2\n    x += 1.0          # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 33.892048604473175, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) using cos^2(x) = 1 - sin^2(x),\n    yielding exp(1 + sin(x) - sin(x)**2). Compute sin in-place, then compute sin^2\n    into a scratch buffer to avoid extra temporaries, combine and exponentiate in-place.\n    This minimizes passes and allocations for large arrays.\n    \"\"\"\n    # Step 1: s = sin(x) in-place\n    np.sin(x, out=x)\n    # Step 2: t = sin(x)^2\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)\n    # Step 3: x = 1 + sin(x) - sin(x)^2\n    x -= t\n    x += 1.0\n    # Step 4: exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.171787534039844, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(1 + sin(x) - sin(x)**2) by applying sin in-place to reuse memory,\n    then compute sin^2 into a scratch array t via t = x * x, combine to 1 + sin - sin^2\n    and exponentiate in-place to minimize temporaries and passes.\n    This yields exp(sin(x) + cos(x)**2) since cos^2(x) = 1 - sin^2(x).\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.14850860768449, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently by rewriting with cos^2 = 1 - sin^2\n    to form exp(1 + sin(x) - sin(x)^2). Compute sin in-place to reuse the buffer,\n    store sin^2 in a single temporary array, then complete the exponent and apply exp in-place.\n    This minimizes temporaries and passes, avoiding Python loops and extra allocations.\n    \"\"\"\n    np.sin(x, out=x)   # x := sin(x)\n    t = x * x            # t := sin(x)^2\n    x -= t               # x := sin(x) - sin(x)^2\n    x += 1.0             # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)     # x := exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 30.46173967133528, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use in-place sin to reuse memory; compute sin^2 into a scratch buffer to form 1 + sin - sin^2, then apply exp in-place.\n    Reuse a per-function scratch buffer to avoid repeated allocations across calls.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.41152325710506, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a scratch buffer, combine and exponentiate in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = np.empty_like(x)          # scratch buffer for sin^2\n    np.multiply(x, x, out=t)      # t := sin(x)^2\n    x -= t                        # x := sin(x) - sin(x)^2\n    x += 1.0                      # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 33.44949877325059, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) using cos^2 = 1 - sin^2 to exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a temporary t via t = x * x, then form the exponent\n    and exponentiate in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t     # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.71951907877329, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place, then compute sin^2 into\n    a scratch array t, combine, and exponentiate in-place to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)  # x holds sin(x)\n    t = x * x         # t holds sin(x)^2\n    x -= t              # x := sin(x) - sin(x)^2\n    x += 1.0            # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 5, "zscore": 32.3437708143244, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, reuse a scratch buffer to hold sin^2, combine, and exponentiate in-place.\n    \"\"\"\n    t = getattr(build_func, \"_scratch\", None)\n    if t is None or t.shape != x.shape:\n        t = np.empty_like(x)\n        build_func._scratch = t\n    np.sin(x, out=x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.15106846168153, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a scratch array, combine and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t      # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 32.476922491722114, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a persistent scratch buffer to minimize per-call allocations for very large arrays.\n    Compute sin(x) in-place into the input array to reuse memory, then compute sin^2 into a cached scratch\n    buffer. Combine as 1 + sin(x) - sin(x)^2 and apply exp in-place. The scratch buffer is reused across\n    calls when shapes match, reducing memory pressure and improving cache locality on large inputs\n    (length ~10,000,000).\n    \"\"\"\n    # Maintain a persistent scratch buffer aligned with the input shape.\n    if not hasattr(build_func, \"_scratch\"):\n        build_func._scratch = None\n    scratch = build_func._scratch\n    if scratch is None or scratch.shape != x.shape:\n        scratch = np.empty_like(x)\n        build_func._scratch = scratch\n\n    # Step 1: x := sin(x)\n    np.sin(x, out=x)\n    # Step 2: t := sin(x)^2 (stored in scratch)\n    np.multiply(x, x, out=scratch)\n    # Step 3: x := sin(x) - sin(x)^2\n    x -= scratch\n    # Step 4: x := 1 + sin(x) - sin(x)^2\n    x += 1.0\n    # Step 5: exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 5, "zscore": 31.85856904258671, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) in-place using the identity\n    exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This allows a single in-place sin operation and minimal temporaries, reducing passes\n    and allocations for large arrays.\n    \"\"\"\n    np.sin(x, out=x)    # x := sin(x)\n    x -= 0.5              # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)  # x := (sin(x) - 0.5)^2\n    x *= -1.0             # x := -(sin(x) - 0.5)^2\n    x += 1.25               # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 33.257754214956, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin(x) in-place, then compute sin^2 into\n    a scratch buffer to avoid creating additional temporaries, combine, and exponentiate\n    in-place to minimize temporaries and passes on large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    t = np.empty_like(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    np.add(x, 1.0, out=x)     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.590375254879866, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by rewriting cos^2(x) as 1 - sin^2(x),\n    so the exponent becomes 1 + sin(x) - sin(x)^2. Compute sin(x) in-place to reuse memory,\n    and use a per-function scratch buffer to store sin(x)^2, minimizing temporaries.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.37389566163741, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: compute sin(x) into x, compute sin^2 into a scratch buffer, then form 1 + sin - sin^2 and exponentiate in-place.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.52942848586086, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use sin(x) once and transform sin(x) + cos(x)**2 into 1 + sin(x) - sin(x)**2\n    by using cos^2(x) = 1 - sin^2(x). Reuse a per-function scratch buffer to avoid\n    re-allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)          # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 36.509895067443594, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1.25 - (sin(x) - 0.5)**2),\n    enabling a single sin evaluation and in-place arithmetic to minimize temporaries.\n\n    Steps:\n    - s := sin(x) (in-place)\n    - x := sin(x) - 0.5\n    - x := x^2\n    - x := 1.25 - x\n    - exp in-place\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)\n    np.multiply(x, x, out=x)\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.113224113168535, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use sin(x) in-place to reuse memory, compute sin(x)^2 into a reusable scratch buffer to form\n    1 + sin(x) - sin(x)^2, and apply exp in-place to minimize temporaries and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)          # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.89469759333519, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos^2(x)) as exp(1 + sin(x) - sin(x)^2).\n    Compute sin in-place to reuse memory, then combine sin(x) - sin(x)^2 in-place by x -= x * x, then add 1 and apply exp in-place.\n    This minimizes passes and allocations for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= x * x\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 6, "zscore": 36.86020550471105, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1.25 - (sin(x) - 0.5)**2),\n    enabling a single sin evaluation and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 36.87080036593589, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    which is equivalent to exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then\n    form (sin(x) - 0.5)**2 in-place and finally apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.43289888012101, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place to reuse memory, then compute sin^2 into a per-function scratch buffer to avoid extra temporaries,\n    applying exp in-place to minimize passes and allocations on large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    np.sin(x, out=x)            # x := sin(x)\n    t = build_func._scratch\n    np.multiply(x, x, out=t)    # t := sin(x)^2\n    x -= t                       # x := sin(x) - sin(x)^2\n    x += 1.0                     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.29748588233959, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2). \n    Compute sin in-place to reuse memory, then compute sin^2 into a persistent scratch buffer to minimize allocations, \n    combine and exponentiate in-place. This reduces memory churn and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)\n    np.multiply(x, x, out=t)  # t := sin^2\n    np.subtract(x, t, out=x)  # x := sin - sin^2\n    np.add(x, 1.0, out=x)      # x := 1 + sin - sin^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.27494181204313, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by rewriting as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2 into a per-function scratch buffer to minimize temporaries,\n    combine to 1 + sin - sin^2, and exponentiate in-place. Reuse a static scratch buffer to avoid repeated allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.385276604696024, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by using cos^2(x) = 1 - sin^2(x) to avoid a separate cos evaluation.\n    Use a single in-place sin call on x, reuse a per-function scratch buffer to store sin^2, then form 1 + sin - sin^2\n    and apply exp in-place. This minimizes passes and allocations while preserving numerical results to float64 precision.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)           # x := sin(x)\n    np.multiply(x, x, out=t)     # t := sin(x)^2\n    x -= t                       # x := sin(x) - sin(x)^2\n    x += 1.0                     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 6, "zscore": 36.62292511168107, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then form (sin(x) - 0.5) and square in-place, and finally apply the remaining constant to obtain the exponent.\n    This minimizes passes and temporaries by using a single sin call and in-place operations.\n    \"\"\"\n    np.sin(x, out=x)            # x := sin(x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 6, "zscore": 36.76373578636568, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin once in-place, then reuse in-place arithmetic to minimize temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)\n    np.multiply(x, x, out=x)\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 36.75464491176567, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single sin evaluation and in-place arithmetic, minimizing temporaries and passes\n    for large arrays. This preserves exact mathematical equivalence and matches the naive result\n    within float64 precision.\n    \"\"\"\n    np.sin(x, out=x)            # x := sin(x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.022658165377734, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a per-function reusable scratch buffer to minimize\n    temporaries and allocations across large arrays. Finally apply exp in-place.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)           # x := sin(x)\n    np.multiply(x, x, out=t)    # t := sin(x)^2\n    x -= t                      # x := sin(x) - sin(x)^2\n    x += 1.0                    # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.11335419687901, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) using cos^2(x) = 1 - sin^2(x).\n    Compute sin in-place, reuse a per-function scratch buffer to store sin^2 without allocating per-call,\n    then apply exp in-place. This preserves exact math while reducing temporaries for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    # Step 1: s := sin(x) in-place\n    np.sin(x, out=x)\n    # Step 2: t := s^2 into persistent scratch\n    t = build_func._scratch\n    np.multiply(x, x, out=t)\n    # Step 3: x := 1 + s - s^2\n    x -= t\n    x += 1.0\n    # Step 4: exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.314771074201715, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently by using cos^2(x) = 1 - sin^2(x),\n    yielding exp(1.0 + sin(x) - sin(x)**2). Compute sin(x) in-place, reuse a per-function scratch buffer\n    to store sin(x)^2, then apply the exponent in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)         # x := sin(x)\n    np.multiply(x, x, out=t)   # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 6, "zscore": 32.51165542694569, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Reuse sin result and transform using cos^2 = 1 - sin^2 to compute exp(sin(x) + cos^2(x)) as exp(1 + sin(x) - sin(x)^2) with a single in-place sin, a single temporary scratch for sin^2, and in-place exp; minimizes allocations and passes.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.60044250125123, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as\n    exp(1 + sin(x) - sin(x)**2). Compute sin in-place, then compute sin^2 into a scratch buffer\n    to avoid extra temporaries, combine and exponentiate in-place. Reuse a per-function scratch buffer\n    to minimize allocations across large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.38163218839065, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Reuse a per-function scratch buffer to store sin(x)^2, allowing a single in-place sin\n    and minimizing allocations. Computes exp(1 + sin(x) - sin(x)^2) in-place.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.40021003398685, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place to reuse memory, then compute sin^2 into a per-function scratch buffer to minimize temporaries,\n    and finally exponentiate in-place. Reuse the scratch buffer across calls to avoid repeated allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.3855495785607, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, then compute sin^2(x) into a per-function scratch buffer to avoid extra temporaries,\n    then combine and exponentiate in-place to minimize passes and allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.287140295087724, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, store sin^2 in a persistent scratch buffer to avoid per-call allocations, then apply the remaining\n    in-place operations and final exp. This minimizes allocations and passes over data while preserving exact float64 results.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 6, "zscore": 36.7607998161502, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    then as exp(1.25 - (sin(x) - 0.5)**2) enabling a single sin evaluation\n    and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.30349975642689, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit cos^2(x) = 1 - sin^2(x) to compute exp(1 + sin(x) - sin(x)^2) using a single sin evaluation.\n    Compute sin(x) in-place to reuse memory, then square into a persistent scratch buffer to avoid extra allocations,\n    combine and exponentiate in-place. Reuses a per-function scratch buffer when shapes match to minimize allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n\n    np.sin(x, out=x)           # x := sin(x)\n    t = build_func._scratch\n    np.multiply(x, x, out=t)    # t := sin(x)^2\n    x -= t                       # x := sin(x) - sin(x)^2\n    x += 1.0                     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.366956588414865, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) in-place to reuse memory, then compute sin^2 into a per-call scratch buffer,\n    form 1 + sin(x) - sin(x)^2, and apply exp in-place. Reuses a function-scope scratch array to minimize allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.37885967303358, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place to reuse memory, then compute sin^2 into a per-function scratch buffer to minimize allocations.\n    This minimizes passes and allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.397316999898024, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a reusable scratch buffer to minimize temporaries, followed by in-place exp.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.43578415594933, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) using cos^2(x) = 1 - sin^2(x).\n    Compute sin(x) in-place to reuse memory, then compute sin^2(x) into a dedicated scratch buffer to\n    avoid extra temporaries, combine to yield 1 + sin - sin^2, and apply exp in-place. This minimizes\n    passes and allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.292835495967616, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) using cos^2 = 1 - sin^2,\n    then compute in-place with a persistent scratch buffer to minimize temporaries and passes while preserving exact arithmetic.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t) # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 6, "zscore": -30.421592814686345, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use a single complex exponential to fuse sin and cos computations.\n    Compute w = exp(i*x). Then cos(x) = Re(w) and sin(x) = Im(w).\n    Since f(x) = exp(sin(x) + cos(x)**2) = exp(Im(w) + Re(w)**2),\n    we can compute g = Re(w)**2 + Im(w) and then f = exp(g).\n    This reduces the number of transcendental evaluations to one (per array),\n    potentially speeding up processing for large arrays.\n    \"\"\"\n    w = np.exp(1j * x)          # complex128: w.real = cos(x), w.imag = sin(x)\n    g = w.real * w.real + w.imag  # g = cos(x)^2 + sin(x)\n    np.exp(g, out=x)            # x := exp(g)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 6, "zscore": 36.46269816787742, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to reduce the number of transcendental evaluations and temporaries.\n    Steps:\n    - Compute sin(x) in-place\n    - Subtract 0.5 in-place\n    - Square in-place\n    - Subtract from 1.25 in-place\n    - Exponentiate in-place\n    This yields exactly the same result as the naive expression for float64.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)\n    np.multiply(x, x, out=x)\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.578423335730946, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) to minimize\n    transcendental calls and temporaries. Compute sin(x) in-place, then compute sin^2 into\n    a reusable scratch array, combine to form the exponent, and apply exp in-place.\n    This reduces memory allocations and passes over the data, enabling faster processing\n    on large arrays while preserving exact float64 results.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)         # x := sin(x)\n    np.multiply(x, x, out=t)   # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 6, "zscore": 32.265140844051345, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use in-place sin to reuse memory; compute sin^2 into a per-function scratch buffer,\n    then form 1 + sin(x) - sin(x)^2 and apply exp in-place.\n    Steps:\n    - x := sin(x)\n    - t := sin(x)^2\n    - x := 1 + sin(x) - sin(x)^2\n    - x := exp(x)\n    This minimizes temporaries and passes on large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)          # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 6, "zscore": 32.34802818634888, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin in-place, then compute sin^2 into a per-function scratch buffer to minimize temporaries and allocations. Exponentiate in-place to preserve memory and reduce passes.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    np.sin(x, out=x)                # x := sin(x)\n    t = build_func._scratch\n    np.multiply(x, x, out=t)        # t := sin(x)^2\n    x -= t                          # x := sin(x) - sin(x)^2\n    x += 1.0                        # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)                # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 30.612614722897643, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a per-function scratch buffer, combine and exponentiate in-place\n    to minimize temporaries and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)       # x := sin(x)\n    np.multiply(x, x, out=t) # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 32.339585551611655, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) using cos^2 = 1 - sin^2.\n    Compute sin in-place, store sin^2 in a per-function scratch buffer to avoid temporaries,\n    then apply exp in-place. This minimizes passes and allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)          # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 36.84791902386231, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single sin evaluation and in-place arithmetic, minimizing temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 6, "zscore": 36.89476356024051, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    cos^2(x) = 1 - sin^2(x) and completing the square to get\n    exp(1.25 - (sin(x) - 0.5)^2). This allows a single sin computation in-place\n    and a few in-place operations to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)               # x := sin(x)\n    np.subtract(x, 0.5, out=x)     # x := sin(x) - 0.5\n    np.square(x, out=x)             # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)     # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.79276650639164, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then apply exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.395247935586426, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2)\n    as exp(1 + sin(x) - sin(x)**2). Compute sin in-place, then compute sin^2 into a\n    per-function scratch buffer to minimize temporaries, and exponentiate in-place.\n    Reuse a scratch buffer across calls to avoid repeated allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)      # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                # x := sin(x) + 1\n    x -= t                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.09650928142245, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)**2 in-place and finally apply exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.402623915781, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a per-function scratch buffer, combine and exponentiate in-place.\n    Reuse the scratch buffer across calls to avoid repeated allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                  # x := sin(x) + 1\n    x -= t                    # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.57093060965732, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2). Compute sin\n    in-place, square it into a per-function scratch buffer to minimize temporaries, then assemble\n    the linear combination and exponentiate in-place. Reuse the scratch buffer across calls to\n    reduce allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.361045909820106, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently by rewriting using\n    cos^2(x) = 1 - sin^2(x), so the exponent becomes 1 + sin(x) - sin(x)^2.\n    Compute sin(x) once in-place, store sin^2(x) in a per-function scratch buffer,\n    then form the exact exponent and apply exp in-place. This minimizes temporaries\n    and passes, suitable for very large arrays. Reuses scratch across calls to avoid\n    repeated allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)           # x := sin(x)\n    np.multiply(x, x, out=t)   # t := sin(x)^2\n    x -= t                     # x := sin(x) - sin(x)^2\n    x += 1.0                   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)           # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 7, "zscore": 32.35606143999725, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by using the exact identity cos^2(x) = 1 - sin^2(x),\n    yielding exp(1 + sin(x) - sin(x)**2). Compute sin in-place once, store sin^2 into a scratch buffer to\n    minimize temporaries, then finish with exponentiation in-place.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.39334174160677, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, store sin(x)**2 into a per-function scratch buffer, then\n    form 1 + sin(x) - sin(x)**2 in-place and finally apply exp in-place.\n    Reuses a per-function scratch buffer to minimize allocations across calls.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                  # x := 1 + sin(x)\n    x -= t                    # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 31.412972871922058, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a scratch buffer, combine, and exponentiate in-place.\n    This minimizes passes and temporaries by reusing a persistent scratch array.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x = x + 1.0               # x := sin(x) + 1\n    x -= t                    # x := 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 7, "zscore": 36.8539808291207, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then perform in-place arithmetic to form (sin(x) - 0.5)^2,\n    subtract from 1.25, then exponentiate in-place. This minimizes temporaries and passes\n    over the data while preserving numerical accuracy within float64.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.63595016830264, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic rewrite exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform in-place to (sin - 0.5)^2, then to 1.25 - (...) and finally exp in-place.\n    This minimizes temporaries and passes over the data while preserving float64 semantics.\n    \"\"\"\n    np.sin(x, out=x)            # x := sin(x)\n    x -= 0.5                      # x := sin(x) - 0.5\n    x *= x                        # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 7, "zscore": 36.82971686937438, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    minimize the number of passes and temporaries. Compute sin in-place, then perform\n    in-place arithmetic to form (sin(x) - 0.5)^2 and finally exp in-place.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.32594652963435, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin(x) once, then use the identity cos^2(x) = 1 - sin^2(x) to form exp(1 + sin(x) - sin(x)^2) with in-place operations and a shared scratch buffer to minimize temporaries for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)       # x := sin(x)\n    np.multiply(x, x, out=t) # t := sin(x)^2\n    x += 1.0                 # x := sin(x) + 1\n    x -= t                   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.644027208298006, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic rewrite exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sin evaluation and in-place operations, minimizing temporaries.\n    \"\"\"\n    np.sin(x, out=x)              # x := sin(x)\n    x -= 0.5                        # x := sin(x) - 0.5\n    x *= x                          # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)    # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 7, "zscore": 32.405386759881814, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a per-function scratch buffer, combine and exponentiate in-place.\n    This minimizes temporaries and the number of passes, while keeping a single sin and a single exp.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.71211258662323, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then\n    form (sin(x) - 0.5)**2 in-place and finally apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.44152438705892, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2),\n    which allows a single sin evaluation and in-place arithmetic to reduce temporaries\n    and passes. This preserves the exact result and minimizes the number of transcendental\n    evaluations for very large arrays.\n    \"\"\"\n    np.sin(x, out=x)              # x := sin(x)\n    x -= 0.5                        # x := sin(x) - 0.5\n    x *= x                          # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)     # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.152646598038025, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a per-function scratch buffer, combine and exponentiate in-place.\n    This minimizes temporaries and keeps a single pass over data where possible.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.436727209711506, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2. Compute sin in-place,\n    then compute sin^2 into a per-function scratch buffer to minimize temporaries, combine and exponentiate in-place.\n    This preserves exact float64 results (up to typical floating point precision) while reducing memory allocations\n    and passes over the data for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.80862571934419, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, adjust by 0.5, square in-place, then apply 1.25 - ...\n    and exp in-place to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 7, "zscore": 32.25199250548193, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, square it into a per-function scratch buffer to minimize temporaries, then assemble and exponentiate in-place.\n    Reuse the scratch buffer across calls to avoid repeated allocations for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.723715809159344, "text": "def build_func(x):\n    \"\"\"\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Compute sin in-place, then (sin - 0.5)^2 in-place, then 1.25 - that, then exp in-place.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 7, "zscore": 36.739689961272745, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) via the identity\n    exp(1.25 - (sin(x) - 0.5)**2), enabling a single sin computation\n    and in-place arithmetic to minimize temporaries. Use in-place\n    operations and np.square for potential speedups on large arrays.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5           # x := sin(x) - 0.5\n    np.square(x, out=x)  # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.63204972940042, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single sin evaluation and in-place arithmetic, minimizing temporaries\n    and passes for large arrays. This preserves exact mathematical equivalence within float64 precision.\n    \"\"\"\n    np.sin(x, out=x)             # x := sin(x)\n    x -= 0.5                       # x := sin(x) - 0.5\n    x *= x                         # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)   # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 31.2847029471036, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2). Compute sin in-place, then compute sin^2 into a per-function scratch buffer, combine and exponentiate in-place to minimize temporaries and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                  # x := 1 + sin(x)\n    x -= t                    # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.737067669220224, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)**2 in-place and finally exponentiate in-place.\n    This minimizes temporaries and passes for large arrays and avoids extra allocations.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.44463080475956, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2). Compute sin in-place,\n    store sin^2 in a per-function scratch buffer using np.multiply(out=) to avoid temporaries, then compute exp in-place.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                    # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.52494853721725, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) via the equivalent exp(1.25 - (sin(x) - 0.5)**2),\n    then perform in-place arithmetic to minimize temporaries and passes for large arrays.\n    Steps: compute sin in-place, subtract 0.5, square in-place, compute 1.25 - value in-place,\n    then apply exp in-place. This preserves exact mathematical equivalence up to float64 precision.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 32.11078111132808, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then compute sin^2 into a per-function scratch buffer to minimize temporaries,\n    combine and exponentiate in-place. Reuse a per-function scratch buffer to avoid allocations across large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                 # x := 1 + sin(x)\n    x -= t                   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 7, "zscore": 32.52047640972972, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently by\n    using cos^2(x) = 1 - sin^2(x) -> exp(1 + sin(x) - sin(x)^2).\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 7, "zscore": 32.30960938657884, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2). Compute sin in-place, then\n    compute sin^2 into a per-function scratch buffer to avoid extra temporaries, combine and exponentiate in-place.\n    Reuse the scratch buffer across calls to minimize allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x -= t                   # x := sin(x) - sin(x)^2\n    x += 1.0                 # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.74704218843686, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place\n    and reuse the same array for subsequent in-place operations to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)            # x := sin(x)\n    x -= 0.5                      # x := sin(x) - 0.5\n    x *= x                        # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.71198521299005, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, finally exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.787286783226605, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic rewrite exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize temporaries and passes. Compute sin in-place, then (sin - 0.5)^2 in-place,\n    then 1.25 - that value in-place, and finally exp in-place.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5            # x := sin(x) - 0.5\n    x *= x              # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 7, "zscore": 30.55711026734916, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently by using cos^2(x) = 1 - sin^2(x). \n    Compute sin in-place into x, then compute sin^2 into a dedicated per-function scratch buffer to avoid extra temporaries.\n    Then compute 1 + sin - sin^2 and exponentiate in-place.\n    This minimizes the number of passes and allocations while ensuring same results as naive.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)      # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                 # x := 1 + sin(x)\n    x -= t                   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.814461100300974, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then compute (sin(x) - 0.5)**2 in-place and finally apply exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": -32.96187091374314, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by using a single complex exponential to obtain cos and sin together:\n    w = exp(1j * x) yields w.real = cos(x) and w.imag = sin(x). Then update in-place to hold cos^2(x) + sin(x)\n    and apply exp to get the final result, minimizing temporaries and transcendental evaluations.\n    \"\"\"\n    w = np.exp(1j * x)\n    w.real *= w.real      # w.real := cos^2(x)\n    w.real += w.imag      # w.real := cos^2(x) + sin(x)\n    np.exp(w.real, out=x) # x := exp(cos^2(x) + sin(x))\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 7, "zscore": 36.75173960262084, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the identity exp(1.25 - (sin(x) - 0.5)**2). \n    Perform in-place sine, then in-place arithmetic to compute (sin(x) - 0.5)^2 and apply the remaining constants and exp.\n    This preserves numerical value (up to float64 precision) and minimizes temporaries.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.79154187028394, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the identity\n    cos^2(x) = 1 - sin^2(x) and completing the square to get\n    exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then form\n    (sin(x) - 0.5)^2 in-place and finally apply exp in-place.\n    This uses a single sin evaluation and minimizes temporaries/passes\n    for large arrays while preserving numerical equivalence to the naive\n    implementation within float64 precision.\n    \"\"\"\n    np.sin(x, out=x)               # x := sin(x)\n    np.subtract(x, 0.5, out=x)     # x := sin(x) - 0.5\n    np.square(x, out=x)             # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)     # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": -28.477304766288604, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use a single complex exponential to obtain sin and cos simultaneously.\n    Compute w = exp(i*x) in a dedicated complex buffer, then rewrite its real part in-place\n    as cos^2(x) + sin(x) via: cos^2 -> multiply real part by itself, then add imaginary part.\n    Finally apply exp to that real buffer to get exp(sin(x) + cos(x)**2) and store in x.\n    This avoids separate sin/cos evaluations and minimizes temporaries for large arrays.\n    \"\"\"\n    w = np.empty(x.shape, dtype=np.complex128)\n    np.multiply(1j, x, out=w)  # w := i * x\n    np.exp(w, out=w)            # w := exp(i*x) = cos(x) + i*sin(x)\n    wr = w.real\n    wi = w.imag\n    np.multiply(wr, wr, out=wr)  # wr := cos(x)^2\n    np.add(wr, wi, out=wr)       # wr := cos(x)^2 + sin(x)\n    np.exp(wr, out=x)            # x := exp(cos^2(x) + sin(x))\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 8, "zscore": 36.760756933162305, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform in-place arithmetic to minimize temporaries.\n    Steps: x := sin(x); x := x - 0.5; x := (x)^2; x := 1.25 - x; x := exp(x)\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.539159066672575, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize temporaries and evaluate sin only once, in-place.\n    Steps: compute sin in-place, subtract 0.5, square in-place, compute 1.25 - value in-place,\n    then apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.48275505632406, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    Compute exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x),\n    so exp(sin(x) + cos^2(x)) = exp(1 + sin(x) - sin(x)^2).\n    We compute sin(x) in-place, store sin(x)^2 into a persistent scratch buffer to avoid extra temporaries,\n    then assemble the final input to exp in-place.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.square(x, out=t)       # t := sin(x)^2\n    x += 1.0                   # x := sin(x) + 1\n    x -= t                     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)           # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 8, "zscore": 36.88814624227406, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    which keeps a single sin evaluation and allows in-place arithmetic to minimize temporaries.\n    Steps: compute sin in-place, subtract 0.5, square in-place, compute 1.25 - value in-place,\n    then apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.503567387224805, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the identity\n    exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, store sin^2 in a scratch buffer, then form\n    1 + sin - sin^2 in-place and finally apply exp in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)          # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                    # x := sin(x) + 1\n    np.subtract(x, t, out=x)   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.33404822601928, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x),\n    i.e., exp(1 + sin(x) - sin(x)**2). Perform in-place operations with a small, reusable scratch buffer.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s = x\n    t = build_func._scratch\n\n    # x := sin(x)\n    np.sin(s, out=s)\n    # t := sin(x)^2\n    np.multiply(s, s, out=t)\n    # x := 1 + sin(x) - sin(x)^2\n    s += 1.0\n    s -= t\n    # x := exp(...)\n    np.exp(s, out=s)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.577506182241045, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) via the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2) to minimize passes and temporaries. \n    Uses a single sin evaluation and in-place arithmetic.\n    \"\"\"\n    np.sin(x, out=x)             # x := sin(x)\n    np.subtract(x, 0.5, out=x)   # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.78849266134827, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place to minimize temporaries, then perform in-place arithmetic to form\n    1.25 - (sin(x) - 0.5)^2 and finally apply exp in-place.\n    This yields exactly the same result as the naive implementation up to float64 precision with a single sin evaluation.\n    \"\"\"\n    np.sin(x, out=x)       # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.42818137948174, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, store sin^2 in a scratch buffer, then form 1 + sin - sin^2 in-place\n    and exponentiate in-place. Reuses a global scratch to minimize allocations and passes\n    for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=t) # t := sin(x)^2\n    x += 1.0                  # x := sin(x) + 1\n    x -= t                    # x := 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.351380445693394, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place into x, store sin^2 into a scratch buffer, then form\n    1 + sin(x) - sin(x)^2 in-place and apply exp in-place. This minimizes temporaries\n    and passes for large arrays by reducing allocations and passes.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s2 = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=s2) # s2 := sin(x)^2\n    x -= s2                   # x := sin(x) - sin(x)^2\n    x += 1.0                  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.38359292443994, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2),\n    enabling a single sin evaluation and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5            # x := sin(x) - 0.5\n    x *= x              # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.90883343137, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exp(1.25 - (sin(x) - 0.5)^2) which is algebraically equal to exp(sin(x) + cos(x)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and subtract from 1.25, then exp in-place.\n    This minimizes temporaries and keeps a single array in use.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.664834862986936, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2), allowing a single sin evaluation and\n    in-place arithmetic to minimize temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)      # x := sin(x)\n    x -= 0.5                # x := sin(x) - 0.5\n    x *= x                  # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 8, "zscore": 36.724079065795294, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform in-place arithmetic to form (sin(x) - 0.5)^2,\n    subtract from 1.25, then exponentiate in-place. This minimizes temporaries and passes\n    over the data for large arrays while preserving float64 precision.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.76263113760205, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the exact identity\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    This allows a single in-place sin evaluation and a short in-place arithmetic\n    chain to minimize temporaries and memory traffic for large 1-D arrays.\n    \"\"\"\n    np.sin(x, out=x)     # x := sin(x)\n    x -= 0.5               # x := sin(x) - 0.5\n    x *= x                 # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)       # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 8, "zscore": 29.70413346999228, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data while preserving float64 precision.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.549699566935075, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform in-place arithmetic: subtract 0.5, square, subtract from 1.25, then exp in-place.\n    This minimizes temporaries and passes while preserving float64 accuracy.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 8, "zscore": -30.400650931462827, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use a single complex exponential to compute both cos(x) and sin(x) in one pass.\n    Compute w = exp(i*x); then w.real = cos(x) and w.imag = sin(x). Build the target\n    exponent as cos(x)^2 + sin(x) in-place on the real part, and finally take exp to obtain\n    exp(sin(x) + cos(x)^2). This reduces the number of transcendental evaluations to one\n    (complex exp) and minimizes temporaries for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty(x.shape, dtype=np.complex128)\n    w = build_func._scratch\n\n    np.multiply(1j, x, out=w)  # w := i * x\n    np.exp(w, out=w)            # w := exp(i*x) = cos(x) + i*sin(x)\n\n    wr = w.real  # cos(x)\n    wi = w.imag  # sin(x)\n\n    np.multiply(wr, wr, out=wr)  # wr := cos(x)^2\n    np.add(wr, wi, out=wr)        # wr := cos^2(x) + sin(x)\n    np.exp(wr, out=x)             # x := exp(cos^2(x) + sin(x))\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 8, "zscore": 36.70596453714012, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then apply the final subtraction\n    and exponentiation in-place to minimize temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.39413637878261, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use in-place sin into x, compute sin^2 into a shared scratch buffer, then form\n    exp(1 + sin - sin^2) in-place to minimize temporaries and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s = x\n    t = build_func._scratch\n\n    np.sin(s, out=s)          # s := sin(x)\n    np.multiply(s, s, out=t)  # t := sin(x)^2\n    s += 1.0                    # s := 1 + sin(x)\n    s -= t                      # s := 1 + sin(x) - sin(x)^2\n    np.exp(s, out=s)            # s := exp(...)\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.13707677883026, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the identity\n    exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, store sin(x)^2 in a persistent scratch array,\n    then compute 1 + sin(x) - sin(x)^2 in-place and finally apply exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)    # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                 # x := sin(x) + 1\n    x -= t                   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.78515597166354, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then compute (sin(x) - 0.5)**2 in-place and finally apply exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 8, "zscore": 29.727984328935808, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by rewriting as exp(1 + sin(x) - sin(x)**2).\n    Use an in-place sine computation and a shared scratch buffer to hold sin^2 without\n    destroying the original sin values, then apply exp in-place.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s = build_func._scratch\n\n    np.sin(x, out=x)  # x := sin(x)\n    s[...] = x          # s := sin(x)\n    s *= s              # s := sin^2(x)\n    x += 1.0            # x := sin(x) + 1\n    x -= s              # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)    # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.66963223119845, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then compute (sin - 0.5)**2 in-place and finally apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.4104639568594, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, store sin^2 in a reusable scratch buffer, then form 1 + sin - sin^2 in-place\n    and apply exp in-place to minimize temporaries for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)          # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                    # x := sin(x) + 1\n    x -= t                      # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.74789522512161, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2),\n    enabling a single sin evaluation and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 8, "zscore": 36.34447811305233, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then apply exp in-place.\n    This minimizes temporaries and passes while preserving exact float64 results.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.79833029509179, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then compute 1.25 -\n    that value in-place, and finally apply exp in-place. This minimizes temporaries\n    and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 8, "zscore": 36.57842181639759, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    in-place with minimal temporaries. This does one sin per call and a few in-place arithmetic steps,\n    suitable for very large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.74531905752199, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, subtract 0.5, square in-place, then apply 1.25 - ... and exp in-place\n    to minimize temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.89680717108099, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, then apply exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.04432119485733, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently using the identity cos^2(x) = 1 - sin^2(x),\n    so the exponent becomes 1 + sin(x) - sin^2(x). Compute sin in-place, use a scratch\n    buffer to compute sin^2, then finalize and apply exp in-place.\n    \"\"\"\n    # Reuse a static scratch buffer to avoid repeated allocations\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)           # x := sin(x)\n    np.multiply(x, x, out=t)     # t := sin(x)^2\n    np.add(x, 1.0, out=x)        # x := sin(x) + 1\n    np.subtract(x, t, out=x)     # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 8, "zscore": 36.87140795463915, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform in-place arithmetic to obtain (sin(x) - 0.5)^2 and finally\n    exp in-place. This minimizes temporaries and passes for large arrays while preserving exact float64\n    equivalence.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.415969102047775, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place (one call) and then perform in-place arithmetic to form (sin(x) - 0.5)^2\n    and finally exp in-place. This minimizes temporaries and passes while preserving numerical equivalence\n    to the naive implementation within float64 precision.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 8, "zscore": 36.77571597534057, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the algebraic identity\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2, and perform in-place,\n    minimal-temporary computations to maximize throughput on large arrays.\n    Steps (in-place): sin -> subtract 0.5 -> square -> 1.25 - value -> exp\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 8, "zscore": 36.40120683273712, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin evaluation in-place and in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.70156836664678, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the equivalent exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, adjust by 0.5, square in-place, subtract from 1.25 in-place,\n    then exponentiate in-place. This minimizes temporaries and passes while preserving\n    numerical correctness to float64 precision.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 32.17988207783738, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by rewriting as exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, store sin^2 in a separate scratch buffer, then form the\n    final exponent in-place and apply exp.\n    \"\"\"\n    # Reuse a scratch buffer to hold sin(x)^2 without additional allocations\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    t = build_func._scratch\n\n    np.sin(x, out=x)       # x := sin(x)\n    np.multiply(x, x, out=t)  # t := sin(x)^2\n    x += 1.0                 # x := sin(x) + 1\n    x -= t                   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 8, "zscore": 36.56457969803897, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize temporaries. Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and finally exp in-place.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.7541966862355, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then form\n    (sin(x) - 0.5)**2 in-place using explicit ufuncs, and finally apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)              # x := sin(x)\n    np.subtract(x, 0.5, out=x)    # x := sin(x) - 0.5\n    np.square(x, out=x)            # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)    # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)               # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.79253646865362, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, then compute 1.25 - value in-place,\n    then exp in-place. This minimizes temporaries and allocations, preserving exact float64 results.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 9, "zscore": 36.79885020482352, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform in-place arithmetic to minimize temporaries.\n    Steps: x := sin(x); x := x - 0.5; x := x^2; x := 1.25 - x; x := exp(x)\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 9, "zscore": 36.64590784252899, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place to a single array, then perform in-place arithmetic to minimize temporaries.\n    Steps: x := sin(x); x := x - 0.5; x := x^2; x := 1.25 - x; x := exp(x)\n    This yields a single sine evaluation and reduced temporaries, optimized for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 9, "zscore": 33.6061083483831, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then compute (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.58701419619041, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data while preserving double precision.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 9, "zscore": 36.681876732418395, "text": "def build_func(x):\n    \"\"\"\n    Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 9, "zscore": 36.553157253600496, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)               # x := sin(x)\n    x -= 0.5                          # x := sin(x) - 0.5\n    x *= x                            # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)      # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                   # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.639383623688666, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    compute with a single sin computation in-place and minimal temporaries. This yields a single in-place sine\n    and a few in-place arithmetic steps, reducing passes and allocations for large arrays.\n    Steps: x := sin(x); x := x - 0.5; x := x^2; x := 1.25 - x; x := exp(x)\n    \"\"\"\n    np.sin(x, out=x)   # x := sin(x)\n    x -= 0.5             # x := sin(x) - 0.5\n    x *= x               # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.67191592300458, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and allocations for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.7945836929305, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then apply in-place arithmetic to form (sin(x) - 0.5)^2, subtract from 1.25,\n    and exponentiate in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 32.32449089929077, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place into x, store sin^2 in a scratch buffer, then x = 1 + sin(x) - sin(x)^2, then exp in-place.\n    This minimizes temporaries and keeps a single large scratch array.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    s2 = build_func._scratch\n\n    np.sin(x, out=x)        # x := sin(x)\n    np.multiply(x, x, out=s2)  # s2 := sin(x)^2\n    x += 1.0                  # x := sin(x) + 1\n    np.subtract(x, s2, out=x) # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.81984405776471, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25 in-place,\n    then exponentiate in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.613879511313634, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25 in-place,\n    and exponentiate in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.86292599721167, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then apply exp in-place.\n    This minimizes temporaries and passes over the data while preserving float64 precision.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.721547534763, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, then apply exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.83724472017539, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform in-place arithmetic to minimize temporaries.\n    This preserves exact numerical equivalence and reduces temporaries.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 9, "zscore": 35.299415340799634, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.66244850707597, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 32.315482283507684, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value using\n    minimal in-place arithmetic (two ops to avoid extra allocations), then exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5            # x := sin(x) - 0.5\n    x *= x              # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)    # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.69383869479496, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.76042460329085, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, then apply the remaining\n    arithmetic and exp in-place to minimize temporaries and passes.\n    This preserves exact results in float64 due to the algebraic identity.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                      # x := sin(x) - 0.5\n    x *= x                        # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.578148417422746, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place to reuse memory, then compute (sin(x) - 0.5)^2 in-place, subtract from 1.25 in-place,\n    and exponentiate in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 9, "zscore": 32.254853603169614, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place computation of exp(sin(x) + cos(x)**2) using the identity\n    sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2.\n    Steps:\n      1) Compute sin(x) in-place.\n      2) Compute sin(x)^2 into a scratch buffer.\n      3) x := 1 + sin(x) - sin(x)^2\n      4) x := exp(x)\n    This minimizes temporaries and passes over data.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)          # x := sin(x)\n    np.multiply(x, x, out=scratch)  # scratch := sin(x)^2\n    x += 1.0                  # x := sin(x) + 1\n    np.subtract(x, scratch, out=x)  # x := 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 9, "zscore": 36.51327007018194, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, subtract from 1.25 in-place,\n    then exponentiate in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.516703153596566, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin - 0.5)^2 in-place, then compute 1.25 - (...) in-place,\n    and finally exp in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.28942416800116, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.88881680042051, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes while keeping a single array in-use.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.74567545925653, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 9, "zscore": 36.634417805574294, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)              # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.917017758543246, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2). This allows a single sin computation in-place\n    and a small number of in-place operations to minimize temporaries and passes\n    over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.56184321076839, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single array,\n    favoring explicit squared operation for potential micro-optimizations on large arrays.\n    It computes sin in-place, forms (sin(x) - 0.5)^2 in-place, then applies the remaining\n    in-place arithmetic and exponentiation to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.square(x, out=x)          # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.58065252884941, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then x := sin(x) - 0.5, square in-place, then x := 1.25 - x,\n    and finally exp in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 9, "zscore": 36.77324927360842, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data while preserving float64 precision.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 9, "zscore": 36.722229092634954, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, take 1.25 minus that, and exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.806543848588866, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then in-place (sin(x) - 0.5)^2, then 1.25 - that, then exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.853579206292366, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exp in-place.\n    This minimizes temporaries and passes over the data while preserving float64 precision.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 9, "zscore": 36.6375094723877, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then\n    perform in-place arithmetic to obtain (sin(x) - 0.5)^2 and finally exp in-place. This minimizes temporaries and passes\n    for large arrays while preserving float64 exactness.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 9, "zscore": 36.59260853968367, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform in-place arithmetic to minimize temporaries.\n    Steps: x := sin(x); x := x - 0.5; x := x^2; x := 1.25 - x; x := exp(x)\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 9, "zscore": 36.72606103566186, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    compute with a single sin() evaluation and a small number of in-place operations, minimizing temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)           # x := sin(x)\n    x -= 0.5                     # x := sin(x) - 0.5\n    x *= x                       # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.77190454387913, "text": "def build_func(x):\n    np.sin(x, out=x)\n    x -= 0.5\n    np.square(x, out=x)\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 36.631770378883274, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then apply 1.25 - that value and exp in-place.\n    This minimizes temporaries and reduces passes over large arrays (~10M elements).\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.937122015325485, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.6767192427584, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 10, "zscore": 36.68710415270053, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    compute the result in-place with a single sin per element, minimizing temporaries.\n    Steps:\n      1) Compute sin(x) in-place.\n      2) Subtract 0.5 from x, square in-place to form (sin(x) - 0.5)^2.\n      3) Subtract that from 1.25 in-place.\n      4) Exponentiate in-place.\n    This ensures minimal passes and memory allocations for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 31.943416514716077, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value\n    using minimal in-place arithmetic (two ops to avoid extra allocations), then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 27.94918077430679, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize\n    passes and transcedental calls: compute sin once, then form (sin(x) - 0.5)^2 and transform\n    to exp input with minimal temporaries. Use a function-scoped scratch buffer to avoid per-call\n    allocations for large arrays.\n    \n    Steps:\n      1) Compute sin(x) in-place.\n      2) Compute scratch = sin(x)^2.\n      3) Compute x = scratch - sin(x) + 0.25  (i.e., (sin(x) - 0.5)^2)\n      4) x = 1.25 - x\n      5) x = exp(x)\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)                # x: sin(x)\n    np.multiply(x, x, out=scratch)  # scratch: sin(x)^2\n    np.subtract(scratch, x, out=x)  # x: sin^2(x) - sin(x)\n    x += 0.25                         # x: sin^2(x) - sin(x) + 0.25\n    np.subtract(1.25, x, out=x)       # x: 1.25 - (sin^2 - sin + 0.25)\n    np.exp(x, out=x)                  # x: exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 31.901822195152604, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place into x, compute sin(x)^2 into a scratch buffer, then form\n    1 + sin - sin^2 in-place and exponentiate in-place. A persistent scratch buffer is reused\n    to minimize allocations and maintain a single-pass-like behavior over large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)         # x := sin(x)\n    np.multiply(x, x, out=scratch)  # scratch := sin(x)^2\n    x += 1.0                   # x := 1 + sin(x)\n    x -= scratch               # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)           # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 36.25496022123446, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 32.44229694995396, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, compute sin^2 into a scratch buffer, then form 1 + sin - sin^2 in-place and exponentiate.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)            # x := sin(x)\n    np.multiply(x, x, out=scratch)  # scratch := sin(x)^2\n    x += 1.0                    # x := sin(x) + 1\n    np.subtract(x, scratch, out=x)  # x := 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 32.24547152810661, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, store sin^2 in a scratch buffer, then form 1 + sin - sin^2 and exp in-place.\n    This minimizes temporaries and reuses a preallocated scratch array for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)                 # x := sin(x)\n    np.multiply(x, x, out=scratch)   # scratch := sin(x)^2\n    x += 1.0                         # x := sin(x) + 1\n    np.subtract(x, scratch, out=x)   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)                 # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 32.561066991054965, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value using\n    in-place arithmetic, then exponentiate in-place.\n    This minimizes temporaries and passes over the data.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 36.68959460746314, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value, \n    then exponentiate in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)               # x := sin(x)\n    x -= 0.5                         # x := sin(x) - 0.5\n    x *= x                           # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)     # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                 # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 10, "zscore": 36.74673361159587, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.696994234410646, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)       # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.47718432813594, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 10, "zscore": 33.09385044019689, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the algebraic identity\n    exp(1.25 - (sin(x) - 0.5)**2) = exp(sin(x) + cos(x)**2).\n    This allows a single sin computation and in-place arithmetic to minimize temporaries.\n    Steps:\n      1) Compute sin(x) in-place: x := sin(x)\n      2) In-place: x := (sin(x) - 0.5)^2\n      3) In-place: x := 1.25 - x\n      4) In-place: x := exp(x)\n    This preserves the input shape and returns x.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 29.248865777381067, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form -(sin(x) - 0.5)^2 in-place and add 1.25 to obtain 1.25 - (sin(x) - 0.5)^2, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.68909292432973, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, then apply 1.25 minus that value and exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)               # x := sin(x)\n    x -= 0.5                         # x := sin(x) - 0.5\n    np.square(x, out=x)              # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)      # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                 # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 31.994267342427577, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.583621763935305, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 31.922706103977376, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exp( sin(x) + cos(x)**2 ) = exp( 1 + sin(x) - sin(x)**2 ).\n    Compute sin(x) once in-place to minimize temporaries, then form sin(x)^2 in a scratch buffer,\n    then compute 1 + sin(x) - sin(x)^2 in-place and finally apply exp in-place.\n    This preserves numerical equality up to float64 precision while reducing memory allocations.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)                 # x := sin(x)\n    np.multiply(x, x, out=scratch)   # scratch := sin(x)^2\n    x += 1.0                         # x := sin(x) + 1\n    np.subtract(x, scratch, out=x)   # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)                  # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.799682783081586, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then compute (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.74682718897093, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place (using a dedicated square ufunc),\n    subtract from 1.25 in-place, then exponentiate in-place. This minimizes temporaries\n    and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)       # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    np.square(x, out=x)      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)         # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 32.0883922593806, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value using\n    in-place arithmetic, then exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5            # x := sin(x) - 0.5\n    x *= x              # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)    # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 31.886805072298053, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, store sin^2 in a scratch buffer, then x = 1 + sin - sin^2, then exp in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)\n    np.multiply(x, x, out=scratch)  # scratch := sin(x)^2\n    x += 1.0                         # x := sin(x) + 1\n    np.subtract(x, scratch, out=x)  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)                 # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 32.01347238493341, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value using\n    in-place arithmetic (two ops to avoid extra allocations), then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)    # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.63855657186275, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place on a single array. This minimizes temporaries and passes over\n    large arrays.\n    Steps:\n      1) Compute sin(x) in-place.\n      2) Subtract 0.5, square in-place to form (sin(x) - 0.5)^2.\n      3) Compute 1.25 - that value in-place.\n      4) Exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 36.77479024481761, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.464294403408054, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 10, "zscore": 36.72394807872572, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 36.828232916066064, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.24280515256547, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 30.819403239125943, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value using\n    minimal in-place arithmetic, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)    # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 36.824898033099544, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place computation of exp(sin(x) + cos(x)**2) using the identity\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2.\n    This minimizes temporaries and keeps a single in-place pass over the data.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 36.70178793604698, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2). This allows in-place computation with a single\n    sin operation and a small number of in-place arithmetic operations, minimizing\n    temporaries for very large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.723912953998344, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the algebraic identity\n    exp(1.25 - (sin(x) - 0.5)**2). This expression is algebraically equal to exp(sin(x) + cos(x)**2)\n    and allows a single in-place sin computation followed by a few simple in-place operations,\n    minimizing temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.36822264131585, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes by using a single sin call and a single in-place pass over the array.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 10, "zscore": 32.55395080630994, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place, store sin(x)**2 in a scratch buffer, then form 1 + sin(x) - sin(x)**2 in-place\n    and finally apply exp in-place. This minimizes temporaries and traversals on large arrays by reusing\n    a single scratch buffer across calls.\n    \"\"\"\n    if not hasattr(build_func, \"_scratch\") or build_func._scratch.shape != x.shape:\n        build_func._scratch = np.empty_like(x)\n    scratch = build_func._scratch\n\n    np.sin(x, out=x)            # x := sin(x)\n    np.multiply(x, x, out=scratch)  # scratch := sin(x)^2\n    x += 1.0                    # x := sin(x) + 1\n    np.subtract(x, scratch, out=x)  # x := 1 + sin(x) - sin(x)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 10, "zscore": 36.832077240426514, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 32.1317946256144, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, form (sin(x) - 0.5)^2 in-place, then obtain 1.25 - that value using\n    minimal in-place arithmetic (two negations/additions) and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)  # x := sin(x)\n    x -= 0.5            # x := sin(x) - 0.5\n    x *= x              # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)    # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.90349968040786, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin evaluation\n    and in-place arithmetic, minimizing temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.51109005211728, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and subtract from 1.25, then exp in-place.\n    This minimizes temporaries and keeps a single buffer in use.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 36.77324608528218, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then form (sin(x) - 0.5)^2 in-place and transform to exp input, all\n    in a single buffer to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 36.598092885921744, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then apply exp in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 32.244445418445956, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin - 0.5)^2 in-place, then transform to 1.25 - value\n    using a single negation and addition, and finally exponentiate in-place.\n    This reduces operations and avoids an extra subtract call.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.46464357826979, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize\n    temporaries and passes over large arrays. Compute sin in-place, then (sin(x) - 0.5)^2\n    in-place, then apply 1.25 - value and finally exp in-place.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 36.74634011899944, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then subtract from 1.25 and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 36.7403682776797, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, apply 1.25 - value, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.730800004364454, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25 in-place,\n    and exponentiate in-place. This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.422999520817015, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sin evaluation and in-place arithmetic, minimizing temporaries and passes\n    over the large input array. Steps are performed in-place to avoid extra allocations.\n    \n    Steps:\n      1) np.sin(x, out=x)\n      2) x -= 0.5\n      3) x *= x\n      4) np.subtract(1.25, x, out=x)\n      5) np.exp(x, out=x)\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.8535075220908, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, subtract 0.5, square in-place, then compute 1.25 - value in-place,\n    and finally exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.83841600495738, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This allows a single sin evaluation and a handful of in-place arithmetic operations, very\n    memory-efficient for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.53168313245046, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sine evaluation and in-place operations, minimizing temporaries\n    and passes over the array.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 36.584088322341344, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to perform\n    a single in-place sin, then a couple of in-place arithmetic steps, and a single exp, minimizing temporaries.\n    This preserves exact float64 results (within FP rounding) and avoids extra allocations.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 36.66566287131073, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25 in-place,\n    and exponentiate in-place. This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 34.34806119637093, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, then exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.80200978298578, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and subtract from 1.25, then exp in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 34.45994966039918, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 32.10132512023515, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then convert to 1.25 - that value\n    using in-place negation and add, then exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.321402283078285, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) for a 1D NumPy array x in-place.\n    Uses the identity exp(sin + cos^2) = exp(1.25 - (sin - 0.5)^2) and performs\n    in-place operations to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 36.63800653244807, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and subtract from 1.25, then exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.91374446341187, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays. Micro-optimize by binding\n    numpy functions to local names to reduce Python call overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.67897689656693, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize passes and temporaries.\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This yields identical results to the naive formulation within float64 precision while reducing allocations for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.86319307267281, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then compute (sin(x) - 0.5)^2, then x = 1.25 - that, then exp in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.52433287142085, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result using only a single sin evaluation and in-place arithmetic.\n    Steps:\n      1) Compute sin(x) in-place.\n      2) Form (sin(x) - 0.5)^2 in-place.\n      3) Compute 1.25 - that value in-place.\n      4) Exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 35.6856705960934, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays, yielding exact values\n    as the naive implementation up to float64 precision.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.74691072311835, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize the number of temporaries and passes over large arrays. Compute sin in-place,\n    then compute (sin(x) - 0.5)^2 in-place, convert to 1.25 - value in-place, and finally apply exp in-place.\n    This yields exact float64 results equivalent to the naive implementation while reducing\n    memory allocations and passes.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.630233021110485, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) which\n    allows a single sin evaluation and in-place arithmetic to minimize temporaries and passes.\n    Steps: compute sin in-place, subtract 0.5, square in-place, then subtract from 1.25 in-place,\n    and finally exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.84172309634687, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    sub = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)        # x := sin(x)\n    x -= 0.5              # x := sin(x) - 0.5\n    x *= x                # x := (sin(x) - 0.5)^2\n    sub(1.25, x, out=x)   # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 31.906941318620213, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form -(sin(x) - 0.5)^2 in-place and convert to 1.25 - value\n    using in-place negation and addition, then exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.83155594908674, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, apply 1.25 - value, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.636347327474255, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize passes\n    and avoid computing cos. Compute sin in-place, form (sin(x) - 0.5)^2 in-place, then apply\n    1.25 - value in-place and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.85460021463104, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then subtract 0.5, square in-place, apply 1.25 minus the result in-place,\n    and exponentiate in-place. This uses a single buffer and minimal passes for large arrays.\n    \"\"\"\n    import numpy as np\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 34.187254933689985, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.69906925026456, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and transform to exp input in-place.\n    This minimizes temporaries and passes, keeping a single buffer in use.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 11, "zscore": 34.749113473731335, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then compute (sin(x) - 0.5)^2 in-place, transform to exp input by 1.25 - value,\n    and exponentiate in-place. This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.8232045004799, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries\n    and passes. Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    Fast path for empty inputs to avoid unnecessary work.\n    \"\"\"\n    if x.size == 0:\n        return x\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.7796469690359, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result with a single sin evaluation and a few in-place operations,\n    minimizing temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.61145160088404, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.64597671037571, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, transform to exp input via\n    x := 1.25 - (sin(x) - 0.5)^2, and exponentiate in-place. This minimizes temporaries\n    and preserves exact float64 equivalence on large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.750726246265124, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    the result with a single sin evaluation and in-place arithmetic, minimizing temporaries\n    and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.281713019889295, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then convert to 1.25 - that value\n    using in-place negation and add, then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x           # x := (sin(x) - 0.5)^2\n    x *= -1            # x := - (sin(x) - 0.5)^2\n    x += 1.25          # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.90123203651046, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then convert to 1.25 - that value\n    using in-place subtraction, then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.56575417114719, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sin call and in-place arithmetic, minimizing temporaries and passes.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.16505678594476, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    with a single in-place sin evaluation and minimal temporaries. This avoids computing cos and\n    uses in-place arithmetic to maximize throughput on large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5        # x := sin(x) - 0.5\n    x *= x          # x := (sin(x) - 0.5)^2\n    x *= -1           # x := -(sin(x) - 0.5)^2\n    x += 1.25         # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.71761978253267, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize the number of transcendental evaluations. Compute sin in-place, form (sin(x) - 0.5)^2 in-place,\n    then compute 1.25 - that value, and finally exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 12, "zscore": 36.25297043996862, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then convert to 1.25 - that value\n    using in-place subtract, then exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays while preserving exact float64 equivalence.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 12, "zscore": 36.37481987282701, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to keep a single sin evaluation and perform in-place arithmetic. Micro-optimizations:\n    bind local NumPy functions to reduce Python overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 31.7850637222134, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value\n    using in-place negation and add, then exponentiate in-place to keep a single array in-use.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 12, "zscore": 36.79390394177674, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result with a single sine evaluation and in-place arithmetic,\n    minimizing temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.93157788797047, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    This mirrors the top-scoring solutions and should be fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.94285943983704, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value, then exp in-place.\n    Bind local functions to minimize Python dispatch overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.22703181186623, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sine evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.81356273624489, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2). This allows a single sin evaluation and\n    in-place arithmetic, minimizing temporaries and passes over large arrays.\n    Micro-optimize by binding numpy functions to local names to reduce Python call overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.42074999724039, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    Bind frequently used functions to locals to reduce Python lookup overhead and minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)            # x := sin(x)\n    x -= 0.5                   # x := sin(x) - 0.5\n    x *= x                     # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x)   # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)              # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 31.97541237814259, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin\n    in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - value via in-place negation and addition, then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x := sin(x)\n    x -= 0.5           # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.053343573582005, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin evaluation\n    and in-place arithmetic, minimizing temporaries and passes over large arrays. Further optimize by avoiding\n    an extra subtract call and using in-place negation/addition instead.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1            # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.65105709567954, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sin evaluation and in-place arithmetic, minimizing temporaries and passes\n    over large arrays. This preserves exact mathematical equivalence and reduces transcendental calls.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 12, "zscore": 36.90163371247756, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize transcendental evaluations and passes over data. Compute sin in-place,\n    then (sin(x) - 0.5)^2 in-place, convert to 1.25 - value, and exponentiate in-place.\n    Bind ufuncs to local names to reduce Python overhead and avoid extra allocations.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 12, "zscore": 32.37940152907759, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then in-place compute (sin(x) - 0.5)^2 and transform to 1.25 - that value using\n    in-place arithmetic, then exponentiate in-place. Bind local ufuncs to reduce Python overhead.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x           # x := (sin(x) - 0.5)^2\n    x *= -1           # x := - (sin(x) - 0.5)^2\n    x += 1.25          # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.17063970460234, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin evaluation\n    and in-place arithmetic, minimizing temporaries and passes. Use local aliases for NumPy functions to reduce Python overhead\n    and perform in-place negation and addition to avoid an extra subtract call.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)     # x := sin(x)\n    x -= 0.5            # x := sin(x) - 0.5\n    x *= x              # x := (sin(x) - 0.5)^2\n    x *= -1               # x := - (sin(x) - 0.5)^2\n    x += 1.25             # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)       # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.37685809496067, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation and minimal temporaries for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)      # x := sin(x)\n    x -= 0.5             # x := sin(x) - 0.5\n    x *= x               # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25             # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.679271232217395, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.59188457707275, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2). This keeps a single sin computation and\n    uses in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.72534626605825, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This enables a single sin evaluation and in-place arithmetic to minimize temporaries and passes.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 12, "zscore": 36.38620846786859, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then 1.25 - that value, then exp in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.75182765356375, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.82151203063568, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then convert to 1.25 - that value\n    using in-place subtraction, then exponentiate in-place. Micro-optimizations bind\n    frequently used ufuncs to locals to reduce Python overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.52687162932596, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity exp(1.25 - (sin(x) - 0.5)**2)\n    with a single in-place sin and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    sub = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)      # x := sin(x)\n    x -= 0.5           # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    sub(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 12, "zscore": 32.19682898828574, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then form (sin(x) - 0.5)^2 in-place,\n    convert to 1.25 - value using simple in-place arithmetic, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5        # x := sin(x) - 0.5\n    x *= x          # x := (sin(x) - 0.5)^2\n    x *= -1           # x := -(sin(x) - 0.5)^2\n    x += 1.25         # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.44985707767973, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single sine evaluation and in-place arithmetic, minimizing temporaries\n    and passes for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 12, "zscore": 36.76162692111488, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.93581559864981, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.419330926371, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: exploit the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This allows a single sin evaluation (in-place) and a small number of in-place operations\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.16240882786604, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then convert to 1.25 - that value\n    using in-place negation and addition, then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x           # x := (sin(x) - 0.5)^2\n    x *= -1            # x := -(sin(x) - 0.5)^2\n    x += 1.25          # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.86818030571174, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then convert to 1.25 - that value in-place,\n    and exponentiate in-place. This minimizes temporaries and number of passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.1523330261526, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value\n    using in-place negation and addition, then exponentiate in-place. This minimizes temporaries\n    and passes over the large array while preserving numerical equivalence to the naive form.\n    \"\"\"\n    sin = np.sin\n    sin(x, out=x)   # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1             # x := - (sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)    # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 12, "zscore": 36.6920430294582, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays. Bind numpy functions to\n    local names to reduce Python call overhead.\n    \"\"\"\n    sin = np.sin\n    sub = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    sub(1.25, x, out=x)      # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 35.6825018780626, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This allows a single sin evaluation and a small number of in-place operations to minimize temporaries\n    and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)           # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 32.26806214796614, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). \n    Compute sin in-place, then form -(sin(x) - 0.5)^2 in-place and convert to 1.25 - value using in-place negation and addition, then exponentiate in-place.\n    Bind common numpy functions to locals to reduce Python overhead.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5       # x := sin(x) - 0.5\n    x *= x          # x := (sin(x) - 0.5)^2\n    x *= -1         # x := -(sin(x) - 0.5)^2\n    x += 1.25       # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)   # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.112710526950494, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations and exponentiate in-place to keep a single array in-use.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.67848940148527, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Compute sin in-place, then (sin(x) - 0.5)^2 in-place, then 1.25 - that value in-place, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.51885442358632, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.20012146651331, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, negate and add 1.25, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.26435710032348, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sin evaluation and in-place arithmetic, minimizing temporaries\n    and passes over the array.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 13, "zscore": 32.07142430597907, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep\n    a single sin evaluation and perform in-place arithmetic to minimize temporaries and passes\n    over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 13, "zscore": 30.291325865787602, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin once in-place, then\n    transform to 1.25 - (sin - 0.5)^2 using in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.73517922358996, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.08269748361087, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin\n    in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This keeps a single array in-use and minimizes temporaries and passes for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.064570148511976, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations,\n    then exponentiate in-place for a single array.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 31.997954110333144, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    and keep a single array in-use, minimizing temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.72057573292591, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value\n    using in-place subtraction, then exponentiate in-place to keep a single array in-use.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 13, "zscore": 36.347472004527795, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 31.987174379325317, "text": "def build_func(x):\n    \"\"\"\n    Optimized in-place computation using identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Executes sin in-place, then performs in-place arithmetic to compute the exponent argument, and finally\n    exponentiates in-place to minimize temporaries and passes over the array.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 13, "zscore": 32.32979723064727, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    and exponentiate in-place to minimize temporaries and passes over the data.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.877335106252794, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value via in-place subtraction,\n    and finally exponentiate in-place to keep a single array in-use and minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.3807138441568, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.105647799808715, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value using in-place\n    negation and addition, then exponentiate in-place to keep a single array in-use.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5        # x := sin(x) - 0.5\n    x *= x          # x := (sin(x) - 0.5)^2\n    x *= -1           # x := -(sin(x) - 0.5)^2\n    x += 1.25        # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.2322191969631, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays. Micro-optimize by binding\n    numpy functions to local names to reduce Python call overhead.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.23740357484103, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.119339748001565, "text": "def build_func(x):\n    \"\"\"\n    Uses the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result in-place with a single sin evaluation and minimal temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x := sin(original)\n    x -= 0.5          # x := sin(original) - 0.5\n    x *= x            # x := (sin(original) - 0.5)^2\n    x *= -1           # x := -(sin(original) - 0.5)^2\n    x += 1.25         # x := 1.25 - (sin(original) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 13, "zscore": 36.47259191616271, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.23789292977966, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.21965907313666, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place\n    operations and exponentiate in-place to keep a single buffer in-use and minimize temporaries.\n    This mirrors high-scoring approaches and is efficient for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 13, "zscore": 32.208082982821345, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to exponent in-place to minimize temporaries and passes over large arrays.\n    This keeps a single array in-use and avoids extra allocations.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.106065842517175, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value\n    using in-place negation and addition, then exponentiate in-place.\n    This keeps a single array in-use and minimizes temporaries for large arrays.\n    \"\"\"\n    sin = __import__('numpy').sin\n    exp = __import__('numpy').exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.82477342268244, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    and exponentiate in-place to keep a single array in-use, minimizing temporaries and passes.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.96503786225286, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.0 + sin(x) - sin(x)**2).\n    Compute sin in-place, then form (sin - sin^2) and add 1, then exp in-place.\n    This reduces the number of arithmetic operations and passes over the array, improving performance for large arrays while preserving correctness.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= x * x\n    x += 1.0\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.6804969311005, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries\n    and passes over data. Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - value\n    and exponentiate in-place. Bind ufuncs to local names to avoid Python overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 25.015485642146018, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)      # x := sin(x)\n    x -= 0.5             # x := sin(x) - 0.5\n    x *= x               # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.2327847528988, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single\n    sin evaluation and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x := sin(x)\n    x -= 0.5           # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.78824535350981, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    with a single sine evaluation and in-place arithmetic, minimizing temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)        # x := sin(x)\n    x -= 0.5               # x := sin(x) - 0.5\n    x *= x                 # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)          # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 13, "zscore": 36.51282046304373, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    This variant binds common numpy ufuncs to local names to reduce Python call overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 30.36372515578924, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations and exponentiate in-place.\n    Keeps a single array in-use and minimizes temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)       # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.13398383668637, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place,\n    then compute (sin(x) - 0.5)^2 and convert to 1.25 - that value using in-place negation and add, then exponentiate in-place\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.87650018988883, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    This mirrors the top-scoring solutions and should be fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.17923298775426, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place computation using identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Perform a single sin pass in-place, then a sequence of in-place arithmetic to form the exponent argument,\n    and finally apply exp in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 13, "zscore": 36.82292387463227, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 32.19533318503158, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the identity exp(1.25 - (sin(x) - 0.5)**2) to reduce passes.\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, and finally transform to 1.25 - (...) and exponentiate in-place.\n    Use in-place arithmetic to minimize temporaries and passes, binding numpy ufuncs to locals for speed.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 30.91433931941247, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Transform cos^2(x) to 1 - sin^2(x) and compute using only sin(x).\n    Compute sin into x, store sin^2 in a scratch buffer, then form 1 + sin - sin^2 in-place\n    and apply exp. This diverges from the common in-place identity paths by introducing a\n    dedicated temporary buffer to decouple dependencies and maintain a clear data flow.\n    \"\"\"\n    import numpy as np\n\n    # Reuse a scratch buffer for sin^2 to avoid reallocations on large arrays\n    tmp = getattr(build_func, \"_tmp_sin2\", None)\n    if tmp is None or tmp.shape != x.shape:\n        tmp = np.empty_like(x)\n        build_func._tmp_sin2 = tmp\n\n    # x := sin(x)\n    np.sin(x, out=x)\n\n    # tmp := sin(x)^2\n    np.multiply(x, x, out=tmp)\n\n    # x := 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= tmp\n\n    # x := exp(x)\n    np.exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 14, "zscore": 32.2351195110635, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently by using the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2),\n    performing the operations in-place to minimize temporaries and passes.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 14, "zscore": 32.04994800613944, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.67928680187718, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    This performs a single sin evaluation in-place and a small in-place arithmetic chain,\n    minimizing temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 14, "zscore": 36.667066053687705, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.24307199378053, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries and passes over large arrays.\n    This keeps a single array in-use and minimizes Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.7298245359522, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single\n    sin evaluation and in-place arithmetic, minimizing temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 14, "zscore": 36.8000128279859, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.87259247097503, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.484036869748934, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.74352929058876, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.69650216939471, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, and exponentiate in-place to minimize temporaries and passes over large arrays.\n    This mirrors the top-scoring solutions and should be fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.36576256023905, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin evaluation\n    and in-place arithmetic, minimizing temporaries and passes over large arrays. This preserves a single array in-use\n    and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1             # x := -(sin(x) - 0.5)^2\n    x += 1.25           # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)       # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 14, "zscore": 36.92563697341523, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.692851376436856, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). \n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and combine to 1.25 - (...)^2 in-place before a final exp.\n    Bind local ufuncs to reduce attribute lookups and minimize Python overhead on large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.340927996373814, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single array, minimizing temporaries and passes over large arrays.\n    Compute sin in-place, transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.55891553020112, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25 and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.38396843444092, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.87780474670753, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.71434691251146, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 14, "zscore": 32.10509722900633, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.74951112199737, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 14, "zscore": 36.60203668606079, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.25171862825816, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin once in-place, then transform to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x           # x := (sin(x) - 0.5)^2\n    x *= -1          # x := -(sin(x) - 0.5)^2\n    x += 1.25        # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)    # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 14, "zscore": 32.34925606392158, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.30581995456844, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity exp(1.25 - (sin(x) - 0.5)**2)\n    with a single in-place sin evaluation and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1              # x := -(sin(x) - 0.5)^2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 14, "zscore": 36.663211207850665, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries and passes.\n    Compute sin once in-place, then compute (sin - 0.5)^2 in-place, then compute 1.25 - that value in-place, finally exponentiate in-place.\n    This preserves a single input array and avoids extra allocations, keeping passes over large arrays minimal.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 14, "zscore": 36.76804427788749, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.074145276728636, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.75599968472261, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then form (sin(x) - 0.5)^2 using in-place arithmetic, convert to 1.25 - (...)^2, and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.66960985977602, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    This mirrors the top-scoring solutions and should be fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.228900255627764, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    This evaluates sin(x) once in-place and then performs in-place arithmetic\n    to minimize temporaries and passes over the array.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1           # x := -(sin(x) - 0.5)^2\n    x += 1.25         # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 14, "zscore": 34.53979204486269, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    This mirrors the top-scoring solutions and should be fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 14, "zscore": 36.92766915942003, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then compute (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.33223470605558, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then compute (sin(x) - 0.5)^2 in-place, negate to get -(...)^2, add 1.25, then exp in-place.\n    This yields exact mathematically equivalent results and minimizes passes over the data.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.91221167557335, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.412228642292895, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries\n    and passes over large arrays. Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place operations,\n    and exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.801894790686156, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 14, "zscore": 36.78388744293132, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 32.48779213352983, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.79856176757661, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). \n    Compute sin in-place, then compute (sin - 0.5)^2 efficiently using a dedicated square ufunc\n    to potentially reduce kernel overhead, followed by in-place subtraction and exponentiation.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    square = np.square\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    square(x, out=x)          # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.16723866386639, "text": "def build_func(x):\n    \"\"\"\n    Computes exp(sin(x) + cos(x)**2) using the algebraic identity\n    exp(1.25 - (sin(x) - 0.5)**2) with a single in-place pass.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 15, "zscore": 28.747642772579198, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 15, "zscore": 32.315440250740124, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.38697050928706, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries\n    and keep a single in-place pass over the data. This avoids extra allocations while producing exact results.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.31567990659562, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity\n    exp(1.25 - (sin(x) - 0.5)**2) with in-place operations to minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)       # x := sin(x)\n    x -= 0.5              # x := sin(x) - 0.5\n    x *= x                # x := (sin(x) - 0.5)^2\n    x *= -1               # x := -(sin(x) - 0.5)^2\n    x += 1.25             # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)         # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 15, "zscore": 32.092245670470824, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays, then exponentiate in-place.\n    This keeps a single array in-use and avoids extra allocations.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1           # x := -(sin(x) - 0.5)^2\n    x += 1.25         # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.21491259017642, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    then exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1           # x := -(sin(x) - 0.5)^2\n    x += 1.25         # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.04747625622408, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sin evaluation and in-place arithmetic, minimizing temporaries and passes\n    over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 31.969894713895336, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place.\n    This keeps a single sin evaluation and a small number of in-place operations, which is fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.2493924785743, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. Then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x := sin(x)\n    x -= 0.5           # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1            # x := -(sin(x) - 0.5)^2\n    x += 1.25          # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.36521475265273, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place.\n    This keeps a single array in-use and minimizes passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.17245503128424, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.416814911859724, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.072310820089314, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries and passes over large arrays.\n    This keeps a single sin evaluation and avoids an extra subtraction call by using in-place ops.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.754116818663256, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sine in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.695863972759575, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.81177025923436, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    then exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.12246276668963, "text": "def build_func(x):\n    \"\"\"\n    In-place fused evaluation leveraging the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This performs a single sin evaluation and uses in-place arithmetic to minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5\n    x *= x          # x := (sin(x) - 0.5)^2\n    x *= -1         # x := -(sin(x) - 0.5)^2\n    x += 1.25        # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)    # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 15, "zscore": 32.22694023207347, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. This keeps a single array in-use\n    and avoids extra allocations.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.8513279291363, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize temporaries. Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2\n    using in-place arithmetic, and exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 15, "zscore": 36.845359701252974, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place to minimize temporaries and passes over large arrays.\n    This yields exact results (within float64) and reduces passes over data.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.77468758071277, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize passes and temporaries by computing sin once in-place and performing in-place arithmetic.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 30.498925545349408, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.28018065716095, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.1810259961525, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin call.\n    Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.24947335578318, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    This mirrors the top-scoring solutions and should be fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x           # x := (sin(x) - 0.5)^2\n    x *= -1          # x := -(sin(x) - 0.5)^2\n    x += 1.25        # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)    # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.76247182756773, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 15, "zscore": 32.311828727333754, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place for large 1D float64 arrays by\n    using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2),\n    which requires only a single sin evaluation and in-place arithmetic.\n    \"\"\"\n    sin = np.sin\n    sin(x, out=x)      # x now holds sin(x)\n    x -= 0.5             # x := sin(x) - 0.5\n    x *= x               # x := (sin(x) - 0.5)**2\n    x *= -1              # x := -(sin(x) - 0.5)**2\n    x += 1.25            # x := 1.25 - (sin(x) - 0.5)**2\n    np.exp(x, out=x)     # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 15, "zscore": 32.20340979991678, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    keep a single sin evaluation and perform in-place arithmetic to minimize temporaries\n    and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x           # x := (sin(x) - 0.5)^2\n    x *= -1          # x := -(sin(x) - 0.5)^2\n    x += 1.25        # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)    # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.90831803843376, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    This keeps a single array in-use and minimizes passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.36466423498912, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.88048139972239, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.40782699850619, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.67540373935295, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries and passes.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place for a single array pass.\n    This preserves exactness up to float64 precision.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.61697654514286, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, then exponentiate in-place.\n    This keeps a single array and minimizes temporaries for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.66257269238291, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic, then exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.22228346904902, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.360364883335855, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit the algebraic identity sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2 to avoid the cos computation.\n    Compute sin(x) in-place, then perform in-place arithmetic to obtain the exponent argument and finally exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x := sin(x)\n    x -= 0.5           # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1            # x := - (sin(x) - 0.5)^2\n    x += 1.25          # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # x := exp(...)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 15, "zscore": 32.32817724208618, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin evaluation\n    and in-place arithmetic, minimizing temporaries and passes over large arrays.\n    This variant keeps a single array in-use and uses in-place transforms to avoid temporaries and repeated passes.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 32.42077441938389, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.7946517105569, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.24366805137057, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    then exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.200686544200074, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) for a 1-D NumPy array in-place, using the\n    identity sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2 to minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 16, "zscore": 32.31431227405619, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.240481531851614, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 16, "zscore": 36.99895800853203, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.937834074851786, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.279915919805724, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 29.86008566539346, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.282809857253646, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place (single evaluation) and perform in-place arithmetic to minimize temporaries\n    and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 31.682546280383853, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    then exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.68077808833584, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with minimal temporaries. Compute sin in-place, then form (sin(x) - 0.5)^2\n    in-place, subtract from 1.25, and exponentiate in-place. Local binding reduces Python overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.048175084196494, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 16, "zscore": 32.36473639743962, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity exp(1.25 - (sin(x) - 0.5)**2)\n    in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 16, "zscore": 36.80897723231184, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.09914558041943, "text": "def build_func(x):\n    \"\"\"\n    Optimized: use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Compute sin in-place, then transform to the squared term and exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x := sin(x)\n    x -= 0.5           # x := sin(x) - 0.5\n    x *= x             # x := (sin(x) - 0.5)^2\n    x *= -1            # x := -(sin(x) - 0.5)^2\n    x += 1.25          # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 16, "zscore": 32.19872880561292, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries\n    and keep a single array in-place. Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using\n    in-place arithmetic, then exponentiate in-place. This minimizes passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 33.532066645259164, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos^2(x))\n    as exp(1 + sin(x) - sin(x)^2). Compute sin(x) in-place, compute sin^2 in a temporary\n    array, then assemble the exponent and exponentiate in-place to minimize temporaries\n    and passes over large arrays. This avoids a separate cosine evaluation and reduces passes.\n    \"\"\"\n    tmp = np.empty_like(x)\n    np.sin(x, out=x)          # x := sin(x)\n    np.square(x, out=tmp)       # tmp := sin(x)^2\n    x += 1.0                    # x := sin(x) + 1\n    np.subtract(x, tmp, out=x)  # x := (sin(x) + 1) - sin(x)^2\n    np.exp(x, out=x)            # x := exp(...)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 16, "zscore": 30.922209065063644, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    compute the result in-place with a single sine evaluation and minimal temporaries.\n    Steps:\n    - Compute sin(x) in-place: x := sin(x)\n    - Transform to (sin(x) - 0.5)^2, negate, and add 1.25 to obtain 1.25 - (sin(x) - 0.5)^2\n    - Exponentiate in-place to get exp(sin(x) + cos(x)**2)\n    This keeps a single array in-use and minimizes passes and temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 29.923022693927233, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single\n    sin evaluation and perform in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 16, "zscore": 36.85058159510296, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute with a single sin call\n    and in-place arithmetic, minimizing temporaries for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 16, "zscore": 32.20693821428589, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value in-place,\n    and exponentiate in-place. This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x := sin(x)\n    x -= 0.5         # x := sin(x) - 0.5\n    x *= x           # x := (sin(x) - 0.5)^2\n    x *= -1          # x := -(sin(x) - 0.5)^2\n    x += 1.25        # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)    # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 16, "zscore": 36.40450558133962, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place with minimal temporaries.\n    Uses the algebraic identity: exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 16, "zscore": 36.84500547820802, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 16, "zscore": 36.91559587131901, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    compute with a single sin evaluation and in-place arithmetic, minimizing temporaries\n    and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 16, "zscore": 34.91827145071297, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25 in-place,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.40412923087511, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    This mirrors the top-scoring solutions but avoids the explicit subtract call to reduce function call overhead.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 30.752678585299968, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place to reuse buffer, then perform in-place arithmetic:\n    sin -> x; x -= 0.5; x *= x; x *= -1; x += 1.25; exp in-place.\n    This minimizes temporaries and passes over data.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 16, "zscore": 36.85732394859667, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays. This mirrors the top solutions\n    and should be fast for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 16, "zscore": 32.28879950006154, "text": "def build_func(x):\n    \"\"\"\n    Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Perform the computation in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 16, "zscore": 32.29159486508997, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.30789220720628, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    then exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.39376398227811, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    then exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.74874427639857, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.3361771245866, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then apply in-place arithmetic to produce 1.25 - (sin(x) - 0.5)^2\n    with minimal temporaries, then exponentiate in-place.\n    This keeps a single array in-use and reduces passes.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 32.387144804454685, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. This variant avoids an extra\n    subtraction call by using x *= -1; x += 1.25 to form the final value.\n    This keeps a single array in-use and minimizes passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.796003242048826, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    Keeps a single array in-use and minimizes passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.6782958169439, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place (one pass), then form 1.25 - (sin(x) - 0.5)^2 in-place, and exponentiate in-place.\n    This minimizes temporaries and passes for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.55279893887021, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use a separate scratch buffer to compute sin(x) and then apply the algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) in a way that avoids aliasing with the input.\n    This provides a fundamentally different implementation pattern from the in-place variants while\n    preserving numerical correctness within float64 precision.\n    \"\"\"\n    s = np.empty_like(x)\n    np.sin(x, out=s)\n    s -= 0.5\n    s *= s\n    np.subtract(1.25, s, out=s)\n    np.exp(s, out=s)\n    return s", "operator": "explore"}
{"type": "mutation", "generation": 16, "zscore": 29.500559849386445, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Break from the common in-place sin-based pattern by using a separate scratch buffer\n    for the sine values. This enables a clean two-pass computation that preserves numerical\n    fidelity while avoiding aliasing in the input array. We rely on the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and compute\n    (sin(x) - 0.5)^2 in a scratch buffer, then exponentiate in-place.\n\n    This approach trades a small amount of additional memory (a scratch array) for a\n    distinct data flow that can improve cache behavior on very large arrays.\n    \"\"\"\n    s = np.empty_like(x)\n    np.sin(x, out=s)\n    s -= 0.5\n    s *= s\n    x[:] = 1.25 - s\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 17, "zscore": 36.84952253940452, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 32.46204055390002, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 17, "zscore": 36.92522578560818, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.680996276128006, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 32.180280512339486, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 32.27656780528531, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 17, "zscore": 36.80066143982008, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.8283826079829, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.75317472139895, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 17, "zscore": 36.75924832346442, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n               Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using\n               in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 17, "zscore": 36.78838223898292, "text": "def build_func(x):\n    \"\"\"\n    Optimized in-place computation using the identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 17, "zscore": 32.20190257182693, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then assemble exponent and exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 17, "zscore": 32.06393609670094, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form exponent in-place to minimize temporaries and passes.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.217378569656766, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 21.42321967311065, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos^2(x)) as\n    exp(1 + sin(x) - sin(x)**2). Compute sin(x) into a scratch buffer, copy into x,\n    compute sin^2 in-place, then form 1 + sin - sin^2 and exponentiate in-place.\n    This minimizes the number of transcendental evaluations to one and reduces temporaries.\n    \"\"\"\n    s = np.empty_like(x)\n    np.sin(x, out=s)  # s := sin(x)\n    x[:] = s           # x := sin(x)\n    x *= s             # x := sin(x) * sin(x) = sin^2(x)\n    x *= -1              # x := -sin^2(x)\n    x += 1               # x := 1 - sin^2(x)\n    x += s               # x := 1 + sin(x) - sin^2(x)\n    np.exp(x, out=x)     # x := exp(...)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 17, "zscore": 32.34997088666395, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. Then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 32.339159697503916, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.744767636499276, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.78708358056776, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, then 1.25 - that, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.84232011043478, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 35.447867955225774, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 32.30249825001703, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.91981673700807, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.751652827008414, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and exponentiate,\n    minimizing temporaries and passes for large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 32.35421322041634, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place into x, then form (sin(x) - 0.5)^2 in-place, negate and add 1.25,\n    then exponentiate in-place to minimize temporaries and passes.\n    This preserves exactness and avoids extra allocations.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 17, "zscore": 32.18442655863951, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.94289022887621, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.67324922789819, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single sine evaluation and then in-place arithmetic, minimizing temporaries\n    and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.55587684274202, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then compute (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 17, "zscore": 36.80812860614505, "text": "def build_func(x):\n    \"\"\"\n    Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then (sin - 0.5)^2 in-place, then 1.25 - ..., and exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 17, "zscore": 32.4542095995514, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cosine and to minimize temporaries. Compute sin(x) in-place, then apply\n    in-place transforms to form (sin(x) - 0.5)^2, negate and add 1.25, and finally exponentiate\n    in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 17, "zscore": 36.76241980471129, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.787707110902204, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the algebraic identity\n    exp(1.25 - (sin(x) - 0.5)**2) to minimize passes and temporaries.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 17, "zscore": 36.72716201785032, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 32.08169597720101, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    and perform all operations in-place to minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x := sin(x)\n    x -= 0.5          # x := sin(x) - 0.5\n    x *= x            # x := (sin(x) - 0.5)^2\n    x *= -1           # x := -(sin(x) - 0.5)^2\n    x += 1.25         # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)     # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 31.904983526894288, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, apply 1.25 - that, and exponentiate in-place\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 35.90033980455962, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 30.651816309897672, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, apply the 1.25 offset, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.57409594849778, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Combine the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    with in-place sine evaluation to minimize temporaries and memory traffic on large arrays.\n    Compute sin(x) in-place, then form (sin(x) - 0.5)^2 in-place, then compute 1.25 - that value in-place,\n    and finally exponentiate in-place. Uses local bindings to reduce Python overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 17, "zscore": 36.77258105356788, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to reduce to a single sin evaluation and a single exp. Compute sin(x) in-place, then\n    transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 36.889455847275975, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 18, "zscore": 32.17214969590825, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, \n    then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries \n    and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.23777517426397, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Maintain the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then perform all subsequent in-place ops to form 1.25 - (sin(x) - 0.5)^2,\n    followed by an in-place exponential. This uses no temporaries beyond the input buffer and minimizes Python overhead by avoiding extra function calls and temporaries.\n    \"\"\"\n    sin = np.sin  # bind for speed\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.72744407844476, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 18, "zscore": 36.61340705450406, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cosine and to minimize temporaries. Compute sin(x) in-place, then apply\n    in-place transforms to form (sin(x) - 0.5)^2, then 1.25 - that, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.235542655093944, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.64957776544427, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries. Compute sin(x) in-place, then apply in-place transforms\n    to form (sin(x) - 0.5)^2, negate and add 1.25, and finally exponentiate in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 18, "zscore": 36.70487407642824, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin(x) in-place,\n    then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 36.79854757952485, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.097099259501654, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    and exponentiate in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.62318395063276, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 18, "zscore": 36.74388250399707, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a new, in-place fused approach based on the exact algebraic identity:\n    sin(x) + cos(x)^2 = 1.25 - (sin(x) - 0.5)^2.\n    This allows computing the result with a single trig operation (in-place sin) and a single exponent,\n    while reusing the input buffer to avoid temporaries and extra passes.\n    Steps:\n    1) compute sin(x) in-place,\n    2) shift by 0.5, square in-place,\n    3) compute 1.25 - value in-place,\n    4) exponentiate in-place.\n    This diverges from the common pattern of separately computing cos or allocating temporaries.\n    \"\"\"\n    import numpy as np\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 18, "zscore": 36.81570034957059, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cos.\n    This computes sin(x) once and then uses in-place arithmetic to form the final exponent, minimizing\n    passes and temporaries for large arrays while preserving exact results.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 18, "zscore": 32.11345324754744, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize transcendentals and temporaries. Compute sin(x) in-place, transform to\n    (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value in-place, and exponentiate in-place.\n    This minimizes passes and allocations for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)       # x := sin(x)\n    x -= 0.5              # x := sin(x) - 0.5\n    x *= x                # x := (sin(x) - 0.5)^2\n    x *= -1               # x := -(sin(x) - 0.5)^2\n    x += 1.25             # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)         # x := exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 33.035550619619976, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place, then in-place transform to 1 + sin(x) - sin(x)**2, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= x * x\n    x += 1\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 31.78087707789262, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.57539683874131, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.08148150912279, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 31.110616030314404, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation and minimal temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 31.862925996667325, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.00448741590324, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, apply the 1.25 offset, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 31.991346941871882, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then transform to (sin(x) - 0.5)^2, apply 1.25 offset, and exponentiate in-place.\n    This minimizes temporaries, passes, and avoids allocations.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 36.578820676009855, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cosine\n    and minimize temporaries. Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 18, "zscore": 32.1105300306369, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid\n    computing cos and to minimize temporaries. Compute sin in-place, then transform to the\n    exponent argument in-place and apply exp in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.277607146499854, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute sin in-place, then form 1.25 - (sin(x) - 0.5)^2 using purely in-place\n    arithmetic to minimize temporaries and Python overhead. This uses a single exp per element\n    and avoids extra allocations, suitable for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.296596711290825, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then\n    transform to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 36.676977603461154, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 and apply the 1.25 offset, all in-place\n    to minimize temporaries and passes over large arrays.\n    This keeps a single sine evaluation and a single exponentiation.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.130696406642, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cosine and to minimize temporaries. Compute sin(x) in-place, then\n    form (sin(x) - 0.5)^2 in-place, transform to 1.25 - that value, and exponentiate in-place.\n    This minimizes passes over large arrays and avoids extra allocations.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)      # x := sin(x)\n    x -= 0.5             # x := sin(x) - 0.5\n    x *= x               # x := (sin(x) - 0.5)^2\n    x *= -1               # x := -(sin(x) - 0.5)^2\n    x += 1.25              # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)        # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.6717807911109, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cosine. Compute sin(x) in-place, then form (sin(x) - 0.5)^2,\n    apply the 1.25 offset, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.15128768025698, "text": "def build_func(x):\n    \"\"\"\n    In-place computation using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Minimizes temporaries by performing all operations in the input buffer.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 32.47006466767984, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid extra computations. Compute sin(x) in-place, then apply in-place transforms\n    to form (sin(x) - 0.5)^2, convert to 1.25 - that, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 36.79727719093565, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.52477291358036, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.70928119350832, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.584523741427795, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, apply the 1.25 offset, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.18649939580383, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin(x)\n    in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using minimal temporaries, and exponentiate in-place\n    to minimize passes and allocations.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 32.20932276347867, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.56211852273896, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to reduce to a single sine evaluation and in-place transforms.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 18, "zscore": 36.580345333616464, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.78999808271991, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, apply the 1.25 offset, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.22371401789286, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation and minimal temporaries, avoiding extra arrays. Steps: compute sin in-place, subtract 0.5, square, negate, add 1.25, then exp in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 19, "zscore": 36.579546976726675, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation\n    and minimal temporaries, avoiding extra allocations and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 19, "zscore": 36.80984222521998, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 19, "zscore": 32.31330168091655, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation and minimal temporaries.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.65365892930537, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.11254941019798, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place (single pass), then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.12858844475031, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation and minimal temporaries. This avoids a separate cos computation and reduces memory traffic, achieving faster evaluation on large arrays while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.78388792118025, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation and minimal temporaries.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.64382544038596, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.00104806211368, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and without computing cos.\n    This minimizes passes and temporaries for large arrays while preserving FP semantics for float64.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Form (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    # Compute 1.25 - (sin(x) - 0.5)^2 in-place\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 19, "zscore": 32.204902414844696, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cos and\n    minimize temporaries. Compute sin in-place, then form 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    followed by a single exponential. This preserves exact mathematical equivalence while reducing passes and allocations\n    for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 19, "zscore": 36.58317534512333, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.23047236615653, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.26948679840644, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place, then perform in-place arithmetic to form 1.25 - (sin - 0.5)^2, then exponentiate in place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.69278750363457, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.07673063733557, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 19, "zscore": 36.605991485925365, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the equivalent form exp(1.25 - (sin(x) - 0.5)**2)\n    with in-place, fused operations to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 19, "zscore": 36.908090338801664, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation\n    and minimal temporaries, ensuring exact mathematical equivalence up to floating point precision.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.21567938263645, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.334687326013515, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation and minimal temporaries for large arrays.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.18801480726435, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. This avoids an extra subtraction\n    function call and keeps a single exp per element, maximizing throughput on large inputs.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.340624648823336, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 31.926219905184578, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2 to fuse\n    the computation into a single in-place pass with minimal temporaries:\n    1) compute sin(x) in-place,\n    2) subtract 0.5, square, negate, add 1.25,\n    3) apply exp in-place.\n\n    This preserves the exact mathematical result while minimizing passes and allocations.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x now holds sin(x)\n    x -= 0.5\n    x *= x             # (sin(x) - 0.5)^2\n    x *= -1            # - (sin(x) - 0.5)^2\n    x += 1.25          # 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 19, "zscore": 32.15497040961598, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. Avoid an extra subtraction\n    call by performing 1.25 - y as two in-place ops: y *= -1; y += 1.25.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.163418995895505, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 19, "zscore": 33.76965200169372, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a completely different algebraic form to compute the exponent:\n    exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    This uses only a single sine evaluation (in-place) and a small, in-place\n    sequence of arithmetic operations, avoiding the specific \"complete the square\"\n    pattern used in prior solutions. This provides a new path to the same exact result\n    with minimal temporaries and passes.\n\n    Steps:\n    1) Compute sin(x) in-place so x holds s = sin(x).\n    2) Compute t = s^2 (temporary array).\n    3) Compute x = 1 + s - s^2 using in-place updates.\n    4) Apply exp in-place to obtain the final result.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)   # x now contains sin(x)\n    t = x * x         # t = sin(x)^2 (temporary)\n    x -= t            # x = sin(x) - sin(x)^2\n    x += 1.0          # x = 1 + sin(x) - sin(x)^2\n    exp(x, out=x)     # x = exp(1 + sin(x) - sin(x)^2)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 19, "zscore": 32.14084851563005, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.27354691931438, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation and minimal temporaries for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.71067066608247, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    in-place with a single sin evaluation and minimal temporaries. Bind ufuncs locally to reduce Python overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.56738595651537, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.627603821017786, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place computation of exp(sin(x) + cos(x)**2) using the identity\n    exp(1.25 - (sin(x) - 0.5)**2) with minimal temporaries and passes.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 19, "zscore": 36.78782582291577, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays, ensuring exactness to the\n    naive implementation up to float64 precision.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.306405596959436, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and implement in-place arithmetic to minimize temporaries and passes over large arrays.\n    Compute sin in-place, then form 1.25 - (sin(x) - 0.5)^2 using only in-place operations:\n    sin(x, out=x); x -= 0.5; x *= x; x *= -1; x += 1.25; exp(x, out=x)\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.2121304035631, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.1599741156738, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.333615326146024, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. This yields a single sin evaluation\n    and a single exp per element, with all work done in-place and no intermediate allocations.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.26213313649552, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Compute sin in-place, then form 1.25 - (sin(x) - 0.5)^2 using purely in-place\n    arithmetic to minimize temporaries and Python overhead. This uses a single exp per element\n    and avoids extra allocations, suitable for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 36.964633232205586, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic simplification to reduce to a single sin evaluation and a\n    single exponential. Use sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2.\n    Compute sin in-place, then perform (sin - 0.5)^2 and then exp(1.25 - ...) \n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 19, "zscore": 32.04728314993165, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. Avoid an extra function call by\n    replacing 1.25 - (sin-0.5)^2 with equivalent in-place steps.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 19, "zscore": 32.06877315957411, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and implement\n    with in-place arithmetic to minimize temporaries and Python overhead. This path computes sin in-place,\n    then applies a couple of in-place operations to form 1.25 - (sin(x) - 0.5)^2, followed by exp.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 30.230358053815436, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 31.95847141923654, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation and minimal temporaries. This avoids a separate cos computation and reduces memory traffic, achieving faster evaluation on large arrays while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.285012299879504, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place pipeline: compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2\n    and apply exp in-place. This minimizes passes and temporaries.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 20, "zscore": 32.19008620968186, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computation.\n    Compute sin in-place, then perform in-place arithmetic to obtain the final argument for exp(),\n    and apply exp in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 20, "zscore": 32.22229994206791, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x now holds sin(x)\n    x -= 0.5           # (sin(x) - 0.5)\n    x *= x             # (sin(x) - 0.5)^2\n    x *= -1            # - (sin(x) - 0.5)^2\n    x += 1.25          # 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 31.46672762717036, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using a single sin evaluation and in-place operations.\n    Uses the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x now holds sin(x)\n    x -= 0.5       # (sin(x) - 0.5)\n    x *= x           # (sin(x) - 0.5)^2\n    x *= -1          # - (sin(x) - 0.5)^2\n    x += 1.25        # 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)    # exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 20, "zscore": 32.34696966203814, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). \n    Compute sin in-place, then perform in-place arithmetic to obtain 1.25 - (sin(x) - 0.5)^2, \n    and then exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.12042563877917, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Leverage the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform an in-place computation with a single sin evaluation and without materializing cos.\n    This minimizes temporaries and passes over large arrays while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x now holds sin(x)\n    x -= 0.5\n    x *= x           # (sin(x) - 0.5)^2\n    x *= -1            # - (sin(x) - 0.5)^2\n    x += 1.25          # 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.09566865751904, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation and minimal temporaries. This avoids\n    computing cos and reduces memory traffic, while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 30.387327750396437, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with\n    a single sin evaluation and minimal temporaries. This avoids computing cos, reduces passes, and keeps\n    float64 semantics, yielding faster evaluation on large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.047038073921556, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place using the identity sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2.\n    This minimizes temporaries and passes while preserving float64 semantics.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    # 1.25 - (sin(x) - 0.5)^2\n    x *= -1\n    x += 1.25\n    # exp in-place\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 20, "zscore": 31.539050769313704, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place using the identity exp(1.25 - (sin(x) - 0.5)**2)\n    to reduce passes and temporaries. The input array is modified in-place for performance.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)       # x now holds sin(x)\n    x -= 0.5\n    x *= x                # (sin(x) - 0.5)^2\n    x *= -1               # - (sin(x) - 0.5)^2\n    x += 1.25             # 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)         # exp(...)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 20, "zscore": 32.01720708401007, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 36.65305006527162, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 36.89531636287126, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse the computation\n    into a single in-place pass with minimal temporaries. Compute sin in-place, then form (sin(x) - 0.5)^2\n    and apply 1.25 minus that in-place, then exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.19741239884837, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then compute (sin(x) - 0.5)^2 and apply the remaining transforms in-place\n    to produce 1.25 - (sin(x) - 0.5)^2, followed by exp in-place. This minimizes temporaries and passes on large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 32.317825703291994, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computations\n    into a single in-place pass with minimal temporaries. Compute sin in-place, then perform the\n    transformation to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place to minimize passes over large arrays.\n    This preserves FP semantics for float64 and significantly reduces memory traffic for long arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 32.30286804272177, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 31.95617178579922, "text": "def build_func(x):\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 20, "zscore": 32.21968429236172, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation and minimal temporaries. This avoids a separate cos\n    computation and reduces memory traffic, achieving faster evaluation on large arrays while preserving\n    float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Form 1.25 - (sin(x) - 0.5)^2 in-place\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 32.026781308867626, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse\n    the computation into a single in-place pass with minimal temporaries:\n    1) compute sin(x) in-place,\n    2) form (sin(x) - 0.5)^2,\n    3) compute 1.25 - (sin(x) - 0.5)^2 in-place,\n    4) apply exp in-place.\n    This preserves FP semantics for float64 and minimizes passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.46628655422759, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation and minimal temporaries.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 36.645790033874526, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then transform to (sin(x) - 0.5)^2 in-place, then\n    compute 1.25 - (...) in-place and exponentiate in-place. This minimizes temporaries\n    and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 36.53583284532566, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2),\n    computed in-place to minimize temporaries and passes over large arrays. This variant uses\n    local aliases for the NumPy functions to reduce attribute lookups and performs all\n    operations in-place with out arguments to avoid extra allocations.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # 1.25 - (sin(x) - 0.5)^2  via in-place operations\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 26.799345297660693, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation per element and minimal temporaries, avoiding cos computation and reducing passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 31.992189988467757, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse the computation\n    into a single in-place path with minimal temporaries. This computes sin(x) once, then forms 1.25 - (sin(x) - 0.5)**2\n    and finally applies exp in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.03401163569194, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 36.61865402985377, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    in-place with a single sin evaluation and minimal temporaries. This avoids an explicit cos computation and reduces\n    memory traffic, achieving faster evaluation on large arrays while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.32237794235464, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation and no cos, minimizing temporaries and passes for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 32.083575229823964, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation and minimal temporaries for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)    # x now holds sin(x)\n    x -= 0.5\n    x *= x             # (sin(x) - 0.5)^2\n    x *= -1            # - (sin(x) - 0.5)^2\n    x += 1.25          # 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)      # exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 29.82840842203558, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.084301477402015, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computation into a single sine evaluation and in-place operations, avoiding cos and extra temporaries.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.250289514161125, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    fuse the computation into a single sine evaluation and a minimal in-place arithmetic chain.\n    Compute sin(x) in-place, then form -(sin(x) - 0.5)**2 + 1.25 in-place, and finally exponentiate in-place.\n    This minimizes temporaries and passes over large arrays while preserving float64 semantics.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.16983539617024, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation and minimal temporaries. This avoids a separate cos\n    computation and reduces memory traffic, achieving faster evaluation on large arrays while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Form (sin(x) - 0.5)^2 and then compute 1.25 - that value in-place\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.27536086438824, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation and minimal temporaries. This avoids a separate cos computation\n    and reduces memory traffic, achieving faster evaluation on large arrays while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 20, "zscore": 32.20750786190693, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse\n    the computation into a single in-place pass with minimal temporaries:\n    1) compute sin(x) in-place,\n    2) subtract 0.5 and square,\n    3) negate and add 1.25, \n    4) apply exp in-place.\n    This preserves FP semantics for float64 and minimizes passes for large arrays.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.29465677419182, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 41.17947436628575, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: This solution processes the input in fixed-size blocks to minimize peak memory usage and\n    demonstrates a different paradigm: streaming, chunk-wise in-place computation. It uses the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and computes it block-by-block, avoiding\n    a separate cos computation and keeping all operations in-place on the original array.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        np.sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        np.exp(y, out=y)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 20, "zscore": 32.34200474728287, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 20, "zscore": 32.294056996887846, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Form (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    # Compute 1.25 - (sin(x) - 0.5)^2 in-place\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.157154572504744, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to collapse the computation into a single sin evaluation and in-place arithmetic,\n    minimizing temporaries and passes over large arrays. This avoids recomputing cos and\n    reduces memory traffic by performing all operations in-place with ufuncs.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # In-place computation of sin(x)\n    sin(x, out=x)\n\n    # Transform to the exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 21, "zscore": 32.23502046039507, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then perform (sin - 0.5)^2 and then exp(1.25 - ...) \n    in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.4061659336754, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    reduce to a single sine evaluation and a few in-place arithmetic operations, followed by a single\n    in-place exponential. This minimizes temporaries and preserves memory locality for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 21, "zscore": 32.225960671975876, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the trigonometric identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse computations into a single sine evaluation and in-place arithmetic, minimizing passes\n    and temporary allocations on large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.069046186577545, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place,\n    then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 21, "zscore": 32.161835088559656, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse computations into a single sine evaluation and a single exponential,\n    performing all transformations in-place to minimize temporaries and passes over the data.\n    This keeps behavior identical to the naive implementation (within float64 precision).\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 21, "zscore": 32.148238577598846, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place using the identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    This performs a single in-place sin computation followed by a few\n    arithmetic operations and a final in-place exp.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 21, "zscore": 32.21456793211018, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 followed by in-place exponential.\n    This reduces the number of passes and temporaries over large arrays while preserving FP semantics\n    for float64.\n    \"\"\"\n    import numpy as np\n\n    # In-place: compute sin(x) into x\n    np.sin(x, out=x)\n    # Transform: (sin(x) - 0.5)^2 -> 1.25 - that\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 21, "zscore": 32.0480555219626, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation per element and minimal temporaries, avoiding cos computation and reducing passes over large arrays.\n    This preserves FP semantics for float64 and significantly reduces memory traffic for long arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 31.99952574261298, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.08965159510551, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    This achieves a single sin evaluation per element and a single exponentiation, with all operations in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 21, "zscore": 32.21520692582688, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 40.36831964126322, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and compute\n    block-wise in-place to minimize temporaries, reduce passes over the data, and keep memory usage low\n    for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        np.sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 36.58127967262026, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently by leveraging the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This requires a single sin evaluation per element and a minimal, in-place sequence of\n    operations to transform sin(x) into 1.25 - (sin(x) - 0.5)**2, followed by a single\n    in-place exponential. Uses in-place operations to minimize temporaries and passes over the data.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 28.57740336847669, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation of exp(sin(x) + cos(x)**2) using the identity\n    exp(1.25 - (sin(x) - 0.5)**2) after computing sin in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 21, "zscore": 31.616324213050394, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 36.80874257150078, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place,\n    then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.0047430665287, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computations\n    into a single in-place pass with minimal temporaries. Compute sin in-place, then convert to 1.25 - (sin - 0.5)^2\n    and exponentiate in-place to minimize passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.27711184001891, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using an algebraic identity to reduce to a single sin evaluation\n    and a fully in-place transformation: sin(x) -> 1.25 - (sin(x) - 0.5)**2, then exp.\n    This preserves dtype float64 and minimizes temporaries for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place computation: s = sin(x); then transform to 1.25 - (s - 0.5)^2\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 21, "zscore": 32.16678942869957, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 21, "zscore": 40.769828858912184, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform\n    in-place, block-wise computation to fuse the exponent with minimal temporaries and passes,\n    while keeping numerical results identical per element to the naive approach within float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        np.sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 36.89578467485673, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 35.66127054795552, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays. Fuse the final two steps into a single\n    in-place subtraction to reduce the number of passes.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n    subtract = np.subtract\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.01131511026257, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Compute sin in-place, then perform in-place arithmetic to obtain 1.25 - (sin(x) - 0.5)^2,\n    and exponentiate in-place to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.325203915314944, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid an explicit cos computation. Compute sin(x) in-place, then transform in-place\n    to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 36.49823073532127, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays, and exponentiate in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.10770411081537, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation per element and minimal temporaries. Compute sin in-place, then perform\n    (sin - 0.5)^2 and then exp(1.25 - ...) in-place to minimize passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.20870555665792, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation per element, minimizing temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.37222689168488, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 21, "zscore": 36.70959566875285, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place\n    with a single sin evaluation and minimal temporaries. Compute sin in-place, then transform to\n    1.25 - (sin(x) - 0.5)^2 and exponentiate in-place to minimize passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.30637360741952, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computations\n    into a single in-place pass with minimal temporaries. Compute sin in-place, then perform the\n    transformation to 1.25 - (sin(x) - 0.5)^2 and exponentiate in-place to minimize passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 41.15423493812717, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform\n    in-place, block-wise computation to improve cache locality for very large arrays while minimizing temporaries.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.21930408445794, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse computations into a single in-place pass with minimal temporaries.\n    Compute sin in-place, then perform (sin - 0.5)^2 and exponentiate in-place.\n    \"\"\"\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.179399577800154, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computations\n    into a single in-place pass with minimal temporaries. Compute sin in-place, then transform to\n    1.25 - (sin(x) - 0.5)^2 and exponentiate in-place to minimize passes over large arrays.\n    This preserves FP semantics for float64 and minimizes memory traffic for long arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 41.31632248284528, "text": "def build_func(x):\n    \"\"\"\n    Efficient block-wise in-place evaluation of exp(sin(x) + cos(x)**2)\n    using the identity to avoid cos computations and minimize temporaries.\n    Processes the input in fixed-size blocks to reduce peak memory and improve locality.\n    \"\"\"\n    import numpy as np\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.2272346208627, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation and minimal temporaries, reducing passes\n    and avoiding explicit cos computation for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 36.668858583837, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computations\n    into a minimal in-place pass. Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2\n    and exponentiate in-place to minimize temporaries and memory traffic for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.20326738801151, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.35122113565908, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Exploit the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single in-place pass with one sine evaluation and minimal temporaries.\n    Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic,\n    and finally exponentiate in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 21, "zscore": 32.242825004774694, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    in-place with a single sine evaluation, avoiding a separate cos computation and minimizing temporaries.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.068742232809605, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cos and\n    to perform in-place, single-pass transformations. This yields exact float64 results as the naive implementation\n    when followed by exp, while avoiding extra allocations.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to 1.25 - (sin(x) - 0.5)^2 in-place\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.17242038480579, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place to reuse memory, then perform in-place algebra to produce the inner value,\n    and finally apply exp in-place. This minimizes passes and temporaries while preserving\n    exact same dtype and producing exact results as the naive implementation up to FP precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin in-place\n    sin(x, out=x)\n    # 1.25 - (x - 0.5)^2  -> transform in-place\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 41.24402399709151, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and minimal temporaries.\n    Do block-wise in-place processing to improve cache locality for large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 40.42642593043754, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result with a single sine evaluation per block, followed by a compact, in-place\n    transformation and a final in-place exponential. Process in fixed-size blocks to improve cache\n    locality for very large arrays while avoiding extra allocations. This preserves dtype float64 and\n    aims for identical results to the naive implementation within floating point precision.\n\n    This implementation:\n    - Computes sin(x) in-place for a block\n    - Transforms to 1.25 - (sin(x) - 0.5)**2 via in-place arithmetic\n    - Applies exp in-place\n    - Repeats for all blocks\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)        # y := sin(x[i:j])\n        y -= 0.5               # y := sin(x) - 0.5\n        y *= y                 # y := (sin(x) - 0.5)^2\n        y *= -1                # y := - (sin(x) - 0.5)^2\n        y += 1.25              # y := 1.25 - (sin(x) - 0.5)^2\n        exp(y, out=y)          # y := exp(1.25 - (sin(x) - 0.5)^2)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 22, "zscore": 32.29254562397389, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation per element,\n    minimizing temporaries and passes over large arrays while preserving exact results within float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 22, "zscore": 32.07906497039011, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    in-place with a single sin evaluation and in-place arithmetic, minimizing temporaries and passes\n    over large arrays. This yields exact mathematical equivalence (given sin values) and fast performance.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform: y = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.223183108435606, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform in-place computation to minimize temporaries and passes over the array. This computes using sin only, avoiding cos and additional allocations.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 38.76380748141274, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform\n    in-place, block-wise computation to improve cache locality for very large arrays while minimizing temporaries.\n    Processes in fixed-size blocks to reduce peak memory and keep iterations cache-friendly.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 31.87609702549179, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, vectorized computation to minimize temporaries and passes over the array.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 40.73522972711304, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid cos\n    and minimize temporaries. Compute sin(x) in-place, then transform to 1.25 - (sin(x) - 0.5)**2\n    and exponentiate in-place. Process in fixed-size blocks to improve cache locality for large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 22, "zscore": 41.049399211151815, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Block-wise in-place evaluation using the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This avoids re-evaluating cos and minimizes temporaries. The input is processed in fixed-size blocks to improve cache locality on large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.027053804483366, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: This approach leverages the algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    It computes sin(x) once and then transforms it in-place to 1.25 - (sin(x) - 0.5)^2,\n    followed by a single exp. This avoids the cos computation entirely, reduces temporaries,\n    and maintains exact floating-point semantics consistent with the naive implementation\n    within float64 precision for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place: y = sin(x)\n    sin(x, out=x)\n\n    # y = 1.25 - (y - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # z = exp(y)\n    exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 22, "zscore": 32.20161588815944, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin(x) in-place, then transform:\n      y = sin(x)\n      y = 1.25 - (y - 0.5)**2\n    This is achieved with in-place operations:\n      sin(x, out=x)\n      x -= 0.5\n      x *= x\n      x *= -1\n      x += 1.25\n    Finally, apply exp in-place. This minimizes temporaries and passes over the data\n    while preserving float64 precision relative to the naive implementation.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.290115906826095, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to\n    reduce to a single sin evaluation per element and perform all transformations in-place to minimize\n    temporaries and passes over large arrays. This preserves exact results (within float64 precision)\n    while keeping memory traffic low by reusing the input buffer and avoiding intermediate allocations.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place: s = sin(x); then transform to 1.25 - (s - 0.5)^2 and apply exp in-place\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 22, "zscore": 40.25976467859345, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform\n    in-place, block-wise computation to improve cache locality and minimize temporaries while\n    preserving identical results (within float64 precision) to the naive implementation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n    const = 1.25\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += const\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.07925621682556, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) =\n    exp(1.25 - (sin(x) - 0.5)**2). Compute sin in-place to avoid temporaries,\n    then transform in-place: t = 1.25 - (t - 0.5)**2, followed by exp in-place.\n    This yields the same float64 results as the naive implementation while minimizing\n    passes and temporaries for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place sine into x\n    sin(x, out=x)\n    # x := sin(x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 22, "zscore": 32.1024725988479, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 22, "zscore": 32.01664976458382, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, vectorized computation to minimize temporaries and passes over the array.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.18446083314656, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform in-place\n    computations to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    np.sin  # ensure np is available\n    sin = np.sin\n    exp = np.exp\n\n    # In-place computation: s = sin(x); then transform to 1.25 - (s - 0.5)^2\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.12815074069672, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation and no temporaries, minimizing memory usage\n    while processing the whole 1-D float64 array.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 28.990606091433055, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2 to fuse\n    into a single in-place pass. Compute sin(x) in-place, then transform to the exponent value and apply exp.\n    This minimizes passes, temporaries and function calls while preserving numerical equivalence.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place computation: s = sin(x); then transform to 1.25 - (s - 0.5)^2\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 22, "zscore": 36.78056855473475, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)**2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays, then apply exp in-place.\n    This preserves dtype float64 and yields outputs matching the naive implementation\n    up to floating point precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # Compute (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    # Compute 1.25 - (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)\n    # Exponentiate in-place\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 22, "zscore": 32.21758647997521, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) \n    and compute in-place to minimize temporaries and passes. This uses a single sin evaluation and a single\n    exp evaluation over the entire 1D float64 array, with all other arithmetic done in place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.008585477893405, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result using a single sine evaluation in-place, minimizing temporaries and passes\n    over very large arrays. This preserves dtype float64 and maintains in-place computation for speed.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.081226389885046, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, single sin evaluation on the entire array to minimize temporaries\n    and passes. This preserves exact float64 results with the naive implementation\n    because the exponent is algebraically identical to sin(x) + cos(x)**2.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.115926804181, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and minimize temporaries.\n    This preserves dtype float64 and avoids extra allocations by operating directly on the input array.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform: y = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 31.9712179755613, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform\n    in-place, vectorized computation to minimize temporaries and passes over very large arrays.\n    This evaluates sin once per element and then applies a simple algebraic transform before a single exp.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place computation: s = sin(x); then transform to 1.25 - (s - 0.5)^2\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.24662044146618, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, block-free computation to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.14530037555499, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid recomputing cos\n    and to keep all operations in-place for large arrays. This reduces temporaries and passes over data.\n    \"\"\"\n    import numpy as np\n\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 30.844499298881395, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 40.2826209391673, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and implement\n    a block-wise, in-place computation to maximize cache locality and minimize temporaries for large arrays.\n    Processes input in fixed-size blocks, applying sin in-place, then performing the algebraic transform\n    and an in-place exponential.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 40.66276093159943, "text": "def build_func(x):\n    \"\"\"\n    In-place, block-wise computation of exp(sin(x) + cos(x)**2) using the algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Processes in fixed-size blocks to improve cache locality and minimize temporaries.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 22, "zscore": 32.16133250206714, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place computation to minimize temporaries and passes. This uses a single\n    sin evaluation per element and no explicit cos, while preserving exact semantics up to FP\n    precision.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.07622858223076, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and no temporaries.\n    Process the whole 1-D array in a single pass by:\n      1) computing sin(x) in-place\n      2) x -= 0.5\n      3) x *= x\n      4) x *= -1\n      5) x += 1.25\n      6) exp(x, out=x)\n    This minimizes memory and passes, and preserves exact dtype and numerical results.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.118954013665636, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    the result with a single sine evaluation per element and a single exponential, all in-place.\n    This avoids computing cos entirely, reduces the number of transcendentals, and minimizes temporaries\n    while preserving exact mathematical equivalence.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 22, "zscore": 32.27522307555602, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place computation of exp(sin(x) + cos(x)**2) using the algebraic identity\n    exp(1.25 - (sin(x) - 0.5)**2) and in-place, vectorized operations to avoid temporaries.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": NaN, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic.\n    This minimizes temporaries and passes over the data.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 32.09547656086325, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid\n    evaluating cos and keep the operation fully in-place on the input array with a single sin call.\n    This minimizes temporaries, passes, and allocations for large arrays. The computation is performed\n    in-place in a vectorized fashion, ensuring the output matches the naive implementation within\n    float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place: s = sin(x)\n    sin(x, out=x)\n    # Transform: s -> 1.25 - (s - 0.5)^2 using in-place ops: (s - 0.5)^2 = (s-0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Final: exp(...)\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 22, "zscore": 32.187106453119384, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the algebraic identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This implementation uses a single sin evaluation and in-place, cache-friendly math\n    to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 22, "zscore": 32.28550521511577, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, single-sine evaluation with minimal temporaries. This computes the\n    argument of exp directly from sin(x) and avoids an explicit cos computation, yielding\n    faster performance on large arrays while preserving numerical fidelity (to float64 precision).\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.23286642718924, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and perform in-place computation\n    to minimize temporaries. This computes sin(x) in-place once, then transforms to the exponent argument and applies\n    exp in-place, preserving exact semantics up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.188592213145895, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse into a\n    single in-place pass. Compute sin(x) in-place, then transform to exponent value and apply exp.\n    This minimizes temporaries and passes, and avoids explicit cos computation.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.08620814963061, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place using the identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    This computes sin(x) in-place, transforms to the exponent value, and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 23, "zscore": 32.062019912632415, "text": "def build_func(x):\n    \"\"\"\n    In-place computation using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize temporaries and passes. Computes sin(x) in-place, then transforms to the exponent\n    value and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 23, "zscore": 32.28959695359222, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation per element and minimal temporaries.\n    This avoids cos entirely and reduces the number of transcendentals while preserving exact\n    mathematical equivalence up to FP rounding.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.06299580615484, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute f(x) = exp(sin(x) + cos(x)**2) using the algebraic identity\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2, then perform all in-place with a\n    single sin evaluation and a single exp. This avoids explicit cos computation, minimizes\n    temporaries, and keeps Python-level overhead to a minimum for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.14746578045773, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with a single sin evaluation per element and minimal temporaries. Process in-place for speed.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.07520427928831, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place pass. Compute sin(x) in-place, then transform to the exponent\n    value 1.25 - (sin(x) - 0.5)^2 and apply exp in-place. This avoids computing cos entirely,\n    reduces temporaries, and minimizes passes over the array while preserving numerical equality\n    to the naive implementation within float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 31.92170682939588, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cos,\n    performing all operations in-place for speed and minimal temporaries. This preserves the exact\n    mathematical result up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to exp(1.25 - (sin(x) - 0.5)^2)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 24.650431480998854, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries.\n    This leverages full-array NumPy vectorization (no Python loops) for speed on large inputs.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 31.9900588049333, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    in-place with a minimal number of passes. Compute sin(x) in-place, then transform to exponent\n    value and apply exp in-place. This avoids computing cos entirely, reduces temporaries, and\n    maintains exact semantics up to floating point precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.165804448447375, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single\n    sine evaluation and a single exponential, minimizing temporaries and passes. This preserves exact semantics up to FP precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (x - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.27901303895413, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place computation to minimize temporaries and passes. This uses a single\n    sin evaluation per element and no explicit cos, while preserving exact semantics up to FP\n    precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.405657501918114, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place with a single sin evaluation per element and a single exponential, avoiding cos and minimizing temporaries. This yields exact float64 results within precision while being fast for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exponent input: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 23, "zscore": 32.11009551490955, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform an in-place, single-sin-evaluation computation with minimal temporaries,\n    suitable for large 1-D arrays. This preserves exact mathematical semantics up to\n    float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 31.40708812504737, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place using the identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    This minimizes transcendentals and temporaries by computing sin(x) once and applying\n    in-place arithmetic, then exponentiating in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 23, "zscore": 32.178678856654244, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place for large arrays by using the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and evaluating sin once\n    in-place, followed by minimal in-place arithmetic, then exp in-place.\n    This minimizes the number of transcendental function calls and avoids temporaries.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent input: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 41.33390387021484, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse\n    into in-place computation with minimal temporaries. This implementation processes the input\n    in fixed-size blocks to keep memory locality and avoid large temporary allocations, while\n    performing as few passes as possible. It computes sin(x) in-place, then transforms to the\n    exponent value and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.039447625648755, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place pass. Compute sin(x) in-place, convert to the exponent form, and\n    apply exp in-place to minimize temporaries and passes for large arrays. This preserves numeric\n    equivalence up to floating-point precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exp(1.25 - (x - 0.5)^2)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 23, "zscore": 41.24072700206843, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, block-wise processing to fuse exponent with minimal temporaries and passes,\n    while keeping numerical results identical per element to the naive approach within float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.27089625115835, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result with a single sine evaluation per element and a single exponential,\n    all in-place. This avoids a separate cos computation, minimizes temporaries, and preserves\n    exact semantics up to floating-point rounding.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exponent in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.13654916397678, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and minimal temporaries.\n    This avoids explicit cos computations and reduces the number of passes while preserving exact semantics\n    up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.311786269456036, "text": "def build_func(x):\n    \"\"\"\n    Optimized in-place computation using the identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    This computes sin(x) in-place, then transforms to the exponent argument and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 23, "zscore": 31.9775326150903, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation over the whole array and a single exponential.\n    This avoids an explicit cos computation, minimizes temporaries, and processes the data in a single\n    vectorized pass for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 40.31231993237257, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation per element and minimal temporaries.\n    Process in fixed-size blocks to improve cache locality for very large arrays while avoiding extra allocations.\n    This preserves exact semantics (up to floating point precision) and eliminates the explicit cos computation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)      # y := sin(x[i:j])\n        y -= 0.5             # y := sin(x) - 0.5\n        y *= y               # y := (sin(x) - 0.5)^2\n        y *= -1                # y := - (sin(x) - 0.5)^2\n        y += 1.25              # y := 1.25 - (sin(x) - 0.5)^2\n        exp(y, out=y)          # y := exp(1.25 - (sin(x) - 0.5)^2)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 23, "zscore": 32.28346893742564, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and compute it in-place with a minimal number of passes and no cosine/temporary allocations.\n    \"\"\"\n    import numpy as np\n\n    # In-place sequence: sin -> (sin - 0.5) -> square -> negate -> add 1.25 -> exp\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)\n    np.square(x, out=x)\n    np.negative(x, out=x)\n    np.add(x, 1.25, out=x)\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 23, "zscore": 32.17077935329153, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation per element and minimal temporaries.\n    This preserves exact semantics up to floating point precision and minimizes memory usage\n    by avoiding cos and extra allocations. Entire computation is done in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 41.11279121383963, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place pass. Compute sin in-place, then transform to exponent value\n    and apply exp. Process in fixed-size blocks to improve cache locality for large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.10021361657011, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid cos and minimize temporaries. Compute sin in-place, then transform in-place\n    to the exponent value and apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 23, "zscore": 32.136963540110074, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    Performs in-place computation to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 23, "zscore": 34.05413476758325, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a block-wise streaming approach that avoids large temporaries and heavy\n    intermediate allocations while preserving exact results (within float64 precision).\n    For each block:\n      - Compute s = sin(x) in-place.\n      - Compute s^2 into a small per-block scratch buffer.\n      - Form the exponent as 1 + s - s^2 and apply exp in-place.\n    This keeps memory usage bounded (via a fixed-size scratch buffer) and reduces peak allocations,\n    while performing the same mathematical operations as the naive implementation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    BLOCK = 1 << 20  # ~1,048,576\n    if BLOCK > n:\n        BLOCK = n\n\n    buf = np.empty(BLOCK, dtype=np.float64)\n\n    sin_u = np.sin\n    exp_u = np.exp\n\n    i = 0\n    while i < n:\n        j = i + BLOCK\n        if j > n:\n            j = n\n        y = x[i:j]  # view into the original array\n\n        # s = sin(y) in-place\n        sin_u(y, out=y)\n\n        m = y.shape[0]\n        # buf = s^2\n        np.multiply(y, y, out=buf[:m])\n\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= buf[:m]\n\n        # y = exp(exponent) in-place\n        exp_u(y, out=y)\n\n        i = j\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 23, "zscore": 41.12775482595217, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cos and minimize temporaries.\n    Compute sin(x) in-place, then transform to exponent: 1.25 - (sin(x) - 0.5)^2, all in-place, and finally apply exp in-place.\n    Process the input in fixed-size blocks to improve cache locality for large arrays and minimize peak allocations.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 23, "zscore": 32.374154978838035, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place computation to minimize temporaries and passes. This uses a single\n    sin evaluation and avoids explicit cos, aiming for maximal speed on large arrays while\n    preserving results within float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.255143475163344, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid cos\n    and minimize temporaries. Compute sin(x) in-place, then transform to exponent value and apply exp\n    in-place. This yields a single sine evaluation per element and a single exponential, with minimal\n    memory overhead for large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 23, "zscore": 32.09497397437073, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid cos and\n    compute sin(x) once in-place. Then transform to the exponent input in-place and apply exp in-place.\n    This minimizes temporaries and Python overhead for large arrays while preserving float64 accuracy.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.21667084581867, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, vectorized computation in a single set of passes to minimize Python overhead\n    and avoid extra temporaries. This computes sin(x) once, transforms to the exponent value, then\n    applies exp, avoiding an explicit cos computation while preserving exact semantics up to FP precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 40.83503161834762, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in a cache-friendly, in-place, block-wise manner with a minimal number of passes.\n    Process large arrays in fixed-size blocks to maximize cache locality and minimize temporary allocations,\n    while preserving float64 semantics and producing results identical to the naive implementation up to FP precision.\n\n    This implementation:\n    - Computes sin(x) in-place for a block\n    - Transforms to 1.25 - (sin(x) - 0.5)**2 via in-place arithmetic\n    - Applies exp in-place\n    - Repeats for all blocks\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)        # y := sin(x[i:j])\n        y -= 0.5               # y := sin(x) - 0.5\n        y *= y                 # y := (sin(x) - 0.5)^2\n        y *= -1                # y := - (sin(x) - 0.5)^2\n        y += 1.25              # y := 1.25 - (sin(x) - 0.5)^2\n        exp(y, out=y)          # y := exp(1.25 - (sin(x) - 0.5)^2)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.08291524629287, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place, vectorized computation to minimize temporaries and passes.\n    This computes sin(x) in-place, then transforms to the exponent value and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 32.11924016594542, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation of exp(sin(x) + cos(x)**2)\n    using the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This version avoids temporaries and uses a single in-place pass over the input.\n    Reasoning: compute sin(x) in-place, transform to the exponent argument, then apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 40.476013330738795, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: This approach follows a block-wise streaming paradigm to improve cache locality and memory\n    efficiency for very large arrays (~10,000,000 elements). It uses the mathematical identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse the computation into a\n    single in-place pass per block, avoiding an explicit cos computation and minimizing temporaries.\n\n    Implementation details:\n    - Process data in fixed-size blocks (approx 1e6 elements) to keep memory footprint small and improve\n      cache reuse on large arrays.\n    - In each block, compute sin in-place, then transform in-place to the exponent argument\n      1.25 - (sin(x) - 0.5)^2 using only in-place arithmetic, and finally apply exp in-place.\n    - Returns the input array with the computed results.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 24, "zscore": 32.3279248860645, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries, while performing\n    exclusively NumPy vectorized operations to maximize throughput on large arrays.\n    This implementation avoids Python loops and extra allocations by reusing the input array\n    for all intermediate steps and evaluating sin once per element, then transforming to the\n    exponent value and applying exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 32.39368182973873, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse\n    into a single in-place sine evaluation and minimal temporaries. This processes the array with\n    a single vectorized pass, avoids extra allocations, and preserves exactness up to float64 precision\n    relative to the naive implementation.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.176109065707095, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries.\n    This processes the 1D numpy array in-place, minimizing passes and avoiding temporaries.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 41.395590118365774, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation of exp(sin(x) + cos(x)**2)\n    using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    with block-wise processing to optimize cache locality and in-place updates.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 24, "zscore": 31.963597025634165, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries. Compute sin(x) in-place,\n    transform to the exponent value, then apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.14740100429634, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place pass. Compute sin(x) in-place, convert to the exponent argument, and then\n    apply exp in-place. This avoids extra temporaries and minimizes passes for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 32.178114204077644, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation per element and minimal temporaries. This\n    implementation performs all operations in-place to minimize allocations and passes,\n    leveraging NumPy vectorized operations for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (x - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.305262582003415, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single in-place sine transform and then a minimal set of in-place arithmetic,\n    avoiding extra temporaries and passes. This yields exactly the same values as the naive\n    implementation within floating point precision for float64 inputs, while being fast on large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.109411246960285, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    - Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse the computation\n      into a single in-place path, avoiding an explicit cos computation and reducing temporaries.\n    - Compute sin(x) in-place, transform to the exponent argument, then apply exp in-place.\n    - This preserves exact mathematical semantics (up to float64 arithmetic) and minimizes passes and allocations.\n    - All operations are performed with numpy ufuncs using the out parameter to avoid extra allocations.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.11575330609492, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per input and minimal temporaries.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 32.32722961838972, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and perform in-place transformations to avoid temporaries and minimize passes.\n    This computes sin(x) in-place, then applies a sequence of in-place operations:\n    x -= 0.5; x *= x; x *= -1; x += 1.25; then exp in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 40.20083856446602, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) by unfolding the algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) in a streaming, in-place fashion.\n    Process the input in fixed-size blocks to keep memory locality and minimize temporaries.\n    This implementation computes sin(x) in-place for each block, transforms to the exponent\n    argument, and applies exp in-place, returning the original array with updated values.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 24, "zscore": 31.83534399894476, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    to compute exp(sin(x) + cos(x)**2) in a single in-place pass. This avoids a second\n    transcendental evaluation and minimizes temporaries, while preserving exact results\n    for float64 inputs.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 24, "zscore": 30.64652730178039, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries. This computes sin(x) in-place,\n    then applies the transform and exponentiation in-place to avoid extra allocations and passes.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 32.16996053797505, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute\n    in-place with a single sine evaluation and minimal temporaries. This leverages vectorized,\n    in-place NumPy operations for high performance on large inputs.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 31.674348774795497, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place leveraging the identity\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    to avoid a separate cos computation and minimize temporaries.\n    This version uses a single in-place sine evaluation followed by\n    in-place arithmetic and a final in-place exponentiation for speed.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n\n    # Transform: 1.25 - (x - 0.5)^2\n    x -= 0.5\n    np.square(x, out=x)\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 31.762155385644345, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the algebraic identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    This implementation uses in-place NumPy operations to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 24, "zscore": 32.32761444936654, "text": "def build_func(x):\n    \"\"\"\n    Fast in-place evaluation of exp(sin(x) + cos(x)**2)\n    using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Computes sin(x) in-place, then applies the transformation and exponentiation in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 24, "zscore": 32.38238814054147, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to perform\n    in-place computation with a single sine evaluation per element. This minimizes temporaries and\n    passes, and processes the array in-place to avoid extra allocations. The computation is done\n    entirely with NumPy vectorized in-place operations for performance on large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (x - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 31.82120972362528, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to compute in-place in a single\n    vectorized pass. This avoids extra temporaries and Python loops; sin is computed in-place, then the exponent\n    argument is formed with a few in-place operations, followed by exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.35723129003243, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation per element and minimal temporaries.\n    Do not allocate intermediate arrays; rely on in-place operations and a single exp call.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.24337414083027, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos at all and compute sin once per element, then transform to the exponent\n    argument and apply exp in-place. This yields a single in-place pass with minimal temporaries\n    while preserving exact float64 results (up to native FP precision).\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 24, "zscore": 32.323922633277775, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid the cosine computation and minimize temporaries. Compute sin(x) in-place, transform\n    to the exponent argument, and apply exp in-place. This yields a single sin evaluation per\n    element and a single exp evaluation, with all operations performed in-place for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 24, "zscore": 32.17480126742339, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) using the algebraic identity exp(1.25 - (sin(x) - 0.5)**2),\n    which avoids explicitly computing cos and minimizes temporaries. This version performs a single\n    in-place sin over the entire array, then applies the remaining in-place arithmetic to form the\n    exponent argument, and finally applies exp in-place.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 31.999878105800956, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.0 + sin(x) - sin(x)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries. This approach\n    avoids computing cos(x) and reduces memory traffic by performing all operations in-place\n    on the input array, ensuring exact mathematical equivalence and improved performance on large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (sin(x) - 0.5)^2  (equivalent to 1 + sin(x) - sin(x)^2)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 24.639660411610635, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Implement in-place, avoiding cos and temporaries. Compute sin(x) in-place, transform to\n    the exponent argument, then apply exp in-place for a fast, cache-friendly operation.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    np.square(x, out=x)\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 32.05287111677243, "text": "def build_func(x):\n    \"\"\"\n    In-place, vectorized computation of exp(sin(x) + cos(x)**2) using the identity\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2, computed with minimal temporaries.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # x = sin(x) - 0.5\n    x -= 0.5\n    # x = (sin(x) - 0.5)^2\n    np.multiply(x, x, out=x)\n    # x = -(sin(x) - 0.5)^2\n    np.negative(x, out=x)\n    # x = 1.25 - (sin(x) - 0.5)^2\n    x += 1.25\n    # x = exp(...)\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 24, "zscore": 32.12983231709296, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse into a single,\n    in-place, vectorized pass. This avoids Python loops and minimizes temporaries by computing sin(x) in-place\n    and then performing all arithmetic in-place before a final in-place exp. Suitable for large 1-D arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 24.904635084585497, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place to obtain s, then transform to the exponent argument and apply exp in-place.\n    This avoids computing cos, reduces temporaries and passes, and preserves exact float64 results\n    up to typical floating-point precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 32.224412792726504, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a minimal number of passes and no temporary arrays. This\n    variant performs the sine transform in-place and then applies the algebraic\n    transformation and exponentiation in-place, resulting in a three-pass approach\n    over the array (sine, algebraic transform, exponentiation) without Python loops.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.20201990223246, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries.\n    This implementation performs a full-array, in-place vectorized computation:\n    1) compute sin(x) in-place,\n    2) transform to 1.25 - (sin(x) - 0.5)^2 using only in-place operations,\n    3) apply exp in-place.\n    This minimizes passes, temporaries, and Python overhead while preserving numerical\n    equivalence to the naive expression on float64 arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 24, "zscore": 32.10678162175742, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place using the algebraic identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    This allows a single in-place sine evaluation followed by scalar transforms and an in-place exp.\n    Works on 1D NumPy array of dtype float64 and returns the same array object.\n    \"\"\"\n    import numpy as np\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.27162021376926, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries. This computes the correct\n    values exactly (within float64 precision) and avoids extra allocations for large arrays by keeping all computations in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 24, "zscore": 32.30487190576182, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sine evaluation and minimal temporaries, avoiding Python loops.\n    This matches the naive implementation up to float64 precision and is cache-friendly for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.32614696907712, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid\n    computing cos(x) and minimize temporaries. Compute sin(x) in-place, convert to the exponent\n    value with a few in-place ops, then exponentiate in-place. This matches the naive result to\n    float64 precision and is vectorized with no Python loops.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.069196888131025, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Departing from block-based and cos-heavy methods, this approach uses a single, fully vectorized\n    pass that leverages the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    It performs:\n      - one in-place sin computation over the entire array,\n      - an in-place algebraic transform to obtain the exponent argument,\n      - one in-place exponentiation.\n    This avoids Python loops, minimizes temporaries, and relies on NumPy's optimized vectorized operations\n    to achieve faster performance on large arrays while preserving float64 precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 24, "zscore": 31.85838146272642, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid cos computations and minimize temporaries.\n    This version performs a single in-place sin evaluation, then in-place arithmetic to form the exponent argument,\n    followed by an in-place exponential. No extra allocations beyond the input array.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # In-place exponentiation\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 32.146578416127156, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation and minimal temporaries. This keeps\n    all operations vectorized and performs only two passes: one for sin and one for exp.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 40.910526666848, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Apply the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to reduce\n    transcendental evaluations and temporaries. Process in fixed-size blocks to limit peak memory and improve cache locality\n    on very large arrays (~10M elements). This version performs sin on a block in-place, then transforms the block\n    to the exponent argument and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 40.67352658083304, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid explicit cos computation and minimize temporaries. Process the input in fixed-size blocks\n    to maximize cache locality and keep memory usage low, performing all transforms in-place per block.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)       # y := sin(x[i:j])\n        y -= 0.5              # y := sin(x) - 0.5\n        y *= y                # y := (sin(x) - 0.5)^2\n        y *= -1                 # y := - (sin(x) - 0.5)^2\n        y += 1.25               # y := 1.25 - (sin(x) - 0.5)^2\n        exp(y, out=y)         # y := exp(1.25 - (sin(x) - 0.5)^2)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 31.887055727879066, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos, and perform in-place, single-pass transformations to minimize temporaries\n    and memory bandwidth. Compute s = sin(x) in-place, transform to the exponent argument, then\n    apply exp in-place. This yields the exact same results as the naive expression up to\n    float64 precision, with significantly fewer passes on large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 25, "zscore": 31.875612718736367, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin once in-place, transform to\n    the exponent argument, and apply exp in-place for a fast, cache-friendly operation.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.33141169277623, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid\n    computing cos and to perform an in-place, single-pass transformation. This computes sin(x)\n    in-place, then transforms to the exponent argument and applies exp in-place for maximum\n    cache locality and minimal allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.28323480800229, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, transform to\n    the exponent argument, then apply exp in-place. This yields a single in-place pipeline\n    with minimal passes and no extra allocations for large arrays.\n    \n    Steps:\n    1) sin(x, out=x)\n    2) x -= 0.5\n    3) x *= x\n    4) x *= -1\n    5) x += 1.25\n    6) exp(x, out=x)\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 25, "zscore": 32.04045359571535, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin in-place, transform to the exponent\n    argument, and apply exp in-place. This yields a single in-place pass over the array with\n    minimal allocations and passes, suitable for very large inputs while preserving float64 precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 30.792641066356495, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, achieving a fast,\n    cache-friendly, single-array operation suitable for large inputs.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 31.96850114963585, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos, minimize temporaries, and keep a single in-place, two-pass operation.\n    This path computes sin in-place, transforms to exponent argument in-place, then applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 25, "zscore": 32.003268199950156, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently using the exact algebraic identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    In-place to minimize temporaries and passes.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 25, "zscore": 32.168855357823716, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and reduce temporaries, while performing in-place computation\n    for cache-friendly, single-pass transformation. In-place sin update and exponentiate.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 30.813285319325775, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, transform to the\n    exponent argument, and apply exp in-place for a fast, cache-friendly operation with a\n    single sin evaluation and a single exp evaluation over the entire array.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.25088700649797, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid the cos computation and perform a single in-place pass. Compute s = sin(x)\n    in-place, then transform to the exponent argument and apply exp in-place.\n    This yields exact results (within float64) and minimizes temporaries.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.22233910534186, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single in-place pass with minimal temporaries. Compute sin(x) in-place, transform\n    to the exponent argument and apply exp in-place. This avoids extra array allocations and\n    extra transcendental function calls while preserving float64 precision.\n    \"\"\"\n    import numpy as np\n\n    np.sin(x, out=x)\n    x -= 0.5\n    np.square(x, out=x)\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.047093285104225, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    and implement entirely in-place to minimize temporaries and passes. This preserves exact float64 results\n    while avoiding Cos computations and extra allocations.\n    Reasoning: Compute sin into x, then transform in-place to obtain the exponent argument, and finally apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 25, "zscore": 32.19873252532686, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a fundamentally different approach by using the exact algebraic identity\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2 to compute the result with a single\n    transcendental operation. Compute sin(x) in-place for all elements, transform to the\n    exponent argument in-place, then apply exp in-place. This minimizes passes, temporaries,\n    and Python overhead, making it significantly faster for large arrays while preserving\n    float64 accuracy within the expected tolerance.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # In-place computation of sin(x)\n    sin(x, out=x)\n\n    # Transform exponent argument: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 25, "zscore": 32.25064777575264, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, transform to the exponent\n    argument, and apply exp in-place. This preserves the exact float64 results up to native FP precision,\n    while reducing memory pressure and passes on large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.082730376509886, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single, in-place vectorized computation. Compute sin(x) for the entire array\n    in one NumPy call, transform to the exponent argument, and apply exp in-place to minimize\n    temporaries and memory passes for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place for the entire array\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.206552958198905, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and to perform in-place, single-pass transformations with minimal temporaries.\n    This computes sin(x) in-place, transforms to the exponent argument, and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.149606103860734, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation of exp(sin(x) + cos(x)**2) using the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). This implementation\n    computes sin(x) in-place, then transforms to the exponent argument and applies exp\n    in-place. No extra allocations; kernel-friendly for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 25, "zscore": 32.166964733503846, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the algebraic identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    This implementation performs in-place, single-pass operations to minimize temporaries.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 25, "zscore": 32.11406168647103, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into in-place computation with minimal temporaries. This version performs sin on\n    the entire array in one vectorized call, then transforms to the exponent argument and\n    applies exp in-place, avoiding Python loops and extra allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 40.195087249044356, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into in-place computation with minimal temporaries. This implementation processes the input\n    in fixed-size blocks to keep memory locality and avoid large temporaries, while performing as few\n    passes as possible. It computes sin(x) in-place, then transforms to the exponent value and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.10541765579316, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid cos and minimize temporaries.\n    Compute sin(x) in-place, then transform to the exponent argument and apply exp in-place.\n    \"\"\"\n    import numpy as np\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    # Apply exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.321769025182114, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) exactly using the algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). This reduces the computation\n    to a single sine evaluation and a single exponential, in-place to minimize allocations\n    and passes. Although this uses only sin(x) in the exponent, the identity is mathematically\n    exact, and the final result matches the naive implementation up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.243625646631614, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute using sin only and in-place operations, minimizing temporaries and passes while\n    preserving exact float64 results within typical FP precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    np.square(x, out=x)\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 31.947083621276516, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and reduce temporaries. Compute sin(x) in-place, transform to the exponent\n    argument, and apply exp in-place for a single pass with minimal allocations.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 31.893861954175065, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in-place using the algebraic identity:\n    sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2\n    This avoids cos and minimizes temporaries, operating in-place for speed on large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 25, "zscore": 32.12760936290165, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, transform to the\n    exponent argument, then apply exp in-place. This yields a single in-place pass with minimal\n    temporaries while preserving float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 34.897052183106815, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Break from the common pattern by leveraging the algebraic route cos^2(x) = 1 - sin^2(x) to rewrite\n    the exponent as 1 + sin(x) - sin(x)^2, and perform all computations in-place with a block-wise strategy.\n    This preserves exactness with the naive implementation (exp(sin(x) + cos(x)**2)) because\n    sin(x) is computed once, and the relation cos^2 = 1 - sin^2 is algebraically exact.\n    The function:\n      - computes sin(x) in-place,\n      - converts to the exponent argument using y = 1 + s - s^2 via in-place operations (y -= y*y; y += 1),\n      - applies exp in-place,\n      - processes in blocks to improve cache locality for large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)      # y now holds sin(x[i:j])\n        y -= y * y           # 1 + s - s^2 (partial step), since we'll add 1 next\n        y += 1.0\n        exp(y, out=y)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 25, "zscore": 41.605736845480905, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation processes the input in\n    fixed-size blocks to keep memory locality and avoid large temporary allocations, while\n    performing as few passes as possible.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.064979635878366, "text": "def build_func(x):\n    \"\"\"\n    In-place, vectorized evaluation of exp(sin(x) + cos(x)**2)\n    using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Computes sin(x) in-place, then transforms to the exponent and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 31.002889926188754, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place computation with minimal temporaries. This computes sin(x)\n    in-place, then transforms to the exponent argument and applies exp in-place, yielding\n    exactly the same float64 results as the naive implementation up to floating point precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.20988603444723, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a distinct in-place path that keeps all operations within NumPy's ufunc ecosystem,\n    avoiding Python-level arithmetic chaining. Uses the exact algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and performs all steps with in-place\n    ufuncs (out parameters) to minimize temporaries and passes, yielding a clean, fast fused kernel.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Compute (s - 0.5)\n    np.subtract(x, 0.5, out=x)\n    # Compute (s - 0.5)^2\n    np.square(x, out=x)\n    # Multiply by -1: -(s - 0.5)^2\n    np.multiply(x, -1.0, out=x)\n    # Add 1.25: 1.25 - (s - 0.5)^2\n    np.add(x, 1.25, out=x)\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 25, "zscore": 32.043278187067614, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place computation with minimal temporaries. Computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place.\n    This yields a fast, cache-friendly, single-pass operation suitable for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 40.70708360820158, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, transform the exponent\n    argument with in-place arithmetic, then apply exp in-place. Process in fixed-size blocks to\n    improve cache locality for very large inputs while keeping a single pass over data per block.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        np.sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        np.exp(y, out=y)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 25, "zscore": 32.293344884222776, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and minimal temporaries.\n    This avoids computing cos and minimizes memory traffic by performing all operations in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    np.square(x, out=x)\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 25, "zscore": 32.055999289921246, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation of exp(sin(x) + cos(x)**2)\n    Uses the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Computes sin(x) in-place, then transforms to the exponent value\n    and applies exp in-place. Returns the input array with the result.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.47712282488735, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This preserves exact float64 results up to\n    native precision and performs in-place, single-pass transformations for speed on large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.07027039757507, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This performs a single in-place pass:\n    compute sin(x) in-place, transform to the exponent value, then apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 32.090910558859015, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single pass, avoiding cos and minimizing temporaries. \n    This version applies the sin() in-place across the entire array, then transforms in-place\n    to the exponent argument and applies exp in-place for minimal allocations and passes.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 25, "zscore": 75.01638943180019, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Break the input into blocks and process them in parallel using a ThreadPoolExecutor.\n    Each block computes s = sin(x_block) in-place, then uses a per-block scratch buffer to compute\n    1 + s - s^2, and finally applies exp in-place. This yields exp(sin(x) + cos(x)**2) exactly\n    because cos^2(x) = 1 - sin^2(x), so the exponent becomes 1 + sin(x) - sin(x)**2.\n    The per-block scratch avoids extra temporaries and the parallel dispatch leverages multi-core CPUs\n    for large arrays without changing the numerical result.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Allocate per-block scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        # scratch = s^2\n        np.multiply(y, y, out=scratch)\n        # y = 1 + s\n        y += 1.0\n        # y = 1 + s - s^2\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 26, "zscore": 32.247012074205635, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to\n    the exponent value and apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 31.89572797524413, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent value and applies exp in-place, achieving a fast,\n    cache-friendly, single-pass operation over large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 31.90693680182471, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This performs a single sin evaluation in-place,\n    transforms to the exponent argument with in-place operations, and applies exp in-place to produce\n    exact float64 results matching the naive expression up to floating point precision. This approach\n    minimizes passes, temporaries, and memory usage for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.04266469996082, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute entirely in-place with minimal temporaries. This performs a single sin evaluation\n    followed by a chain of in-place ufuncs (subtract, square, negative, add) and a final exp,\n    avoiding extra allocations and keeping memory usage low for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # x now holds s\n    np.subtract(x, 0.5, out=x)  # x = s - 0.5\n    np.square(x, out=x)          # x = (s - 0.5)^2\n    np.negative(x, out=x)         # x = -(s - 0.5)^2\n    np.add(x, 1.25, out=x)        # x = 1.25 - (s - 0.5)^2\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.188989744288904, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid\n    computing cos and minimize temporaries. Compute sin(x) in-place, then transform to the\n    exponent argument with a single in-place pass and apply exp in-place. This yields exactly\n    the same results as the naive implementation up to float64 precision, while reducing passes\n    and temporaries for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.191326840559505, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent argument and apply exp in-place. This yields exactly the same values\n    as the naive implementation up to floating point precision while performing a single\n    sin evaluation per element and minimal intermediate allocations.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 75.16167194658749, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 26, "zscore": 32.05022278672231, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, achieving a fast,\n    cache-friendly, single-pass transformation with minimal temporaries.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.29704541506993, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation uses a single in-place\n    pass: compute sin(x) in-place, then transform the exponent argument and apply exp in-place.\n    This preserves exact float64 results relative to the naive expression while reducing passes\n    and memory allocations for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.18906472309425, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse into a single in-place computation with minimal temporaries. This preserves\n    exact float64 results and performs in-place, single-pass transformations for speed\n    on large arrays by computing sin(x) in-place, transforming to the exponent argument,\n    and applying exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.3398406708494, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) exactly as exp(1 + sin(x) - sin(x)**2)\n    by computing sin(x) in-place and then applying the algebraic transformation\n    to form the exponent, all in a few in-place passes to minimize temporaries.\n    This avoids Python-level loops and leverages NumPy vectorization for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent argument: 1 + s - s^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.344136409066266, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, yielding a fast,\n    cache-friendly, single-pass operation suitable for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 31.95964174752066, "text": "def build_func(x):\n    \"\"\"\n    In-place, using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to minimize temporaries and passes. Works directly on the provided 1D float64 array.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (x - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 31.880444361454924, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, transform to the exponent\n    argument, and apply exp in-place, yielding a fast, cache-friendly, single-array operation with\n    minimal passes for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Apply exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 32.151883897263325, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to\n    the exponent argument and apply exp in-place, achieving a fast, cache-friendly single-array operation.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 32.199034619237835, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation of exp(sin(x) + cos(x)**2).\n    Uses exact algebraic identity: exp(sin x + cos^2 x) = exp(1.25 - (sin x - 0.5)^2).\n    Performs a single in-place sin computation, then transforms to the exponent argument\n    and applies exp in-place for optimal cache locality and minimal temporaries.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Compute exponent: 1.25 - (x - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 31.783305838542542, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to\n    the exponent argument with a sequence of in-place operations, and finally apply exp in-place.\n    This yields the exact same results as the naive implementation (within float64 precision),\n    with a single pass over the data using NumPy vectorized ops and minimal allocations.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.25499734354414, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse computation into a single in-place pass.\n    This computes sin(x) in-place, then transforms to the exponent and exponentiates in-place, ensuring identical results to the naive implementation up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    # compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.122704707512256, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to perform a single, in-place, vectorized pass over the data. This avoids extra temporaries,\n    Python loops, and threading overhead, while guaranteeing identical results as the naive\n    implementation up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.03997933218757, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse into a single, in-place computation with minimal temporaries.\n    Implement as: compute sin(x) in-place; then transform to the exponent value in-place; finally apply exp in-place.\n    This yields exact results within float64 and minimizes passes and temporaries for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 31.92593454998635, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to fuse computations into a single in-place operation with minimal temporaries. This computes sin(x)\n    in-place, then transforms to the exponent argument and applies exp in-place, yielding exactly the\n    same float64 results as the naive implementation up to floating point precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 31.24863580362732, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result in a single, in-place pass per array, avoiding extra temporaries and\n    Python loops. This preserves exact float64 results for the input domain while offering\n    significant speedup on large arrays by reducing passes and memory allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 31.939516500924018, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, achieving a fast,\n    cache-friendly, in-place operation over the array.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 26, "zscore": -55.46254670850806, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use complex exponential to compute both sin and cos components in a single transcendental\n    operation. For each x, compute z = exp(i*x) = cos(x) + i*sin(x). Then sin(x) = Im(z)\n    and cos(x) = Re(z). The exponent sin(x) + cos(x)^2 becomes Im(z) + (Re(z))^2. We\n    process in blocks to limit memory, and apply exp to obtain exp(sin(x) + cos(x)^2) with\n    minimal temporaries and high throughput on large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # 1,048,576\n    if block > n:\n        block = n\n\n    out = np.empty(n, dtype=np.float64)\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        xi = x[i:j]\n        z = np.exp(1j * xi)          # complex array: cos(xi) + i*sin(xi)\n        arg = z.real * z.real + z.imag  # cos(xi)^2 + sin(xi)\n        out[i:j] = np.exp(arg)\n\n    return out", "operator": "explore"}
{"type": "mutation", "generation": 26, "zscore": 32.155301357879395, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single pass over the array, avoiding extra temporaries and\n    extra trig evaluations. This preserves exact float64 results to within floating-point\n    precision while maximizing throughput on large inputs.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 29.181216349530004, "text": "def build_func(x):\n    \"\"\"\n    Fast in-place evaluation using the algebraic identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    This implementation performs a single in-place sin, followed by a small in-place polynomial transform,\n    then a single in-place exp. It avoids temporaries and extra passes for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 32.23366069239369, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This performs a single in-place\n    sine evaluation followed by a sequence of in-place arithmetic operations that\n    transform sin(x) into the exponent argument and then apply exp in-place, yielding\n    exactly the same float64 results as the naive implementation within precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 31.432626565068226, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This is a single in-place, cache-friendly\n    pass: compute sin(x) in-place, transform to the exponent argument, then apply exp in-place.\n    This yields exact float64 results and maximal throughput for large 1D arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 30.96834202016448, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, achieving a fast,\n    cache-friendly, single-pass operation with minimal memory overhead for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.051511773881224, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation using the algebraic identity:\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    Processes the input in a single sin() pass and a single exp() pass with no extra temporaries.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 32.069689378257124, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent argument and apply exp in-place, achieving a fast, cache-friendly,\n    single-pass operation for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.33704031077654, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, achieving a fast,\n    cache-friendly, single-pass operation over large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.23330731956907, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, yielding fast, cache-friendly\n    single-array operation suitable for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 31.9984101472626, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This approach performs a single\n    in-place sin into x, then transforms to the exponent argument and applies exp in-place.\n    This yields exact results consistent with the algebraic identity while maximizing\n    performance on large arrays by avoiding extra allocations and Python loops.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.35176750849859, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, transform to the\n    exponent argument, and apply exp in-place for a fast, cache-friendly operation with a\n    single sin evaluation and a single exp evaluation over the entire array.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 32.31192777800219, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to the\n    exponent argument and apply exp in-place, achieving a fast, cache-friendly, single-array operation.\n    This preserves exact functional equivalence with the naive expression up to floating point precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 26, "zscore": 30.49924645038518, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a two-scratch, two-pass approach that trades memory for clear, vectorized computation.\n    1) Compute s = sin(x) into a dedicated scratch array sbuf (leaving the input untouched).\n    2) Compute s^2 into a second scratch array tmp.\n    3) Assemble the exponent as 1 + s - s^2 in sbuf, then apply exp in-place.\n    This yields exp(1 + sin(x) - sin(x)^2) = exp(sin(x) + cos(x)**2) exactly for float64 inputs.\n    The implementation avoids Python loops and keeps all operations in NumPy, benefiting large arrays (~1e7 elements).\n    \"\"\"\n    import numpy as np\n\n    # Scratch buffers\n    sbuf = np.empty_like(x)\n    tmp = np.empty_like(x)\n\n    # s = sin(x) stored in sbuf\n    np.sin(x, out=sbuf)\n\n    # tmp = s^2\n    np.multiply(sbuf, sbuf, out=tmp)\n\n    # exponent = 1 + s - s^2\n    sbuf += 1.0\n    sbuf -= tmp\n\n    # exp in-place\n    np.exp(sbuf, out=sbuf)\n\n    return sbuf", "operator": "explore"}
{"type": "mutation", "generation": 26, "zscore": 32.30034788338638, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cos.\n    Process input in-place: compute s = sin(x) in-place, then transform to the exponent argument and apply exp in-place.\n    This minimizes temporaries and passes for large arrays, preserving float64 accuracy within tolerance of the naive implementation.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 26, "zscore": 32.24254746097575, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This implementation computes sin(x) in-place,\n    then transforms to the exponent argument and applies exp in-place, achieving a fast,\n    cache-friendly, single-array operation suitable for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 26, "zscore": 42.79940245546428, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks for cache locality.\n    Compute sin(x) in-place, then transform to the exponent argument with minimal passes:\n    after sin(y): y -= 0.5; y *= y; y = 1.25 - y (via np.subtract with out=y); exp(y, out=y).\n    This yields exact mathematical equivalence (up to float64 precision) with fewer passes.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n    sub = np.subtract\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        sub(1.25, y, out=y)\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 31.730939174260357, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute entirely in-place with minimal temporaries. This performs a single sin evaluation\n    followed by a chain of in-place transforms and a final exp, avoiding extra allocations and\n    keeping memory usage low for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place; x now holds sin(x)\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1.0\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.00916431852176, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid extra temporaries and minimize transcendental evaluations. Compute sin in-place,\n    then transform to the exponent value with a tight chain of in-place operations, and\n    finally apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 27, "zscore": 31.963981750333446, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) =\n    exp(1.25 - (sin(x) - 0.5)**2) to avoid computing cos and minimize temporaries.\n    Compute sin(x) in-place, then transform to the exponent value with a chain of\n    in-place operations: x -= 0.5; x *= x; x = -x; x += 1.25; exp in-place.\n    This yields exact float64 results equivalent to the naive formulation.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    np.subtract(x, 0.5, out=x)  # x = s - 0.5\n    np.multiply(x, x, out=x)     # x = (s - 0.5)^2\n    np.negative(x, out=x)         # x = -(s - 0.5)^2\n    np.add(x, 1.25, out=x)        # x = 1.25 - (s - 0.5)^2\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 31.99693443046373, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to the\n    exponent value with a minimal set of in-place operations, and finally apply exp in-place.\n    This yields the exact same results as the naive formulation (within float64 precision) with\n    a single transcendental evaluation and a few vectorized operations, ideal for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 31.996519522942734, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute in-place using a single sin pass and the exact algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2). This minimizes temporaries and passes\n    while keeping the result numerically identical to the naive implementation up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 75.12798983055292, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 36.62898553533143, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to the exponent\n    value with minimal passes and apply exp in-place.\n    Steps:\n    1) Compute s = sin(x) in-place\n    2) x -= 0.5\n    3) x *= x   -> x = (s - 0.5)^2\n    4) x = 1.25 - x\n    5) x = exp(x)\n    This yields exact mathematical equivalence (up to float64 precision) with fewer passes and no extra temporaries.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # x now holds s; transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 27, "zscore": 36.90184876508226, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute entirely in-place with a single sin pass and minimal temporaries. This preserves\n    exact mathematical equivalence to the naive expression up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # x now holds s = sin(x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    np.subtract(x, 0.5, out=x)  # x = s - 0.5\n    np.multiply(x, x, out=x)     # x = (s - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x = 1.25 - (s - 0.5)^2\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.09215352784257, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) in a single in-place pass using the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    This avoids extra temporaries and keeps memory usage low for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x        # (sin(x) - 0.5)^2\n    x *= -1       # -(sin(x) - 0.5)^2\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 27, "zscore": 32.07276908884713, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    (which is algebraically equal to 1 + sin(x) - sin(x)**2) to avoid computing cos and minimize temporaries.\n    Process the input in-place: compute sin(x) in-place, then transform to the exponent and apply exp in-place.\n    This yields exact mathematical equivalence with fewer passes and allocations.\n    \"\"\"\n    import numpy as np\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # exponent = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 36.56629182922832, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute the result using only in-place NumPy operations, minimizing temporaries and passes.\n    Steps: sin(x) in-place, x = x - 0.5, x = x^2, x = 1.25 - x, exp in-place.\n    This keeps memory usage low and avoids Python-level loops.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n    sub = np.subtract\n\n    # 1) Compute sin(x) in-place\n    sin(x, out=x)\n    # 2) x = sin(x) - 0.5\n    x -= 0.5\n    # 3) x = (sin(x) - 0.5)^2\n    x *= x\n    # 4) x = 1.25 - x\n    sub(1.25, x, out=x)\n    # 5) exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 27, "zscore": 33.392057940900735, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to\n    avoid computing cos and to minimize temporaries. Process the entire 1D array with in-place\n    NumPy operations and a single per-call scratch buffer to store sin(x)^2, achieving fast,\n    vectorized execution on large arrays while preserving numerical equivalence up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    # Scratch buffer to hold sin(x)^2\n    scratch = np.empty_like(x)\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # scratch = s^2\n    np.multiply(x, x, out=scratch)\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.11382569719071, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to the exponent\n    value with a few in-place operations, followed by a single in-place exp. This yields the exact\n    same results as the naive formulation up to floating point precision while minimizing passes and memory.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.076556767278106, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with minimal temporaries. Compute sin(x) in-place, then transform to the\n    exponent value and apply exp in-place, achieving fast, cache-friendly, single-array operation.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 27, "zscore": 34.686386874729216, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the identity cos^2(x) = 1 - sin^2(x),\n    so the exponent becomes 1 + sin(x) - sin(x)^2. Processes input in fixed-size\n    blocks to improve cache locality, using a per-block scratch buffer for sin^2.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=np.float64)\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        np.sin(y, out=y)                       # y now contains sin(x[i:j])\n        length = j - i\n        np.multiply(y, y, out=scratch[:length])  # scratch = sin(x[i:j])^2\n        y += 1.0\n        y -= scratch[:length]                   # y = 1 + sin(x[i:j]) - sin(x[i:j])^2\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.25521595644647, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to\n    the exponent value with minimal passes: (sin(x) - 0.5)^2, then exponentiate in-place.\n    This preserves exact functional equivalence up to floating point precision and minimizes\n    memory traffic for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute s = sin(x) in-place\n    sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 27, "zscore": 32.30532969627071, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then transform to the exponent argument and apply exp in-place\n    to avoid temporaries. This minimizes passes and allocations for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # x currently holds s\n    x -= 0.5          # x = s - 0.5\n    x *= x            # x = (s - 0.5)^2\n    np.negative(x, out=x)  # x = -(s - 0.5)^2\n    x += 1.25         # x = 1.25 - (s - 0.5)^2\n    np.exp(x, out=x)  # x = exp(1.25 - (s - 0.5)^2) = exp(sin(x) + cos(x)**2)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 27, "zscore": 36.72269963644879, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation using identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    One-pass in-place sine followed by a few operations in-place for speed on large arrays.\n    \"\"\"\n    import numpy as np\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # Exponent argument: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 27, "zscore": 75.17402963338886, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks for cache locality.\n    Compute sin in-place, then transform to the exponent with a per-block scratch buffer for sin^2,\n    and finally apply exp in-place. For very large arrays, parallelize across blocks to leverage\n    multi-core CPUs while preserving numerical correctness.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    # Parallelize for large inputs; otherwise run in a single thread\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 27, "zscore": 40.74840862047555, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Process in block-sized chunks to improve cache locality\n    and perform all updates in-place to minimize memory usage. This yields exact functional equivalence\n    with the naive formulation up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 31.929523223721354, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin per element and minimal temporaries, preserving\n    exact mathematical equivalence up to floating point precision. This avoids repeated\n    trig evaluations (no cos) and minimizes allocations by operating in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (x - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 29.62774600897812, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent value with minimal passes and apply exp in-place for maximal cache locality\n    and to avoid extra allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent transformation: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.234794939452556, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute entirely in-place with a single sin evaluation and a small chain of\n    in-place operations, avoiding loops and extra temporaries. This preserves\n    numerical fidelity to the naive expression within float64 precision and is\n    highly cache-friendly for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Compute 1.25 - (s - 0.5)^2 in-place\n    x -= 0.5      # x = s - 0.5\n    x *= x        # x = (s - 0.5)^2\n    x *= -1       # x = -(s - 0.5)^2\n    x += 1.25      # x = 1.25 - (s - 0.5)^2\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 36.63473695703063, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute with minimal temporaries. This in-place approach computes sin(x) into x,\n    then transforms to the exponent and applies exp in-place, keeping memory usage minimal\n    and avoiding extra allocations for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # x now holds s\n    x -= 0.5          # s - 0.5\n    x *= x            # (s - 0.5)^2\n    np.subtract(1.25, x, out=x)  # 1.25 - (s - 0.5)^2\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 31.858349951435443, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place and then transform\n    to the exponent value with a minimal set of in-place operations, finishing with exp in-place.\n    This yields exact functional equivalence (up to floating point rounding) with the naive\n    expression while reducing memory traffic for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # x now contains sin(x); transform to 1.25 - (sin(x) - 0.5)^2 in-place\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.14216906721871, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to\n    the exponent value with a small chain of in-place operations, and apply exp in-place.\n    This yields exact mathematical equivalence (within float64 precision) and minimizes\n    passes and allocations for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 28.97951326678874, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to the\n    exponent value with minimal passes: after sin(y): y -= 0.5; y *= y; y *= -1; y += 1.25;\n    exp in-place to obtain the final result. This yields exact equivalence up to float64 precision\n    while using a single sin evaluation and no additional allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.267792362427706, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently using the algebraic identity:\n    exp(sin(x) + cos(x)**2) = exp(1.0 + sin(x) - sin(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    This implementation uses a single sin call and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent value: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x          # (sin(x) - 0.5)^2\n    x *= -1         # - (sin(x) - 0.5)^2\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 27, "zscore": 33.369430442734405, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Process in fixed-size blocks to improve cache locality for large arrays, compute sin(x)\n    in-place per block, store sin^2(x) in a per-block scratch buffer, then form the exponent\n    and apply exp in-place. This yields exact algebraic equivalence to the naive formulation\n    up to float64 precision while minimizing allocations and passes.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        # Compute sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for sin^2(x)\n        scratch = np.empty(j - i, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # Exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 31.752707631060858, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and minimal temporaries.\n    Process in-place to minimize allocations and passes; uses sin(x) in-place, then transforms\n    to the exponent with a small number of in-place operations and finally applies exp in-place.\n    This preserves exact mathematical equivalence up to float64 rounding and is cache-friendly\n    for large arrays.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.01173325924858, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity cos^2(x) = 1 - sin^2(x) so that\n    exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin in-place to reuse memory, then transform to the exponent with\n    in-place operations to avoid temporaries and extra passes. This preserves\n    exact functional equivalence to the naive formulation within float64 precision\n    and avoids Python-level loops for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2  => 1 + sin(x) - sin(x)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 75.06040980193629, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently by using the identity cos^2(x) = 1 - sin^2(x),\n    implemented in block-wise parallel fashion to minimize allocations and maximize throughput\n    for large arrays.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # Compute exponent: 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 27, "zscore": 34.4897796938128, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to avoid computing cos\n    and minimize temporaries. Process in fixed-size blocks to improve cache locality and reuse a\n    per-block scratch buffer for sin(x)^2, preserving exact mathematical equivalence up to\n    float64 precision while keeping memory usage low for large inputs.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=np.float64)\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)  # y holds sin(x[i:j])\n        b = j - i\n        np.multiply(y, y, out=scratch[:b])  # scratch = sin(x[i:j])^2\n        y += 1.0\n        y -= scratch[:b]                   # y = 1 + sin(x) - sin(x)^2\n        exp(y, out=y)                        # in-place exp\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 32.26544293796231, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin in-place, then transform\n    to the exponent value with a single in-place chain, and exponentiate in-place.\n    This preserves exact functional equivalence (up to float64 precision) and minimizes\n    passes and allocations for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    np.square(x, out=x)   # (sin(x) - 0.5)^2\n    np.negative(x, out=x) # -(sin(x) - 0.5)^2\n    np.add(x, 1.25, out=x)  # 1.25 - (sin(x) - 0.5)^2\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 33.3704072927547, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to avoid computing cos.\n    Process in fixed-size blocks to improve cache locality and keep memory usage low while avoiding extra\n    large temporaries. Each block computes sin in-place, then forms 1 + s - s^2 (via a scratch s^2),\n    and finally applies exp in-place to yield the correct result.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # s2 = s^2\n        s2 = y * y\n        # exponent value: 1 + s - s^2\n        y += 1.0\n        y -= s2\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 31.996126508595236, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform to\n    the exponent value with minimal passes and apply exp in-place.\n    This yields identical results to the naive formulation up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 36.65912685566333, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Process in-place to minimize passes:\n    compute sin in-place, then transform to the exponent and apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # x now holds s; compute (s - 0.5)^2\n    x -= 0.5\n    x *= x\n\n    # x = 1.25 - (s - 0.5)^2\n    np.subtract(1.25, x, out=x)\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 27, "zscore": 32.17880941861366, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place evaluation using the exact algebraic identity cos^2(x) = 1 - sin^2(x),\n    so exp(sin(x) + cos^2(x)) = exp(1 + sin(x) - sin(x)**2) which is numerically stable and\n    requires only a single sine evaluation and a small in-place transform.\n    We compute sin(x) in-place, then convert to the exponent value with minimal temporaries:\n    x = sin(x) -> x = 1.25 - (sin(x) - 0.5)^2 -> exp in-place.\n    This approach avoids extra allocations and keeps memory usage low for large inputs.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    exp = np.exp\n\n    sin(x, out=x)  # x now holds s = sin(original_x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 34.245559324201174, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Process the input in fixed-size blocks to improve cache locality. For each block:\n      - compute s = sin(x_block) in-place,\n      - compute s^2 into a per-block scratch buffer to avoid extra full-array temporaries,\n      - transform to exponent: 1 + s - s^2 in-place, and\n      - apply exp in-place.\n    This preserves exact mathematical equivalence (within floating point precision) with\n    the naive implementation and reduces peak memory usage by avoiding large temporaries.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Pre-allocate scratch for per-block s^2\n    scratch = np.empty(block, dtype=np.float64)\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        # s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = j - i\n        # scratch[:m] = s^2\n        np.multiply(y, y, out=scratch[:m])\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch[:m]\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 27, "zscore": 33.37886634737204, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact algebra: exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Compute sin(x) for the entire array in-place to obtain s. Then process in fixed-size blocks to\n    compute s^2 into a scratch buffer, update in-place: x[i:j] += 1; x[i:j] -= s^2; then x[i:j] = exp(x[i:j]).\n    This minimizes passes and temporaries while preserving numerical equivalence (up to float64 precision).\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Step 1: compute sin for the whole array in-place\n    np.sin(x, out=x)\n\n    # Step 2: per-block scratch for s^2\n    scratch = np.empty(block, dtype=x.dtype)\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        m = j - i\n        # scratch[0:m] = s^2\n        np.multiply(x[i:j], x[i:j], out=scratch[:m])\n        # x[i:j] = 1 + s - s^2\n        x[i:j] += 1.0\n        x[i:j] -= scratch[:m]\n        # exp in-place\n        np.exp(x[i:j], out=x[i:j])\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 28, "zscore": 31.21752911124958, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    which is algebraically identical to exp(1.25 - (sin(x) - 0.5)**2). This form allows\n    an in-place, single-pass transformation with minimal temporaries:\n    compute sin(x) in-place, then convert to the exponent using 1.25 - (sin(x) - 0.5)^2,\n    and finally apply exp in-place. This preserves exact results (within float64 precision)\n    while reducing memory traffic and avoiding extra allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2 in-place\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.24059971247747, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent value with a minimal in-place sequence: sin -> (sin - 0.5) -> square ->\n    negate -> add 1.25, then exp in-place. This yields exact functional equivalence (within\n    float64 precision) with the naive formulation while avoiding extra allocations and passes.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 28, "zscore": 33.32683966494428, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin(x) in-place, then compute s^2 into a scratch array,\n    then compute exponent = 1 + s - s^2 in-place, and finally apply exp in-place.\n    This minimizes temporaries and passes and avoids Python loops; uses a single extra\n    array the size of x for the s^2 terms.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for s^2\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 33.24911246924527, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks for cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and perform\n    in-place transformations to minimize allocations and passes while preserving\n    numerical correctness.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for start in range(0, n, block):\n        end = min(start + block, n)\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 73.16074147586845, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks and parallelize across blocks\n    for large inputs, reusing a single preallocated scratch buffer to store sin^2\n    and minimize allocations and passes over data.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Shared scratch buffer to store sin^2 for each block\n    scratch = np.empty(n, dtype=np.float64)\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch_slice = scratch[start:end]\n        np.multiply(y, y, out=scratch_slice)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch_slice\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 74.97334447693757, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks for cache locality.\n    Compute sin in-place, then transform to the exponent with a per-block scratch buffer for sin^2,\n    and finally apply exp in-place. For very large arrays, parallelize across blocks to leverage\n    multi-core CPUs while preserving numerical correctness.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # Scratch buffer for s^2\n        scratch = np.empty(m, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 33.114551764205814, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Implement a fully vectorized, in-place approach with a single\n    temporary scratch array to hold sin(x)^2, achieving minimal Python overhead and\n    maximal throughput on large arrays. This yields identical results to the naive\n    implementation up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    scratch = np.empty_like(x)\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n    # scratch = s^2\n    np.multiply(x, x, out=scratch)\n    # exponent = 1 + s - s^2\n    x += 1.0\n    np.subtract(x, scratch, out=x)\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 34.22109859158724, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks to improve cache locality.\n    Reuse a single per-block scratch buffer to compute sin(x)^2 without allocating per-block temporaries, and\n    exponentiate in-place. This maintains numerical equivalence up to float64 precision while improving throughput\n    on large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Reusable scratch buffer for sin^2 per block\n    scratch = np.empty(block, dtype=np.float64)\n\n    for start in range(0, n, block):\n        end = min(start + block, n)\n        y = x[start:end]\n        # Compute s = sin(y) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # Compute s^2 into scratch\n        np.multiply(y, y, out=scratch[:m])\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch[:m]\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 33.00273673795855, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin in-place and reuse a single preallocated scratch\n    buffer for sin(x)**2 to minimize allocations and Python overhead, enabling fast\n    NumPy-vectorized operations over very large arrays. This preserves numerical correctness\n    up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Allocate a scratch buffer for s^2\n    scratch = np.empty(n, dtype=np.float64)\n\n    # scratch = s^2\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.308499317660605, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent value with minimal passes and apply exp in-place for maximum cache locality\n    and to avoid extra allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 28, "zscore": 34.249543775499745, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Propose a novel, block-wise fused kernel that preserves exactness and minimizes Python overhead.\n    - Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to avoid cos.\n    - Process the 1D float64 array in fixed-size blocks to keep memory locality and limit peak scratch usage.\n    - Compute sin in-place, store sin^2 in a shared block scratch (no per-element temporaries), then form the exponent\n      argument as 1 + sin - sin^2 and apply exp in-place.\n    - This design avoids Python-level loops over every element and reduces transient allocations by reusing a single scratch buffer.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = min(1 << 20, n)  # ~1,048,576 max block\n    scratch = np.empty(block, dtype=np.float64)\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # scratch[:m] = s^2 using a in-place scratch to avoid temporaries\n        np.multiply(y, y, out=scratch[:m])\n        # exponent = 1 + s - s^2\n        y += 1.0\n        np.subtract(y, scratch[:m], out=y)\n        # exp in-place\n        np.exp(y, out=y)\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        process_block(i, j)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 28, "zscore": 36.47313138096204, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin in-place, then transform to the exponent with a minimal\n    set of in-place operations, finishing with exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 31.753736025688653, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin in-place, then transform to the exponent in-place\n    for minimal temporaries and maximal speed. All operations are in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent = 1.25 - (x - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 34.4056470444258, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality,\n    reuse a single per-block scratch buffer to store sin(x)^2, and perform exp in-place.\n    No additional allocations per block beyond the scratch buffer.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=np.float64)\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # scratch = s^2\n        np.multiply(y, y, out=scratch[:m])\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch[:m]\n        # exp in-place\n        np.exp(y, out=y)\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 75.04665488430025, "text": "def build_func(x):\n    \"\"\"\n    In-place blockwise computation using identity exp(1 + sin(x) - sin(x)**2)\n    to avoid cos. Processes in fixed-size blocks and uses per-block scratch memory.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 28, "zscore": 34.45185481891567, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin(x) in-place, then transform to the exponent value\n    entirely in-place with minimal passes and no temporaries.\n    \"\"\"\n    import numpy as np\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # Exponent = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5      # sin(x) - 0.5\n    x *= x        # (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # 1.25 - (sin - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 36.54414768131954, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Process in-place: compute sin(x) in-place, then transform to the exponent\n    with a minimal set of operations, finishing with exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent argument: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 74.84829848133259, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks for cache locality,\n    use a per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 34.68886999634148, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to minimize temporaries and\n    passes. Compute sin in-place, then form exponent using a per-block scratch buffer\n    for sin^2, and apply exp in-place.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    scratch = None\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)  # y now contains sin(x_block)\n        m = j - i\n        if scratch is None or scratch.shape[0] < m:\n            scratch = np.empty(m, dtype=np.float64)\n        np.multiply(y, y, out=scratch[:m])  # scratch = sin(x_block)^2\n        y += 1.0\n        y -= scratch[:m]  # exponent = 1 + sin(x) - sin(x)^2\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.144669033821266, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) \n    (via cos^2 = 1 - sin^2) or equivalently exp(1.25 - (sin(x) - 0.5)**2) to avoid cos,\n    while performing all operations in-place to minimize temporaries and passes.\n    Steps (in-place):\n    1) Compute sin in-place: np.sin(x, out=x)\n    2) Exponent argument: 1.25 - (sin(x) - 0.5)^2 implemented as:\n       x -= 0.5; x *= x; x *= -1; x += 1.25\n    3) Exponentiate in-place: np.exp(x, out=x)\n    \"\"\"\n    import numpy as np\n\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 74.90246782526927, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation using identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Processes input in fixed-size blocks with per-thread scratch buffers to minimize allocations\n    and maximize throughput on large arrays.\n    \"\"\"\n    import numpy as np\n    import threading\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Persist per-thread scratch buffers to avoid repeated allocations.\n    if not hasattr(build_func, \"_scratch_by_thread\"):\n        build_func._scratch_by_thread = {}\n    scratch_by_thread = build_func._scratch_by_thread\n\n    def _get_scratch():\n        tid = threading.get_ident()\n        arr = scratch_by_thread.get(tid)\n        if arr is None or arr.size < block:\n            arr = np.empty(block, dtype=np.float64)\n            scratch_by_thread[tid] = arr\n        return arr\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute sin in-place\n        np.sin(y, out=y)\n        bs = end - start\n        scratch = _get_scratch()\n        tmp = scratch[:bs]\n        # Compute sin(x)^2 into temp\n        np.multiply(y, y, out=tmp)\n        # Exponent: 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= tmp\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 36.27688665960002, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Process the entire 1D array in a single\n    vectorized pass: compute sin in-place, then transform to the exponent with minimal passes\n    and exponentiate in-place.\n    \"\"\"\n    import numpy as np\n\n    if x.size == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 28, "zscore": 33.180551126951606, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, allocate a single\n    scratch buffer for sin^2, then form the exponent as 1 + s - s^2 and exponentiate in-place.\n    This eliminates Python loops and per-block allocations, reduces passes, and remains\n    numerically equivalent (up to float64 precision) to the naive formulation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for s^2\n    scratch = np.empty(n, dtype=np.float64)\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": NaN, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks to improve\n    cache locality, use a per-block scratch buffer for sin(x)^2 to avoid temporaries, and\n    parallelize blocks to utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Shared scratch buffer to avoid per-block allocations\n    scratch_buffer = np.empty(block, dtype=np.float64)\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # scratch = s^2 using a shared buffer\n        scratch = scratch_buffer[:m]\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = i + block\n            if j > n:\n                j = n\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 31.452383453706933, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform in-place\n    with a minimal number of operations and a single exp call to maximize throughput on large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1.0\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 36.874152093892704, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin in-place, then transform to the exponent value in-place\n    with minimal temporaries and finalize with exp in-place. This keeps all operations vectorized\n    and uses no extra allocations, yielding exact float64 results comparable to the naive form.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Compute (sin(x) - 0.5)^2 in-place\n    x -= 0.5\n    x *= x\n\n    # Compute 1.25 - (sin(x) - 0.5)^2 in-place\n    np.subtract(1.25, x, out=x)\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 28, "zscore": 36.698464052805974, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin in-place, then transform\n    to the exponent value with minimal passes and apply exp in-place for maximal cache locality.\n    This yields exact equivalence (up to floating point rounding) with the naive formulation\n    while performing only in-place NumPy operations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # exponent = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5      # now x = sin(x) - 0.5\n    x *= x        # (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # 1.25 - (sin(x) - 0.5)^2\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 74.99082814210796, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process data in fixed-size blocks for cache locality and use\n    a per-block scratch buffer to hold sin(x)**2, enabling an in-place, multi-pass but\n    low-allocation pipeline. Parallelize across blocks for large inputs while avoiding\n    contention on shared memory.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 28, "zscore": 32.362863521469144, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent value in-place and apply exp in-place for maximum cache locality and\n    minimal allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 34.229532617843624, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality and minimize\n    temporaries. Use a per-block scratch buffer to hold sin^2(x) without creating large extra arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=np.float64)\n\n    sin = np.sin\n    exp = np.exp\n    mul = np.multiply\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)  # y now holds s = sin(original_x)\n        m = j - i\n        mul(y, y, out=scratch[:m])  # scratch = s^2\n        y += 1.0\n        y -= scratch[:m]  # exponent = 1 + s - s^2\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.10204313130376, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent value in-place and exponentiate, avoiding extra allocations and passes.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin in-place\n    np.sin(x, out=x)\n\n    # Exponent = 1.25 - (sin(x) - 0.5)^2 via in-place operations\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponential in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.18288149574499, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin(x) in-place, then transform to the exponent value with\n    minimal passes, finishing with exp in-place. This yields exact equivalence (up to floating point\n    rounding) with the naive expression while reducing memory traffic for large inputs.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # exponent = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)  # x = -(sin(x) - 0.5)^2\n    x += 1.25\n\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.23961473222527, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin in-place, then transform to the exponent in-place\n    and finally apply exp in-place for maximal cache locality and minimal temporaries.\n    The result is mathematically identical to the naive expression for float64.\n    \"\"\"\n    import numpy as np\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent = 1.25 - (s - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.33018429345247, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then\n    transform to the exponent value entirely in-place: (sin(x) - 0.5)^2 -> negate\n    -> add 1.25, then exp in-place.\n    \"\"\"\n    import numpy as np\n\n    # In-place sine\n    np.sin(x, out=x)\n    # exp_arg = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n    np.exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 28, "zscore": 34.64813838471901, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, reuse\n    a per-block scratch buffer to hold sin(x)^2 and perform in-place transforms, keeping\n    memory usage bounded for large arrays and avoiding Python-level element-wise loops.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Pre-allocate a scratch buffer for squares, reused across blocks\n    scratch_all = np.empty(block, dtype=np.float64)\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        # compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        l = j - i\n        scratch = scratch_all[:l]\n        # s^2 into scratch\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.05582297548033, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Process the entire input in a single\n    vectorized pass to maximize throughput on large arrays by avoiding Python loops and\n    extra allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # Exponent argument: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 32.13451926293913, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin in-place and transform to the exponent value with a\n    minimal set of in-place operations, finishing with exp in-place. This preserves exact values\n    up to floating point rounding and is fast for large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent = 1.25 - (sin(x) - 0.5)^2  -> 1.0 + sin(x) - sin(x)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 28, "zscore": 34.43885032699832, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Process in fixed-size blocks, compute sin in-place, and reuse a scratch buffer to hold sin(x)^2\n    to avoid extra allocations while preserving numerical correctness within float64.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    scratch = np.empty(block, dtype=x.dtype)\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)  # y now contains sin(x[i:j])\n        m = j - i\n        s2 = scratch[:m]\n        np.multiply(y, y, out=s2)  # s^2\n        y += 1.0  # 1 + s\n        y -= s2   # 1 + s - s^2\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 36.56081529438953, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent with a minimal set of in-place operations. This keeps a single sin\n    evaluation and a single exp, with no additional allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # exponent = 1.25 - (sin(x) - 0.5)**2\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 28, "zscore": 73.20848256958455, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Propose a completely different paradigm from the common identities by performing\n    a block-wise, in-place computation that reuses a single preallocated scratch buffer partitioned\n    per block. This enables multi-threaded execution with no per-block allocations, while preserving\n    numerical exactness by sticking to the exact arithmetic:\n        f(x) = exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    The implementation processes the input in fixed-size blocks, computes sin in-place, stores sin^2\n    into a per-block slice of a preallocated scratch buffer, then completes the final expression\n    in-place and applies exp in-place. A thread pool is used for large inputs; scratch memory is\n    partitioned to avoid data races across threads.\n    \"\"\"\n\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.size\n    if n == 0:\n        return x\n\n    # Block size tuned for cache and vectorization benefits\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    nb = (n + block - 1) // block  # number of blocks\n\n    # Preallocate a single large scratch buffer and partition it per block to avoid races\n    scratch_big = np.empty(nb * block, dtype=np.float64)\n\n    def process_block(start, end, bid):\n        y = x[start:end]  # in-place view to operate directly on input\n        # Compute sin into-place\n        np.sin(y, out=y)\n        m = end - start\n        # Per-block scratch for sin(x)^2\n        s = scratch_big[bid * block: bid * block + m]\n        np.multiply(y, y, out=s)  # s = sin(x)^2\n        # exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= s\n        # exp in-place\n        np.exp(y, out=y)\n\n    # Choose between sequential and multi-threaded execution\n    if n > 1_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                bid = i // block\n                futures.append(executor.submit(process_block, i, j, bid))\n            for f in futures:\n                f.result()\n    else:\n        bid = 0\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j, bid)\n            bid += 1\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 29, "zscore": 33.55316736026806, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks for cache locality. Compute sin in-place,\n    reuse a single per-block scratch buffer for sin^2 to minimize allocations, and apply exp in-place.\n    This preserves exact results and speeds up large arrays by reducing Python overhead.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=np.float64)\n\n    for start in range(0, n, block):\n        end = min(start + block, n)\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n\n        m = end - start\n        # Scratch buffer for s^2\n        np.multiply(y, y, out=scratch[:m])\n\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch[:m]\n\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 31.96272926950995, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) = \n    exp(1 + sin(x) - sin(x)**2). Compute sin in-place, then transform to the exponent\n    using the compact, in-place form to avoid temporaries and extra passes. This yields\n    exact results (within float64) and minimizes memory traffic by avoiding extra arrays.\n    \"\"\"\n    import numpy as np\n\n    if x.size == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 36.581429364537094, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    which is algebraically equivalent to exp(1.25 - (sin(x) - 0.5)**2). \n    Compute sin(x) in-place, then transform to the exponent with a minimal number of\n    temporary allocations, and exponentiate in-place. This preserves exact results\n    (within float64) while reducing memory traffic and avoiding extra temporaries.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # exponent = 1.25 - (x - 0.5)^2  (in-place)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 75.08041410469099, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while preserving numerical equivalence to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.size\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n    mul = np.multiply  # for readability; still uses in-place operations\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        mul(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 74.99371942261736, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks for cache locality.\n    Compute sin in-place, then transform to the exponent with a per-block scratch buffer for sin^2,\n    and finally apply exp in-place. For very large arrays, parallelize across blocks to leverage\n    multi-core CPUs while preserving numerical correctness.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 29, "zscore": 34.3229345286836, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality,\n    use a per-block scratch buffer for sin(x)^2 to minimize temporaries, and perform\n    in-place transformations to maximize throughput on large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=np.float64)\n\n    for start in range(0, n, block):\n        end = start + block\n        if end > n:\n            end = n\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        s2 = scratch[:m]\n        # s2 = s^2\n        np.multiply(y, y, out=s2)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= s2\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": NaN, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to avoid computing cos.\n    Process in fixed-size blocks to improve cache locality, and reuse a single scratch buffer across blocks\n    to minimize allocations. For very large inputs, parallelize across blocks to utilize multi-core CPUs\n    while preserving numerical equivalence (within float64 precision) to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Reusable scratch buffer for sin^2 values per block\n    scratch = np.empty(block, dtype=x.dtype)\n\n    def process_block(start, end):\n        y = x[start:end]\n        # s = sin(x_block) in-place\n        np.sin(y, out=y)\n        size = end - start\n        # scratch[:size] = s^2\n        np.multiply(y, y, out=scratch[:size])\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch[:size]\n        # exp in-place\n        np.exp(y, out=y)\n\n    # Parallelize for very large inputs; otherwise run in a single thread\n    if n > 4 * block:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 74.84146350696169, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) more efficiently by using cos^2 = 1 - sin^2,\n    i.e., exp(1 + sin(x) - sin(x)^2). Process in fixed-size blocks to improve cache locality,\n    and use a per-thread scratch buffer to avoid per-block allocations while keeping results\n    identical to the naive formulation. Parallelize blocks with a ThreadPoolExecutor to\n    utilize multiple cores.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n    import threading\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    thread_local = threading.local()\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # Per-thread scratch buffer for s^2\n        scratch = getattr(thread_local, 'scratch', None)\n        if scratch is None or scratch.shape[0] < m:\n            scratch = np.empty(max(block, m), dtype=np.float64)\n            thread_local.scratch = scratch\n        scratch_view = scratch[:m]\n        np.multiply(y, y, out=scratch_view)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch_view\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 33.09898975639734, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Perform sin(x) in-place, store sin^2 in a scratch buffer,\n    then compute the exponent and apply exp in-place. This minimizes Python overhead and\n    passes over data for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    if x.size == 0:\n        return x\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for s^2\n    scratch = np.empty_like(x)\n\n    # s2 = s^2\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 33.28213593021802, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    and implement a single, large, in-place pipeline to minimize Python overhead and avoid per-block allocations.\n    Compute sin in-place, square into a separate scratch buffer (preallocated to the full input size),\n    then form the exponent by 1 + sin - sin^2 and finally apply exp in-place.\n    This yields exact results (within float64) and is tuned for very large arrays by reducing Python-level iterations.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Preallocate scratch for s^2\n    scratch = np.empty_like(x)\n\n    # s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # s^2 into scratch\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 34.67911462141488, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) exactly via the algebraic identity\n    exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Process in fixed-size blocks to improve cache locality, and use a per-block scratch\n    buffer for sin(x)^2 to avoid extra temporaries and allocations. This preserves\n    exact numerical results (within float64 precision) and minimizes passes over data.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    # Shared scratch buffer to avoid per-block allocations\n    scratch_buffer = np.empty(block, dtype=np.float64)\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        # Compute s = sin(x_block) in-place\n        sin(y, out=y)\n        m = j - i\n        # scratch = s^2 using a shared buffer\n        scratch = scratch_buffer[:m]\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        exp(y, out=y)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 29, "zscore": 32.95384051364674, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a new, fully vectorized in-place approach that avoids recomputing cos\n    and minimizes Python-level loops and allocations. Use the identity cos^2(x) = 1 - sin^2(x)\n    to transform f(x) = exp(sin(x) + cos^2(x)) into exp(1 + sin(x) - sin(x)^2).\n    Compute sin(x) in-place, store sin(x)^2 in a preallocated scratch array, form the exponent\n    as 1 + sin - sin^2, then apply exp in-place. This yields identical results to the naive\n    implementation (within float64 precision) while reducing memory traffic and eliminating\n    Python loops for large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.size\n    if n == 0:\n        return x\n\n    # Preallocate scratch buffer for sin^2(x)\n    scratch = np.empty_like(x)\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # scratch = sin(x)^2\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 29, "zscore": 74.96714796489566, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    - Compute f(x) = exp(sin(x) + cos(x)**2) efficiently and exactly (within float64 precision)\n      by using the algebraic identity sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2.\n      This avoids computing cos(x) entirely and enables a single, in-place pass per block.\n    - Process large arrays in fixed-size cache-friendly blocks to improve locality.\n    - Use per-block scratch buffers for sin^2 to avoid shared temporaries across threads.\n    - Parallelize across blocks with a thread pool for large inputs to utilize multi-core CPUs,\n      but keep a data-size threshold to avoid threading overhead on small inputs.\n    - All operations are in-place on x to minimize allocations and passes.\n\n    This function preserves numerical correctness relative to the naive formulation\n    up to float64 precision.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)  # scratch = s^2\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 75.03375587284259, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) using the algebraic identity:\n    exp(1 + sin(x) - sin(x)**2)\n    Implemented in blockwise fashion with in-place operations to minimize allocations.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute sin(x) in-place for this block\n        np.sin(y, out=y)\n        # Scratch buffer for sin(x)^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 32.17205383356606, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin(x) in-place, then transform in-place with a minimal\n    number of operations and no extra temporaries, finishing with an in-place exp.\n    This preserves exact float64 results compared to the naive implementation.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1.0\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 33.094829096935385, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Fully vectorized with in-place operations and a single scratch\n    buffer to minimize allocations and passes over the data.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Allocate a scratch buffer to store sin(x)^2 without creating temporaries\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # Compute exponent: 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 34.30513718535025, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to reduce allocations,\n    reuse a preallocated scratch buffer for sin(x)^2 to minimize temporaries,\n    and apply exp in-place. This preserves numerical equivalence within float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Preallocate a scratch buffer for sin^2 reused across blocks\n    scratch = np.empty(block, dtype=np.float64)\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # scratch[:m] holds s^2\n        np.multiply(y, y, out=scratch[:m])\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch[:m]\n        # exp in-place\n        np.exp(y, out=y)\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 32.28698736170588, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    which is equivalent to exp(1 + sin(x) - sin(x)**2). This allows an in-place, single-pass\n    transformation after computing sin, minimizing temporaries and passes.\n    \"\"\"\n    import numpy as np\n\n    # In-place sine computation\n    np.sin(x, out=x)\n\n    # Transform to the exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1.0\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 75.09744003249126, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks to improve cache locality,\n    use a per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to utilize multi-core CPUs\n    while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 33.12492248609619, "text": "def build_func(x):\n    \"\"\"\n    Optimized computation of exp(sin(x) + cos(x)**2) using the identity exp(1 + sin(x) - sin(x)**2).\n    In-place sin to avoid extra temporaries, and a single scratch array for sin^2.\n    \"\"\"\n    import numpy as np\n\n    # Quick return for empty input\n    if x.size == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for sin(x)^2\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 32.466801894025046, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exact identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Perform in-place, single-pass transformations:\n    compute sin(x) in-place, then transform to the exponent using the derived form, and finally\n    apply exp in-place. This preserves exact float64 results while reducing allocations and passes.\n    \"\"\"\n    import numpy as np\n\n    if x.size == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # exponent = 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 36.57476974810923, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2),\n    enabling a single in-place pass with minimal temporaries. This avoids computing cos\n    and reduces memory traffic by reusing the input array for all intermediate results.\n    \"\"\"\n    import numpy as np\n\n    np.sin(x, out=x)          # x now holds sin(x)\n    x -= 0.5                    # (sin(x) - 0.5)\n    x *= x                      # (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)            # exp(...) in-place\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 75.07670671894243, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to optimize cache locality, and\n    minimize temporaries by using a per-block scratch buffer for sin(x)^2. For very large\n    inputs, parallelize across blocks using ThreadPoolExecutor to leverage multi-core CPUs\n    while preserving numerical equivalence to the naive formulation within float64 precision.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]  # view into x\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    # Parallelize for very large inputs; otherwise run in a single thread\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 30.927481228190636, "text": "def build_func(x):\n    \"\"\"\n    New approach: compute exp(sin(x) + cos(x)**2) by using the identity\n    exp(1 + sin(x) - sin(x)**2) = exp(sin(x) + cos(x)**2).\n    Implement this in a fully vectorized, single-pass style with two temporaries:\n      - s  = sin(x)\n      - s2 = s * s  (i.e., sin(x)^2)\n    Then compute s = 1 + s - s2 and apply exp in-place.\n    This avoids Python loops and minimizes temporaries while preserving exact float64 results.\n    \"\"\"\n    import numpy as np\n\n    s = np.sin(x)\n    s2 = np.empty_like(s)\n    np.multiply(s, s, out=s2)  # s2 = sin(x)^2\n    s -= s2                    # s = sin(x) - sin(x)^2\n    s += 1.0                   # s = 1 + sin(x) - sin(x)^2\n    np.exp(s, out=s)            # s = exp(1 + sin(x) - sin(x)^2)\n    return s", "operator": "explore"}
{"type": "mutation", "generation": 29, "zscore": 75.08578021716444, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to minimize temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation within\n    float64 precision.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 32.13139241825958, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Perform in-place operations on the input to minimize memory\n    traffic and passes. This computes sin once and directly forms the exponent, then applies\n    exp in-place.\n    \"\"\"\n    import numpy as np\n\n    sin = np.sin\n    exp = np.exp\n\n    # Compute sin(x) in-place\n    sin(x, out=x)\n\n    # exponent = 1 + sin(x) - sin(x)^2 transformed as 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1.0\n    x += 1.25\n\n    # exp in-place\n    exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 33.00448410015283, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Perform a single in-place pass over the data by\n    computing sin(x) in-place, storing sin^2 in a scratch buffer, then forming\n    the exponent as 1 + sin - sin^2 and exponentiating in-place. This minimizes\n    temporaries and passes while preserving numerical correctness within float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Scratch buffer for sin^2\n    scratch = np.empty_like(x)\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # scratch = sin(x)^2\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 30.112766152397842, "text": "def build_func(x):\n    import numpy as np\n\n    # Compute sin(x)\n    s = np.sin(x)\n    # Compute sin^2(x)\n    t = s * s\n    # exponent = 1 + sin(x) - sin^2(x)\n    np.add(s, 1.0, out=s)  # s = 1 + sin(x)\n    s -= t                   # s = 1 + sin(x) - sin^2(x)\n    # exp in-place\n    np.exp(s, out=s)\n    return s", "operator": "explore"}
{"type": "mutation", "generation": 29, "zscore": 74.97557965304614, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # Scratch buffer for s^2\n        scratch = np.empty(m, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 33.06527161227628, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to avoid computing cos.\n    Compute sin into-place on x, reuse a scratch buffer to hold sin^2, then form the exponent in-place\n    and finally apply exp in-place. This minimizes allocations and passes while ensuring exact numerical equivalence\n    to the naive formulation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Scratch buffer to store sin(x)^2\n    scratch = np.empty_like(x)\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # scratch = s^2\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    np.subtract(x, scratch, out=x)\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 32.24194858703087, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos. Compute sin in-place then transform in-place with minimal temporaries.\n    This preserves exact results relative to the mathematical identity and reduces allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.negative(x, out=x)\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 74.88763929191164, "text": "def build_func(x):\n    \"\"\"\n    Improved function using the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    and block-wise multi-threaded processing for large arrays.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    num_blocks = (n + block - 1) // block\n    if num_blocks <= 4:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n        return x\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 34.552941711901376, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality,\n    reuse a per-block scratch buffer to hold sin^2, and perform exponentiation in-place.\n    This minimizes allocations and passes while preserving exact result within float64.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Preallocate scratch for sin^2\n    scratch = np.empty(block, dtype=np.float64)\n\n    sin = np.sin\n    exp = np.exp\n    mul = np.multiply\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        bs = j - i\n        mul(y, y, out=scratch[:bs])\n        y += 1.0\n        y -= scratch[:bs]\n        exp(y, out=y)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 29, "zscore": 75.09130834974951, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks for cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks\n    to utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 32.32780521755307, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform\n    to the exponent with minimal passes and in-place operations, followed by a single exp\n    in-place. This preserves numerical results up to float64 precision and avoids extra allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    x *= -1.0\n    x += 1.25\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 32.27287960263294, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. This in-place approach uses a single\n    sin computation and a few arithmetic operations per element, resulting in zero\n    allocations and a single exp call. It preserves exact results up to float64 precision\n    for the given identity. Processes in-place for performance on large arrays.\n    \"\"\"\n    import numpy as np\n\n    if x.size == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Transform to exponent: 1.25 - (sin(x) - 0.5)^2 in-place\n    x -= 0.5\n    x *= x            # (sin(x) - 0.5)^2\n    x *= -1.0          # - (sin(x) - 0.5)^2\n    x += 1.25           # 1.25 - (sin(x) - 0.5)^2\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 34.56251407690196, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute f(x) = exp(sin(x) + cos(x)**2) using the identity\n    sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2.\n    This approach requires only sin evaluations and one exponentiation, avoiding\n    the computation of cos entirely and minimizing memory allocations by reusing\n    a per-block scratch buffer. Processing in fixed-size blocks keeps memory usage\n    bounded for very large arrays and preserves numerical exactness (within float64).\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Reusable scratch buffer to avoid repeated allocations\n    scratch_buffer = np.empty(block, dtype=np.float64)\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        seg_len = j - i\n        scratch = scratch_buffer[:seg_len]\n        # scratch = sin(x_block)^2\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 29, "zscore": 34.88305298654225, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to avoid computing cos and minimize temporaries. Compute sin(x) in-place, then transform in-place\n    with a minimal number of operations and a single exp call to maximize throughput on large arrays.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Exponent: 1.25 - (sin(x) - 0.5)^2\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n\n    # Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 29, "zscore": 24.594188024567366, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: This approach uses a single in-place sine transformation on x, a single\n    auxiliary scratch array to hold sin(x)^2, then a single in-place exponent. It avoids\n    Python loops and minimizes temporaries by reusing a pre-allocated scratch buffer and\n    performing all operations as vectorized NumPy calls, yielding identical results to the\n    naive implementation for float64 inputs while improving throughput on large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place: x now holds sin(x)\n    np.sin(x, out=x)\n\n    # Scratch buffer to store sin(x)^2 without creating a transient\n    scratch = np.empty_like(x)\n    scratch[:] = x          # copy sin(x) into scratch\n    scratch *= scratch        # scratch = sin(x)^2\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 29, "zscore": 74.88356949974745, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer to avoid temporaries, and parallelize blocks to utilize multi-core CPUs\n    while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    import threading\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Persist per-thread scratch buffers to avoid repeated allocations.\n    if not hasattr(build_func, \"_scratch_by_thread\"):\n        build_func._scratch_by_thread = {}\n    scratch_by_thread = build_func._scratch_by_thread\n\n    def _get_scratch():\n        tid = threading.get_ident()\n        arr = scratch_by_thread.get(tid)\n        if arr is None or arr.size < block:\n            arr = np.empty(block, dtype=np.float64)\n            scratch_by_thread[tid] = arr\n        return arr\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute sin(x_block) in-place\n        np.sin(y, out=y)\n        bs = end - start\n        scratch = _get_scratch()\n        tmp = scratch[:bs]\n        # Compute sin(x)^2 into temp\n        np.multiply(y, y, out=tmp)\n        # exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= tmp\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 25.929109771549456, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    - Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n      to avoid computing cos and minimize temporaries.\n    - Compute sin(x) in-place in x to reuse memory, then copy the result to a separate\n      array to preserve sin(x) for the sin^2 term.\n    - Compute sin^2 in the separate array, then form the exponent as 1 + sin(x) - sin(x)**2\n      in a single in-place pass, and finally apply exp in-place.\n    - This yields a vectorized, cache-friendly computation with minimal Python overhead\n      and no Python-level loops, suitable for very large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place; x now holds sin(x)\n    np.sin(x, out=x)\n\n    # Copy sin(x) to preserve for the sin^2 term\n    sin_vals = x.copy()\n    # sin_vals now contains sin(x); compute sin(x)^2 in-place in sin_vals\n    sin_vals *= sin_vals\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= sin_vals\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 74.83640554621905, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks for cache locality, use a per-block\n    scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to utilize\n    multi-core CPUs while preserving numerical equivalence to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 26.244878679445108, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin(x) in-place, store sin^2 in a single pre-allocated\n    scratch buffer to minimize temporaries, then compute exponent and apply exp in-place.\n    This yields exactly the same result as the naive implementation for float64 inputs\n    while avoiding Python-level loops and excessive allocations.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Pre-allocated scratch buffer for sin^2\n    scratch = np.empty_like(x)\n    scratch[:] = x\n    scratch *= scratch  # scratch = sin(x)^2\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 75.05865292790207, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks for cache locality, use a per-block\n    scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to utilize\n    multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.75211572914042, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute f(x) = exp(sin(x) + cos(x)**2) exactly and efficiently by using the\n    algebraic identity cos(x)**2 = 1 - sin(x)**2, so\n    f(x) = exp(1 + sin(x) - sin(x)**2).\n    To minimize passes and temporaries, perform in-place sine into x, compute sin^2 into a\n    separate scratch array (derived from x), then update x with the exponent and apply exp\n    in-place. This leverages NumPy vectorization to avoid Python loops and keeps allocations\n    limited to a single scratch array proportional to the input size.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch array for sin(x)^2\n    scratch = x * x  # sin(x)^2\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 26.750295130330397, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    - Compute f(x) = exp(sin(x) + cos(x)**2) exactly and efficiently by using the algebraic identity\n      sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2.\n      This avoids computing cos(x) explicitly while preserving numerical correctness within float64.\n    - Perform in-place operations to minimize temporaries:\n      1) Compute sin(x) in-place into x.\n      2) Use a preallocated scratch buffer to hold sin(x)^2 without creating a temporary.\n      3) Transform to the exponent 1 + sin(x) - sin(x)^2 and exponentiate in-place.\n    - All operations are vectorized NumPy operations with no Python loops.\n    \"\"\"\n    import numpy as np\n\n    if x.size == 0:\n        return x\n\n    scratch = np.empty_like(x)\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # scratch = sin(x)^2 without creating a temporary\n    scratch[:] = x\n    scratch *= scratch\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n    # exp in-place\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 30.820754876895418, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) exactly by using the identity cos(x)**2 = 1 - sin(x)**2,\n    i.e., exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2). This allows a fully vectorized,\n    single-pass (in the sense of NumPy operations) approach without Python loops and without\n    intermediate Python-level control flow, leading to significant speedups on large arrays.\n    \"\"\"\n    import numpy as np\n\n    s = np.sin(x)      # sin(x)\n    s2 = s * s         # sin(x)^2\n    s += 1.0           # 1 + sin(x)\n    s -= s2            # 1 + sin(x) - sin(x)^2\n    np.exp(s, out=s)   # exp in-place\n    return s", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 75.01083797129482, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)  # scratch = s^2\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 30, "zscore": 26.285058391795925, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin in-place on the full array, reuse a single\n    scratch buffer sized to n to hold sin^2, then form the exponent and apply exp in-place.\n    This minimizes passes, temporaries, and Python overhead while preserving exact results\n    up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer to store sin^2(x); reuse a single large buffer\n    scratch = np.empty(n, dtype=np.float64)\n    scratch[:] = x\n    scratch *= scratch  # scratch now holds sin(x)^2\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.15479859082392, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin in-place, derive sin^2 via a temporary, then form the exponent\n    and apply exp in-place. This preserves numerical correctness relative to the naive formulation\n    up to float64 precision, while reducing temporaries and passes.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place; x now holds sin(x)\n    np.sin(x, out=x)\n\n    # Temporary: sin(x)^2\n    sin_sq = x * x\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= sin_sq\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 34.392866691842926, "text": "def build_func(x):\n    \"\"\"\n    Vectorized block-wise implementation using the identity\n    exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    Processes in fixed-size blocks to manage memory and improve throughput on large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.size\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=x.dtype)\n\n    for start in range(0, n, block):\n        end = min(n, start + block)\n        y = x[start:end]\n        # Compute sin(x) in-place for the block\n        np.sin(y, out=y)\n        m = end - start\n        # scratch = sin(x)^2 for the block\n        np.multiply(y, y, out=scratch[:m])\n        # exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= scratch[:m]\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 30, "zscore": 71.82910264213523, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    - Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to avoid computing cos.\n    - Process in fixed-size blocks to improve cache locality.\n    - For very large inputs, parallelize across blocks with a thread pool to leverage multiple cores.\n    - Use a per-block scratch buffer to store sin(x)^2 and perform all operations in-place on x to minimize allocations.\n    - This preserves numerical correctness relative to the naive formulation within float64 precision.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        size = end - start\n        # Scratch buffer for s^2\n        scratch = np.empty(size, dtype=x.dtype)\n        scratch[:] = y\n        scratch *= scratch  # scratch = s^2\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 75.11587998297772, "text": "def build_func(x):\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute sin(x) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for sin(x)^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # Exponent: 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        from concurrent.futures import ThreadPoolExecutor\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 30, "zscore": 26.285885071650448, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute f(x) = exp(sin(x) + cos(x)**2) exactly and efficiently by using\n    the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    This avoids computing cos(x) entirely and minimizes temporaries by:\n    - performing sin(x) in-place to reuse the input array\n    - using a single pre-allocated scratch buffer to hold sin(x)**2\n    - performing all operations in a few vectorized passes without Python loops\n    Returns the transformed x (modified in place) matching the naive implementation\n    up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for s^2\n    scratch = np.empty_like(x)\n    scratch[:] = x\n    scratch *= scratch  # scratch = sin(x)^2\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.211082645276164, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute f(x) = exp(sin(x) + cos(x)**2) efficiently by using the exact identity\n    sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2. This avoids computing cos(x) entirely.\n    Perform in-place sine to minimize temporaries, and reuse a per-call scratch buffer for\n    sin(x)^2 to avoid extra allocations. This yields identical results to the naive formulation\n    up to float64 precision while reducing passes over large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer to hold sin(x)^2\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.75384162327137, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process the entire 1-D float64 array in vectorized form with a\n    single preallocated scratch buffer for sin^2 to minimize allocations and passes.\n    This preserves exact float64 results relative to the naive formulation within precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    scratch = np.empty_like(x)\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # scratch = sin(x)^2\n    np.multiply(x, x, out=scratch)\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 75.06637027155911, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2) to avoid\n    computing cos, and perform block-wise, in-place vectorized computation with a per-thread\n    scratch buffer to minimize allocations and contention. For large arrays, parallelize across\n    blocks using a thread pool. All operations are in-place on the input array to preserve memory.\n\n    This approach preserves float64 numerical results relative to the naive formulation within\n    float64 precision and aims to be faster on large inputs by reducing Python overhead and\n    maximizing NumPy/C-optimized kernel usage.\n    \"\"\"\n    import numpy as np\n    import threading\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Thread-local scratch buffer to avoid cross-thread data races while reusing memory\n    _thread_scratch = threading.local()\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        size = end - start\n\n        # Obtain a per-thread scratch buffer large enough for this block\n        buf = getattr(_thread_scratch, \"buf\", None)\n        if buf is None or buf.shape[0] < size:\n            _thread_scratch.buf = np.empty(max(block, size), dtype=x.dtype)\n            buf = _thread_scratch.buf\n\n        # s^2 into scratch to avoid extra temporaries\n        np.multiply(y, y, out=buf[:size])\n\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= buf[:size]\n\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4 * block:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.46363666200647, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin(x) in-place, then compute sin^2 into a temporary\n    array, apply the exponent transformation, and finally exponentiate in-place.\n    This preserves exact mathematical equivalence (up to float64 precision) with minimal\n    Python overhead and no Python loops.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # sin^2(x) stored in a temporary array to avoid extra temporaries on the main array\n    sin2 = x * x\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= sin2\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 75.03828478398492, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    All operations are in-place on x to minimize allocations and passes.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)  # scratch = s^2\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.20327177738284, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin(x) in-place, then compute sin(x)^2 into a scratch buffer,\n    then form 1 + sin(x) - sin(x)^2 in-place, and finally exponentiate in-place.\n    This yields identical results to the naive formulation for float64 inputs while avoiding\n    temporaries beyond a single per-call scratch array and minimizing passes over data.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for sin^2\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin^2(x)\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 26.242187891517258, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Introduce a memory-efficient, cache-friendly two-pass approach that avoids per-block\n    allocations and minimizes Python overhead by reusing a single preallocated scratch buffer to hold\n    sin(x)^2. We compute sin(x) in-place into x, copy to a scratch buffer, square it to obtain sin^2(x),\n    then compute the exponent argument as 1 + sin(x) - sin^2(x) and apply exp in-place.\n    This preserves exact mathematical equivalence using the identity sin(x) + cos(x)^2 = 1 + sin(x) - sin(x)^2,\n    but reduces allocations and Python-side control flow for very large arrays (length ~1e7).\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Preallocate scratch buffer once and reuse\n    scratch = np.empty_like(x)\n\n    # 1) Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # 2) Copy sin(x) into scratch and square to get sin(x)^2\n    scratch[:] = x\n    scratch *= scratch\n\n    # 3) Compute 1 + sin(x) - sin(x)^2 in-place on x\n    x += 1.0\n    x -= scratch\n\n    # 4) Exponentiate in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 30, "zscore": 75.03154971050279, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    - Compute exp(sin(x) + cos(x)**2) exactly by using the identity cos(x)**2 = 1 - sin(x)**2, so\n      sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2. This avoids computing cos entirely and is exact in float64.\n    - Process the 1-D input in fixed-size blocks to improve cache locality. For each block:\n      - compute sin in-place on the block,\n      - allocate a per-block scratch buffer to store sin^2 (to avoid cross-block races and temporaries),\n      - exponent = 1 + sin - sin^2, performed in-place, followed by in-place exp.\n    - Parallelize across blocks with a thread pool to utilize multiple cores on large arrays while preserving numerical equivalence.\n    - All operations are in-place on x to minimize allocations and passes.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # Scratch buffer for s^2 (per-block, to avoid contention)\n        scratch = np.empty(m, dtype=np.float64)\n        np.multiply(y, y, out=scratch)  # scratch = sin(x_block)^2\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 34.021544015619654, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks for cache locality, compute sin in-place,\n    use a per-block scratch buffer for sin^2 to avoid temporaries, and apply exp in-place.\n    This preserves exact results up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch_buf = np.empty(block, dtype=np.float64)\n\n    for start in range(0, n, block):\n        end = min(start + block, n)\n        y = x[start:end]\n\n        # s = sin(x_block) in-place\n        np.sin(y, out=y)\n\n        # scratch = s^2\n        s2 = scratch_buf[:end - start]\n        np.multiply(y, y, out=s2)\n\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= s2\n\n        # exp in-place\n        np.exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.26166974526908, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin(x) in-place in x, store sin(x)^2 in a separate scratch buffer,\n    then form the exponent and apply exp in-place. This minimizes temporaries and passes while preserving\n    numerical correctness up to float64 precision.\n    \"\"\"\n    import numpy as np\n\n    # Pre-allocate a scratch buffer for sin(x)^2\n    scratch = np.empty_like(x)\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Compute sin(x)^2 into scratch\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 26.160873775662676, "text": "def build_func(x):\n    \"\"\"\n    Compute f(x) = exp(sin(x) + cos(x)**2) efficiently and exactly by using\n    the algebraic identity: sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2.\n    This avoids computing cos(x) and minimizes temporaries.\n    Operations are performed in-place to minimize allocations.\n    \"\"\"\n    import numpy as np\n\n    # Compute sin(x) in-place; x now holds sin(x)\n    np.sin(x, out=x)\n\n    # Scratch buffer to hold sin(x)^2 without extra temporaries\n    scratch = np.empty_like(x)\n    scratch[:] = x\n    scratch *= scratch  # scratch = sin(x)^2\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": NaN, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, reuse a\n    per-block scratch buffer for sin(x)^2 to minimize temporaries, and optionally parallelize\n    blocks to utilize multi-core CPUs. All operations are in-place on x to minimize allocations\n    and passes, ensuring exact results within float64 precision relative to the naive formulation\n    while handling very large arrays efficiently.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    # Scratch buffer reused across blocks to avoid per-block allocations\n    scratch_buffer = np.empty(block, dtype=np.float64)\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute sin(x_block) in-place\n        np.sin(y, out=y)\n        m = end - start\n        # scratch = sin(x_block)^2\n        scratch = scratch_buffer[:m]\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 30, "zscore": 34.85408109113537, "text": "def build_func(x):\n    \"\"\"\n    Compute exp(sin(x) + cos(x)**2) efficiently by exploiting the identity\n    sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2, and performing in-place, cache-friendly\n    operations in fixed-size blocks to handle large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    scratch = np.empty(block, dtype=np.float64)\n\n    i = 0\n    while i < n:\n        j = i + block\n        if j > n:\n            j = n\n\n        y = x[i:j]\n        # Compute sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for sin(x_block)^2\n        sp = scratch[:(j - i)]\n        np.multiply(y, y, out=sp)\n        # exponent = 1 + sin(x) - sin(x)^2\n        y += 1.0\n        y -= sp\n        # exp in-place\n        np.exp(y, out=y)\n\n        i = j\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.31286613440592, "text": "def build_func(x):\n    \"\"\"\n    Efficiently compute exp(sin(x) + cos(x)**2) using the identity\n    exp(1 + sin(x) - sin(x)**2) and in-place NumPy operations.\n    Uses a scratch array to hold sin(x)^2, minimizing temporaries and passes.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer to store sin(x)^2\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 30, "zscore": 26.155532372717566, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin in-place, allocate a single scratch buffer to hold sin(x)^2\n    (reusing the buffer to minimize allocations), then form the exponent and apply exp in-place.\n    This yields identical results to the naive formulation while minimizing Python-level overhead\n    and maximizing NumPy vectorization for large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place: x now holds s = sin(x)\n    np.sin(x, out=x)\n\n    # Scratch buffer for s^2, allocated once to minimize temporaries\n    scratch = np.empty_like(x)\n    scratch[:] = x       # scratch = s\n    scratch *= scratch     # scratch = s^2\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 74.8857231078431, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) exactly by using the algebraic identity\n    sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2, avoiding cos altogether.\n    Process the input in fixed-size blocks to improve cache locality and limit per-block\n    temporary allocations. Use an in-place, block-local scratch buffer to hold sin(x)^2\n    and apply the exponential in-place. Optionally parallelize blocks to utilize multiple cores\n    for large arrays, while avoiding overhead on small inputs.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2 (block-local)\n        L = end - start\n        scratch = np.empty(L, dtype=np.float64)\n        # scratch = s^2\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 30, "zscore": 75.13285383478278, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) exactly by using the algebraic identity\n    sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2. This avoids computing cos entirely\n    and allows a single, in-place block-processed pass per chunk of data.\n    \n    To scale to very large arrays (e.g., length ~10,000,000), process in fixed-size\n    blocks to improve cache locality, allocate a per-block scratch buffer for sin^2\n    to avoid temporaries that span the entire array, and optionally parallelize\n    across blocks for multi-core CPUs on large inputs. All operations are in-place\n    on x to minimize allocations and passes, preserving numerical equivalence to the\n    naive formulation up to float64 precision.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # s = sin(x_block) computed in-place into y\n        np.sin(y, out=y)\n        # scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 33.15693848911676, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin in-place into x, store sin^2 in a scratch buffer, then form\n    the exponent as 1 + sin - sin^2 in-place and finally apply exp in-place. This minimizes temporaries\n    (one scratch buffer) and passes over data, leveraging NumPy vectorization for large arrays while\n    preserving exact float64 results relative to the naive formulation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    scratch = np.empty_like(x)\n\n    # Compute s = sin(x) in-place\n    np.sin(x, out=x)\n\n    # scratch = s^2\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + s - s^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 35.27274807387451, "text": "def _mem_block_worker(start, end, shm_name, shape, dtype_name):\n    \"\"\"\n    Worker for multiprocessing: operates on a disjoint slice [start:end) of a shared array.\n    \"\"\"\n    import numpy as np\n    from multiprocessing import shared_memory\n\n    # Attach to existing shared memory\n    existing_shm = shared_memory.SharedMemory(name=shm_name)\n    arr = np.ndarray(shape, dtype=np.dtype(dtype_name), buffer=existing_shm.buf)\n\n    # Compute in-place on the assigned slice\n    y = arr[start:end]\n    np.sin(y, out=y)\n\n    # Scratch buffer for sin(x)^2\n    scratch = np.empty(end - start, dtype=np.float64)\n    np.multiply(y, y, out=scratch)\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    y += 1.0\n    y -= scratch\n    np.exp(y, out=y)\n\n    existing_shm.close()\n\ndef build_func(x):\n    \"\"\"\n    Reasoning: Introduce genuine parallelism via multiprocessing with a shared memory buffer.\n    Each process handles a disjoint block of the input array, performing sin, a scratch\n    computation for sin^2, the in-place linear transform, and exp. This avoids Python-level\n    per-element loops and eliminates extra data copies across threads, leveraging multi-core\n    CPUs for large arrays (~10,000,000 elements). The approach is fundamentally different\n    from the single-process, block-wise threadpool patterns seen in prior solutions.\n    \"\"\"\n    import numpy as np\n    import os\n    from multiprocessing import Process, shared_memory\n\n    # Normalize input to 1D float64 for safety\n    if x.ndim != 1 or x.dtype != np.float64:\n        x = np.asarray(x, dtype=np.float64)\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Single-thread fast path for small arrays to avoid multiprocessing overhead\n    SMALL_THRESHOLD = 2_000_000\n    if n <= SMALL_THRESHOLD:\n        y = x\n        np.sin(y, out=y)\n        scratch = np.empty(n, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        y += 1.0\n        y -= scratch\n        np.exp(y, out=y)\n        return x\n\n    # Create a shared memory block and copy input data into it\n    shm = shared_memory.SharedMemory(create=True, size=x.nbytes)\n    shm_arr = np.ndarray(x.shape, dtype=np.float64, buffer=shm.buf)\n    shm_arr[:] = x[:]\n\n    # Launch workers on disjoint blocks\n    cpu_count = max(1, os.cpu_count() or 1)\n    workers = min(cpu_count, 8)  # cap to reasonable number to avoid overhead\n    block_size = max(1, (n + workers - 1) // workers)\n\n    processes = []\n    shape = (n,)\n    dtype_name = str(x.dtype)  # e.g., 'float64'\n    for start in range(0, n, block_size):\n        end = min(start + block_size, n)\n        p = Process(target=_mem_block_worker, args=(start, end, shm.name, shape, dtype_name))\n        p.start()\n        processes.append(p)\n\n    for p in processes:\n        p.join()\n\n    # Copy back the results from shared memory to the original array\n    x[:] = shm_arr[:]\n\n    # Clean up shared memory\n    shm.close()\n    shm.unlink()\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 30, "zscore": 32.93989381818754, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin in-place, use a scratch buffer for sin^2,\n    and apply exp in-place. This minimizes passes and allocations while preserving\n    numerical correctness relative to the naive formulation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for sin(x)^2\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # Exponent: 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # Exponential in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 31.683713473480505, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) exactly by using the algebraic identity\n    cos^2(x) = 1 - sin^2(x), so f(x) = exp(1 + sin(x) - sin(x)^2).\n    This allows a single in-place pass over the data with a small scratch buffer to hold sin^2.\n    Steps:\n      - compute sin(x) in-place into x\n      - compute sin(x)^2 into a scratch buffer\n      - exponent = 1 + sin(x) - sin(x)^2 (in-place in x)\n      - apply exp in-place\n    This minimizes temporaries and passes while staying fully NumPy-based.\n    \"\"\"\n    import numpy as np\n\n    scratch = np.empty_like(x)\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n    # scratch = sin(x)^2\n    np.multiply(x, x, out=scratch)\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 32.902657302925014, "text": "def build_func(x):\n    \"\"\"\n    Reasoning:\n    - Compute f(x) = exp(sin(x) + cos(x)**2) exactly using the identity cos(x)**2 = 1 - sin(x)**2, i.e.\n      exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2).\n    - Perform all operations with a minimal number of passes by:\n      1) computing sin(x) in-place in x,\n      2) computing sin(x)**2 into a separate scratch buffer (no extra temporaries on the path),\n      3) forming the exponent in-place as 1 + sin(x) - sin(x)**2,\n      4) applying exp in-place.\n    - This approach uses a single large scratch buffer and vectorized NumPy operations for speed on large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for sin^2(x)\n    scratch = np.empty(n, dtype=np.float64)\n\n    # scratch = sin(x)^2\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin(x)^2\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 30.956185144777283, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute exp(sin(x) + cos(x)**2) efficiently and exactly by using the algebraic\n    identity sin(x) + cos(x)**2 = 1 + sin(x) - sin(x)**2, while processing in fixed-size\n    blocks to improve cache locality and minimize temporaries via a per-block scratch buffer\n    for sin^2. All operations are in-place on x to avoid extra allocations and passes.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        scratch[:] = y\n        scratch *= scratch\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        process_block(i, j)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 75.03262470783241, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to optimize cache locality,\n    use a per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks\n    to utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 30, "zscore": 30.242439631564668, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Compute sin(x) in-place on x, then compute sin^2(x) into a scratch\n    buffer and form the exponent 1 + sin(x) - sin^2(x) in-place, followed by an in-place exp.\n    This minimizes temporaries and passes while preserving exact float64 results relative to the naive formulation.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    # Compute sin(x) in-place\n    np.sin(x, out=x)\n\n    # Scratch buffer for sin^2(x)\n    scratch = np.empty_like(x)\n    np.multiply(x, x, out=scratch)\n\n    # exponent = 1 + sin(x) - sin^2(x)\n    x += 1.0\n    x -= scratch\n\n    # exp in-place\n    np.exp(x, out=x)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 30, "zscore": 47.62593279917895, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Compute f(x) = exp(sin(x) + cos(x)**2) exactly as exp(1 + sin(x) - sin(x)**2)\n    without extra temporaries by:\n    - performing sin(x) once in-place across the full array to maximize locality\n    - then, in fixed-size blocks, computing sin(x)^2 into a per-block scratch buffer, adding 1,\n      subtracting sin^2, and finally applying exp in-place.\n    - using a thread pool for very large inputs to leverage multi-core CPUs, while keeping\n      memory usage bounded per-block to avoid large global temporaries.\n    This preserves float64 precision relative to the naive formulation.\n    \"\"\"\n\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    BLOCK = 1 << 20  # ~1,048,576\n    if BLOCK > n:\n        BLOCK = n\n\n    # Compute sin(x) in-place for the entire array to avoid repeated ufunc calls\n    np.sin(x, out=x)\n\n    def process_block(start, end):\n        y = x[start:end]\n        m = end - start\n        # Scratch buffer per block to store sin^2(x)\n        scratch = np.empty(m, dtype=np.float64)\n        np.multiply(y, y, out=scratch)  # scratch = sin(x)^2\n        y += 1.0\n        y -= scratch\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, BLOCK):\n                j = min(i + BLOCK, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, BLOCK):\n            j = min(i + BLOCK, n)\n            process_block(i, j)\n\n    return x", "operator": "mutate"}
