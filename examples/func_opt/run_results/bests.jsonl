{"type": "seed", "generation": 0, "zscore": 0, "text": "def build_func(x):\n    return np.exp(np.sin(x) + np.square(np.cos(x)))", "operator": "seed"}
{"type": "mutation", "generation": 1, "zscore": 27.44898074397811, "text": "def build_func(x):\n    \"\"\"Reasoning: Use the identity cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2),\n    enabling a single sine evaluation per element and reducing temporaries, improving performance on large arrays while preserving float64 semantics.\"\"\"\n    s = np.sin(x)\n    return np.exp(1.0 + s - s * s)", "operator": "mutate"}
{"type": "mutation", "generation": 2, "zscore": 33.197853642052955, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place computation to minimize allocations:\n    - Compute sin(x) in place to reuse the original input array memory and avoid a separate sin result array.\n    - Compute sin^2 into a temporary array t, then form the exact expression 1 + sin(x) - sin(x)^2 and apply exp in place.\n    - This implements exp(sin(x) + cos(x)**2) via the identity cos^2 = 1 - sin^2, while using only a single transcendental function (sin).\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 3, "zscore": 33.82532437575736, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: In-place sin into input buffer to minimize allocations; compute sin^2 into a temporary array t,\n    then form 1 + sin - sin^2 and apply exp in-place.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x\n    x -= t\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 4, "zscore": 33.96767049521902, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use cos^2(x) = 1 - sin^2(x) to rewrite exp(sin(x) + cos(x)**2) as exp(1.0 + sin(x) - sin(x)**2).\n    Compute sin(x) in-place to reuse memory, then compute sin^2 into a scratch array t via t = x * x,\n    combine and apply exp in-place to minimize allocations and passes.\n    \"\"\"\n    np.sin(x, out=x)\n    t = x * x  # sin(x)^2\n    x -= t      # sin(x) - sin(x)^2\n    x += 1.0\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 5, "zscore": 36.65674368807859, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Rewrite exp(sin(x) + cos(x)**2) as exp(1 + sin(x) - sin(x)**2) and then as exp(1.25 - (sin(x) - 0.5)**2),\n    enabling a single sin evaluation and in-place arithmetic to minimize temporaries.\n    \"\"\"\n    np.sin(x, out=x)\n    np.subtract(x, 0.5, out=x)  # x := sin(x) - 0.5\n    np.multiply(x, x, out=x)     # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 6, "zscore": 36.89476356024051, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    cos^2(x) = 1 - sin^2(x) and completing the square to get\n    exp(1.25 - (sin(x) - 0.5)^2). This allows a single sin computation in-place\n    and a few in-place operations to minimize temporaries and passes.\n    \"\"\"\n    np.sin(x, out=x)               # x := sin(x)\n    np.subtract(x, 0.5, out=x)     # x := sin(x) - 0.5\n    np.square(x, out=x)             # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)     # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)                # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 7, "zscore": 36.8539808291207, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin(x) in-place, then perform in-place arithmetic to form (sin(x) - 0.5)^2,\n    subtract from 1.25, then exponentiate in-place. This minimizes temporaries and passes\n    over the data while preserving numerical accuracy within float64.\n    \"\"\"\n    np.sin(x, out=x)        # x := sin(x)\n    x -= 0.5                  # x := sin(x) - 0.5\n    x *= x                    # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x)  # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)          # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 8, "zscore": 36.90883343137, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use exp(1.25 - (sin(x) - 0.5)^2) which is algebraically equal to exp(sin(x) + cos(x)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place and subtract from 1.25, then exp in-place.\n    This minimizes temporaries and keeps a single array in use.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 9, "zscore": 36.917017758543246, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Evaluate exp(sin(x) + cos(x)**2) using the exact identity\n    exp(1.25 - (sin(x) - 0.5)**2). This allows a single sin computation in-place\n    and a small number of in-place operations to minimize temporaries and passes\n    over large arrays.\n    \"\"\"\n    np.sin(x, out=x)          # x := sin(x)\n    x -= 0.5                    # x := sin(x) - 0.5\n    x *= x                      # x := (sin(x) - 0.5)^2\n    np.subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    np.exp(x, out=x)             # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 10, "zscore": 36.937122015325485, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over the data for large arrays.\n    \"\"\"\n    np.sin(x, out=x)\n    x -= 0.5\n    x *= x\n    np.subtract(1.25, x, out=x)\n    np.exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 11, "zscore": 36.91374446341187, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to keep a single sin evaluation\n    and perform in-place arithmetic to minimize temporaries and passes over large arrays. Micro-optimize by binding\n    numpy functions to local names to reduce Python call overhead.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)          # x := sin(x)\n    x -= 0.5                 # x := sin(x) - 0.5\n    x *= x                   # x := (sin(x) - 0.5)^2\n    subtract(1.25, x, out=x) # x := 1.25 - (sin(x) - 0.5)^2\n    exp(x, out=x)            # x := exp(...)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 12, "zscore": 36.93581559864981, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This minimizes temporaries and passes over large arrays by keeping a single array in-use.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 13, "zscore": 36.877335106252794, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then form (sin(x) - 0.5)^2 in-place, convert to 1.25 - that value via in-place subtraction,\n    and finally exponentiate in-place to keep a single array in-use and minimize temporaries.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 14, "zscore": 36.92766915942003, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to minimize temporaries.\n    Compute sin in-place, then compute (sin(x) - 0.5)^2 in-place, subtract from 1.25, and exponentiate in-place.\n    This keeps a single array in-use and reduces Python overhead by binding ufuncs locally.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 15, "zscore": 36.90831803843376, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    This keeps a single array in-use and minimizes passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 16, "zscore": 36.99895800853203, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 17, "zscore": 36.94289022887621, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 18, "zscore": 36.889455847275975, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2).\n    Compute sin in-place, then transform to 1.25 - (sin(x) - 0.5)^2 using in-place arithmetic\n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 19, "zscore": 36.964633232205586, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use algebraic simplification to reduce to a single sin evaluation and a\n    single exponential. Use sin(x) + cos(x)**2 = 1.25 - (sin(x) - 0.5)**2.\n    Compute sin in-place, then perform (sin - 0.5)^2 and then exp(1.25 - ...) \n    to minimize temporaries and passes over large arrays.\n    \"\"\"\n    import numpy as np\n    sin = np.sin\n    subtract = np.subtract\n    exp = np.exp\n\n    sin(x, out=x)\n    x -= 0.5\n    x *= x\n    subtract(1.25, x, out=x)\n    exp(x, out=x)\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 20, "zscore": 41.17947436628575, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: This solution processes the input in fixed-size blocks to minimize peak memory usage and\n    demonstrates a different paradigm: streaming, chunk-wise in-place computation. It uses the identity\n    exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) and computes it block-by-block, avoiding\n    a separate cos computation and keeping all operations in-place on the original array.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        np.sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        np.exp(y, out=y)\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 21, "zscore": 41.31632248284528, "text": "def build_func(x):\n    \"\"\"\n    Efficient block-wise in-place evaluation of exp(sin(x) + cos(x)**2)\n    using the identity to avoid cos computations and minimize temporaries.\n    Processes the input in fixed-size blocks to reduce peak memory and improve locality.\n    \"\"\"\n    import numpy as np\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 22, "zscore": 41.24402399709151, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    to compute in-place with a single sin evaluation per element and minimal temporaries.\n    Do block-wise in-place processing to improve cache locality for large arrays.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = i + block\n        if j > n:\n            j = n\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 23, "zscore": 41.33390387021484, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2) to fuse\n    into in-place computation with minimal temporaries. This implementation processes the input\n    in fixed-size blocks to keep memory locality and avoid large temporary allocations, while\n    performing as few passes as possible. It computes sin(x) in-place, then transforms to the\n    exponent value and applies exp in-place.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "mutate"}
{"type": "mutation", "generation": 24, "zscore": 41.395590118365774, "text": "def build_func(x):\n    \"\"\"\n    Efficient in-place evaluation of exp(sin(x) + cos(x)**2)\n    using the identity exp(sin(x) + cos(x)**2) = exp(1.25 - (sin(x) - 0.5)**2)\n    with block-wise processing to optimize cache locality and in-place updates.\n    \"\"\"\n    import numpy as np\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    sin = np.sin\n    exp = np.exp\n\n    for i in range(0, n, block):\n        j = min(i + block, n)\n        y = x[i:j]\n        sin(y, out=y)\n        y -= 0.5\n        y *= y\n        y *= -1\n        y += 1.25\n        exp(y, out=y)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 25, "zscore": 75.01638943180019, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Break the input into blocks and process them in parallel using a ThreadPoolExecutor.\n    Each block computes s = sin(x_block) in-place, then uses a per-block scratch buffer to compute\n    1 + s - s^2, and finally applies exp in-place. This yields exp(sin(x) + cos(x)**2) exactly\n    because cos^2(x) = 1 - sin^2(x), so the exponent becomes 1 + sin(x) - sin(x)**2.\n    The per-block scratch avoids extra temporaries and the parallel dispatch leverages multi-core CPUs\n    for large arrays without changing the numerical result.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Allocate per-block scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        # scratch = s^2\n        np.multiply(y, y, out=scratch)\n        # y = 1 + s\n        y += 1.0\n        # y = 1 + s - s^2\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "explore"}
{"type": "mutation", "generation": 26, "zscore": 75.16167194658749, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos. Process in fixed-size blocks to improve cache locality, use a\n    per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to\n    utilize multi-core CPUs while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "cross"}
{"type": "mutation", "generation": 27, "zscore": 75.17402963338886, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the exact algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks for cache locality.\n    Compute sin in-place, then transform to the exponent with a per-block scratch buffer for sin^2,\n    and finally apply exp in-place. For very large arrays, parallelize across blocks to leverage\n    multi-core CPUs while preserving numerical correctness.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    # Parallelize for large inputs; otherwise run in a single thread\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 28, "zscore": 75.04665488430025, "text": "def build_func(x):\n    \"\"\"\n    In-place blockwise computation using identity exp(1 + sin(x) - sin(x)**2)\n    to avoid cos. Processes in fixed-size blocks and uses per-block scratch memory.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    if n > 4_000_000:\n        with ThreadPoolExecutor() as executor:\n            futures = []\n            for i in range(0, n, block):\n                j = min(i + block, n)\n                futures.append(executor.submit(process_block, i, j))\n            for f in futures:\n                f.result()\n    else:\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            process_block(i, j)\n\n    return x", "operator": "insights"}
{"type": "mutation", "generation": 29, "zscore": 75.09744003249126, "text": "def build_func(x):\n    \"\"\"\n    Reasoning: Use the algebraic identity exp(sin(x) + cos(x)**2) = exp(1 + sin(x) - sin(x)**2)\n    to avoid computing cos and minimize temporaries. Process in fixed-size blocks to improve cache locality,\n    use a per-block scratch buffer for sin(x)^2 to avoid temporaries, and parallelize blocks to utilize multi-core CPUs\n    while keeping the result identical to the naive formulation.\n    \"\"\"\n    import numpy as np\n    from concurrent.futures import ThreadPoolExecutor\n\n    n = x.shape[0]\n    if n == 0:\n        return x\n\n    block = 1 << 20  # ~1,048,576\n    if block > n:\n        block = n\n\n    def process_block(start, end):\n        y = x[start:end]\n        # Compute s = sin(x_block) in-place\n        np.sin(y, out=y)\n        # Scratch buffer for s^2\n        scratch = np.empty(end - start, dtype=np.float64)\n        np.multiply(y, y, out=scratch)\n        # exponent = 1 + s - s^2\n        y += 1.0\n        y -= scratch\n        # exp in-place\n        np.exp(y, out=y)\n\n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for i in range(0, n, block):\n            j = min(i + block, n)\n            futures.append(executor.submit(process_block, i, j))\n        for f in futures:\n            f.result()\n\n    return x", "operator": "mutate"}
