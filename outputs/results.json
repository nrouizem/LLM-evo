[["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build a compact additive feature proxying metabolic/exertional load using allowed columns.\n    - Include exactly one context-aware interaction: Age-centered normalization by sex, interacted with Heart_Rate (AgeInteract).\n    - Add a small curvature term on the age-centered component (AgeSquared) to capture nonlinearity without adding new interactions.\n    - Use per-column mean imputation for stability on very large data (750k rows) and vectorized operations for speed.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), BMI_log = log1p(BMI)\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by sex, interacted with Heart_Rate (AgeInteract)\n      7) Age-centered nonlinearity: AgeSquared\n    - Final feature is a single, scalable scalar feature per row.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, then interaction with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build an additive, robust feature proxying metabolic/exertional load using the allowed columns.\n    - Include exactly one context-aware interaction: Age-centered normalization by Sex, interacted with Heart_Rate (AgeInteract), plus a mild curvature (AgeSquared) on the contextualized term.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), with height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by sex, interacted with Heart_Rate: AgeInteract\n      7) Age-centered nonlinearity: AgeSquared\n    - Use per-column mean imputation for stability on very large datasets and vectorized operations for speed.\n    - Coefficients tuned to balance the contributions, emphasizing exertion and the contextual interaction while keeping size influence reasonable.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, then interaction with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build a compact, additive feature backbone using only allowed columns.\n    - Use exactly one context-aware interaction: Age-centered normalization by Sex, then interacted with Heart_Rate (AgeInteract), plus a mild AgeSquared curvature.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by Sex, interacted with Heart_Rate: AgeInteract\n      7) Age-centered nonlinearity: AgeSquared\n    - Use per-column mean imputation for stability on large data (750k rows) and vectorized operations.\n    - Coefficients tuned to modestly emphasize exertion and the contextual interaction while keeping size influence reasonable.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, interacted with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Use a simple additive feature backbone that proxies metabolic/exertional load using the allowed columns.\n    - Exactly one context-aware interaction: Age-centered normalization by Sex, interacted with Heart_Rate (AgeInteract).\n    - Include a mild nonlinear term on the age-centered component (AgeSquared) to capture curvature without adding numerous cross-terms.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), with height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by sex, interacted with Heart_Rate: AgeInteract\n      7) Age-centered nonlinearity: AgeSquared\n    - Use per-column mean imputation for stability; vectorized operations for speed on very large data (~750k rows).\n    - Coefficients tuned to modestly emphasize exertion and the contextual interaction while keeping Size influence reasonable.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, then interaction with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build a compact additive feature backbone that proxies metabolic/exertional load while avoiding target leakage.\n    - Use exactly one contextual interaction: Age-centered normalization by Sex, interacted with Heart_Rate (AgeInteract), plus a mild AgeSquared term for nonlinearity.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), with height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by Sex, then interaction with Heart_Rate: AgeInteract\n      7) Age-centered nonlinearity: AgeSquared\n    - Preprocessing: per-column mean imputation for stability, vectorized operations, robust handling for large data (750k rows).\n    - Coefficients tuned to emphasize exertion and the contextual interaction while keeping size influence reasonable.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, interacted with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Favor an additive, robust feature backbone with exactly one group-normalized interaction: AgeCentered by Sex, interacted with Heart_Rate (AgeInteract), plus a mild AgeSquared term.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), where height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by sex, then interaction with Heart_Rate: AgeInteract\n      7) Age-centered nonlinearity: AgeSquared\n    - Use per-column mean imputation for stability on very large datasets and vectorized operations for speed.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, then interaction with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build a compact additive feature backbone using the allowed columns to proxy metabolic/exertional load.\n    - Use a robust size proxy (log(weight) * (log(height) + 1)).\n    - Include an Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1).\n    - Include a BMI-like proxy: BMI = weight / (height_m^2), with height_m = Height / 100, plus its log.\n    - Include a Thermal stress proxy: (Body_Temp - 37)^2.\n    - Demographic modulation: Age * Sex (group-aware context).\n    - One context-aware interaction: Age-centered normalization by Sex, interacted with Heart_Rate (AgeInteract) plus a mild AgeSquared curvature (AgeSquared).\n    - All components are additive, with per-column mean imputation for stability on large datasets.\n    - Coefficients are balanced to emphasize exertion and contextual interaction while keeping size influence reasonable.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n\n    import numpy as np\n    import pandas as pd\n\n    # Cast to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, then interaction with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build a compact, additive feature backbone using only allowed columns, focusing on robust proxies of metabolic/exertional load.\n    - Components (additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), with height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by sex, then interaction with Heart_Rate (AgeInteract)\n      7) Age-centered nonlinearity: AgeSquared\n    - Use per-column mean imputation for stability on very large datasets and vectorized operations for speed.\n    - One contextual interaction: Age-centered normalization by Sex interacted with Heart_Rate (AgeInteract). Include AgeSquared for mild nonlinearity.\n    - Coefficients tuned to balance contributions (size, exertion, and contextual interaction) while preventing any single proxy from dominating.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, interacted with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build an additive, robust feature backbone using the available columns.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), with height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by sex, interacted with Heart_Rate: AgeInteract\n      7) Age-centered nonlinearity: AgeSquared\n    - Use per-column mean imputation for stability on very large datasets and vectorized operations.\n    - Exactly one contextual interaction: Age-centered normalization by sex, interacted with Heart_Rate (AgeInteract).\n    - Coefficients tuned to balance contributions, emphasizing exertion and the contextual interaction while keeping size influence reasonable.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    d = df['Duration'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    hr_mean = hr.mean()\n    d_mean = d.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    hr = hr.fillna(hr_mean)\n    d = d.fillna(d_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, then interaction with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].transform('mean')\n    std_by_sex = df.groupby('Sex')['Age'].transform('std').fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - mean_by_sex) / (std_by_sex + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774], ["def build_feature(df):\n    \"\"\"\n    Reasoning:\n    - Build a compact additive feature backbone that proxies metabolic/exertional load using only the allowed columns.\n    - Use robust, per-column mean imputation for stability on large datasets (~750k rows) and vectorized operations for speed.\n    - Components (all additive):\n      1) Size proxy: log(weight) * (log(height) + 1)\n      2) Exertion proxy: Heart_Rate^1.2 * sqrt(Duration + 1)\n      3) BMI-like proxy and its log: BMI = weight / (height_m^2), with height_m = Height / 100\n      4) Thermal stress proxy: (Body_Temp - 37)^2\n      5) Demographic modulation: Age * Sex\n      6) Age-centered normalization by Sex, then interaction with Heart_Rate: AgeInteract\n      7) Age-centered nonlinearity: AgeSquared\n    - Exactly one contextual interaction: Age-centered by sex interacted with Heart_Rate (AgeInteract). No additional cross-terms.\n    - Coefficients chosen to balance contributions: emphasize exertion and the contextual interaction while keeping size influence reasonable.\n    - Return a single feature as a pandas Series aligned to df.index.\n    Columns used: Age, Weight, Height, Duration, Heart_Rate, Body_Temp, Sex\n    \"\"\"\n\n    import numpy as np\n    import pandas as pd\n\n    # Cast inputs to float for stability\n    age = df['Age'].astype(float)\n    w = df['Weight'].astype(float)\n    h = df['Height'].astype(float)\n    d = df['Duration'].astype(float)\n    hr = df['Heart_Rate'].astype(float)\n    temp = df['Body_Temp'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Column-wise mean imputation for stability on very large data\n    w_mean = w.mean()\n    h_mean = h.mean()\n    d_mean = d.mean()\n    hr_mean = hr.mean()\n    temp_mean = temp.mean()\n    age_mean = age.mean()\n    sex_mean = sex.mean()\n\n    w = w.fillna(w_mean)\n    h = h.fillna(h_mean)\n    d = d.fillna(d_mean)\n    hr = hr.fillna(hr_mean)\n    temp = temp.fillna(temp_mean)\n    age = age.fillna(age_mean)\n    sex = sex.fillna(sex_mean)\n\n    # 1) Size proxy: log(weight) * (log(height) + 1)\n    logW = np.log1p(w)\n    logH = np.log1p(h)\n    SizeScore = logW * (logH + 1.0)\n\n    # 2) Exertion proxy: HR^1.2 * sqrt(Duration + 1)\n    Exertion = np.power(hr, 1.2) * np.sqrt(d + 1.0)\n\n    # 3) BMI-like proxy and its log: BMI = weight / (height_m^2)\n    height_m = h / 100.0\n    BMI = w / (height_m * height_m + 1e-9)\n    BMI_log = np.log1p(BMI)\n\n    # 4) Thermal stress proxy\n    TempFactor = (temp - 37.0) ** 2\n\n    # 5) Demographic modulation\n    Dem = age * sex\n\n    # 6) Age-centered normalization by sex, then interaction with Heart_Rate\n    mean_by_sex = df.groupby('Sex')['Age'].mean()\n    std_by_sex = df.groupby('Sex')['Age'].std().fillna(1.0).replace(0.0, 1.0)\n    AgeCentered = (age - df['Sex'].map(mean_by_sex)) / (df['Sex'].map(std_by_sex) + 1e-9)\n    AgeInteract = AgeCentered * hr\n    AgeSquared = AgeCentered * AgeCentered\n\n    feature = (\n        0.40 * SizeScore +\n        0.25 * Exertion +\n        0.15 * BMI +\n        0.12 * TempFactor +\n        0.18 * Dem +\n        0.08 * BMI_log +\n        0.16 * AgeInteract +\n        0.04 * AgeSquared\n    )\n\n    return pd.Series(feature, index=df.index)", 3.95957427241774]]