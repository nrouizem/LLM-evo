{"type": "seed", "generation": 0, "score": 0.01698859610825565, "text": "def build_feature(df):\n  return df['Sex']"}
{"type": "seed", "generation": 0, "score": -0.17767088792781038, "text": "def build_feature(df):\n  return df['Age']"}
{"type": "seed", "generation": 0, "score": -0.09782467975347942, "text": "def build_feature(df):\n  return df['Height']"}
{"type": "seed", "generation": 0, "score": -0.05655144716701699, "text": "def build_feature(df):\n  return df['Weight']"}
{"type": "seed", "generation": 0, "score": -0.023541512294876554, "text": "def build_feature(df):\n  return df['Duration']"}
{"type": "seed", "generation": 0, "score": -0.13281595095623544, "text": "def build_feature(df):\n  return df['Heart_Rate']"}
{"type": "seed", "generation": 0, "score": -0.05371874887896411, "text": "def build_feature(df):\n  return df['Body_Temp']"}
{"type": "mutation", "generation": 1, "score": -0.1492827047686589, "text": "def build_feature(df):\n    \"\"\"\n    Reasoning:\n    I create a single estimated-calorie-like feature using available physiological signals that correlate with energy expenditure:\n    - Intensity estimated from Heart_Rate relative to an age-based max (220 - Age).\n    - Multiply intensity by Weight and Duration to approximate total work done.\n    - Slight sex adjustment (males often burn marginally more under similar conditions).\n    - Clip and guard against division by zero and missing values.\n    This produces one numeric feature (same length as df) that is compact, robust, and should provide additional signal for predicting Calories.\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Work on a view of columns to avoid accidental modifications\n    hr = df['Heart_Rate'].astype(float)\n    age = df['Age'].astype(float)\n    weight = df['Weight'].astype(float)\n    duration = df['Duration'].astype(float)\n    sex = df['Sex'].astype(float)\n\n    # Estimate maximum heart rate, guard against zero/negative\n    max_hr = (220.0 - age).clip(lower=1.0)\n\n    # Intensity: current HR as fraction of max; clip to a reasonable upper bound\n    intensity = (hr / max_hr).clip(lower=0.0, upper=1.5)\n\n    # Small sex factor (1.0-1.1 range) \u2014 avoid large multipliers\n    sex_factor = 1.02 + 0.04 * sex\n\n    # Combine into an estimated-calorie-like feature.\n    # Use a small scaling constant to keep magnitudes reasonable across plausible unit assumptions.\n    feature = duration * weight * intensity * sex_factor * 0.08\n\n    # Fill any remaining NaNs with the median to avoid introducing missing values\n    if feature.isna().any():\n        feature = feature.fillna(feature.median())\n\n    return feature", "operator": "mutate"}
{"type": "mutation", "generation": 1, "score": 0.09028080481557765, "text": "def build_feature(df):\n    \"\"\"\n    Reasoning: I construct a physiologically-based estimated calories feature using well-known\n    heart-rate formulas that estimate calories burned per minute differently for men and women.\n    These formulas use Age, Weight, and Heart_Rate and produce calories/min which I multiply by\n    Duration to get total estimated calories. This leverages multiple available columns (Sex,\n    Age, Weight, Heart_Rate, Duration) to produce a feature that should be strongly predictive\n    of actual Calories. I clip negatives to zero to keep the feature valid for RMSLE.\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    hr = df['Heart_Rate'].astype(float)\n    w = df['Weight'].astype(float)\n    age = df['Age'].astype(float)\n    dur = df['Duration'].astype(float)\n    sex = df['Sex'].astype(int)\n\n    # Standard heart-rate based calorie formulas (calories per minute), separate for men and women\n    men_cal_per_min = (-55.0969 + 0.6309 * hr + 0.1988 * w + 0.2017 * age) / 4.184\n    women_cal_per_min = (-20.4022 + 0.4472 * hr - 0.1263 * w + 0.074 * age) / 4.184\n\n    cal_per_min = np.where(sex == 1, men_cal_per_min, women_cal_per_min)\n    total_cal = cal_per_min * dur\n\n    # Ensure non-negative (required for RMSLE and sensible interpretation)\n    total_cal = np.maximum(total_cal, 0.0)\n\n    return pd.Series(total_cal, index=df.index)", "operator": "mutate"}
{"type": "mutation", "generation": 1, "score": 0.09028080481557765, "text": "def build_feature(df):\n    \"\"\"\n    Reasoning:\n    I create a single, strongly predictive feature: an estimate of Calories burned derived from a\n    well-known heart-rate-based calorie equation that differs for men and women. This formula\n    uses Age, Weight, Heart_Rate, Sex and Duration (all available) and is widely used to\n    approximate energy expenditure. Using a physiologically-motivated formula captures nonlinear\n    interactions (HR \u00d7 sex, weight \u00d7 sex, age effects, duration scaling) that are highly relevant\n    to the Calories target and should improve the model's RMSLE when added as a feature.\n    The implementation is vectorized (numpy/pandas) and memory-efficient for large data (100k rows).\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # Ensure numeric arrays\n    age = df['Age'].astype(float).to_numpy()\n    weight = df['Weight'].astype(float).to_numpy()\n    hr = df['Heart_Rate'].astype(float).to_numpy()\n    duration = df['Duration'].astype(float).to_numpy()\n    sex = df['Sex'].astype(int).to_numpy()  # 1 male, 0 female\n\n    # Gender-specific calories-per-minute formulas (heart-rate based)\n    # Male:   ((-55.0969 + 0.6309*HR + 0.1988*weight + 0.2017*age) / 4.184)  [kcal/min]\n    # Female: ((-20.4022 + 0.4472*HR - 0.1263*weight + 0.074*age)  / 4.184)  [kcal/min]\n    male_cpm = (-55.0969 + 0.6309 * hr + 0.1988 * weight + 0.2017 * age) / 4.184\n    female_cpm = (-20.4022 + 0.4472 * hr - 0.1263 * weight + 0.074 * age) / 4.184\n\n    cal_per_min = np.where(sex == 1, male_cpm, female_cpm)\n\n    # Total estimated calories = calories per minute * duration (assumes duration in minutes)\n    est_calories = cal_per_min * duration\n\n    # Clip unrealistic negatives to zero (keeps values meaningful)\n    est_calories = np.where(est_calories < 0, 0.0, est_calories)\n\n    return pd.Series(est_calories, index=df.index, name='est_hr_calories')", "operator": "insights"}
{"type": "mutation", "generation": 1, "score": 0.09028080481557765, "text": "def build_feature(df):\n    \"\"\"\n    Reasoning: Use heart-rate based caloric-expenditure formulas (sex-specific) to produce an estimated\n    calories-burned feature. These well-known formulas combine Heart_Rate, Weight, Age and Duration\n    and should correlate strongly with the target \"Calories\". The function handles Duration given\n    in seconds by converting to minutes when the max Duration is large, clips negatives to zero,\n    and returns a Series aligned with the input df.\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    duration = df['Duration']\n    # If durations look like seconds (large max), convert to minutes; otherwise assume already in minutes\n    duration_min = duration / 60.0 if duration.max() > 500 else duration.astype(float)\n\n    hr = df['Heart_Rate'].astype(float)\n    wt = df['Weight'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(int)\n\n    # Male and female heart-rate calorie formulas (units: kcal)\n    male_cal = (-55.0969 + 0.6309 * hr + 0.1988 * wt + 0.2017 * age) * duration_min / 4.184\n    female_cal = (-20.4022 + 0.4472 * hr - 0.1263 * wt + 0.074 * age) * duration_min / 4.184\n\n    est = np.where(sex == 1, male_cal, female_cal)\n    est = np.maximum(est, 0.0)  # clip negatives\n\n    return pd.Series(est, index=df.index, name='est_calories_hr')", "operator": "mutate"}
{"type": "mutation", "generation": 1, "score": 0.09028080481557765, "text": "def build_feature(df):\n    # Reasoning: Use a physiologically informed calories estimate based on heart rate, weight, age, sex and duration.\n    # This uses standard sex-specific formulas for calories-per-minute from heart rate, then multiplies by duration.\n    # If Duration appears to be in seconds (large median), convert to minutes. Clip negatives to zero.\n    import numpy as np\n    import pandas as pd\n\n    hr = df['Heart_Rate'].astype(float)\n    w = df['Weight'].astype(float)\n    age = df['Age'].astype(float)\n    sex = df['Sex'].astype(int)\n    dur = df['Duration'].astype(float)\n\n    # Heuristic: if duration values look like seconds (median large), convert to minutes\n    try:\n        if dur.median() > 500:\n            dur = dur / 60.0\n    except Exception:\n        # If median fails for some reason, proceed without conversion\n        pass\n\n    # Calories per minute formulas (commonly used HR-based estimates)\n    # Male: ((-55.0969 + 0.6309*HR + 0.1988*weight + 0.2017*age) / 4.184)\n    # Female: ((-20.4022 + 0.4472*HR - 0.1263*weight + 0.074*age) / 4.184)\n    cal_per_min_male = (-55.0969 + 0.6309 * hr + 0.1988 * w + 0.2017 * age) / 4.184\n    cal_per_min_female = (-20.4022 + 0.4472 * hr - 0.1263 * w + 0.074 * age) / 4.184\n\n    cal_per_min = np.where(sex == 1, cal_per_min_male, cal_per_min_female)\n    total_cal = cal_per_min * dur\n\n    # Clip unrealistic negative values\n    total_cal = np.maximum(total_cal, 0.0)\n\n    return pd.Series(total_cal, index=df.index, name='est_calories_hr')", "operator": "mutate"}
{"type": "mutation", "generation": 1, "score": 0.09028080481557765, "text": "def build_feature(df):\n    \"\"\"\n    Reasoning: Use a validated heart-rate-based energy-expenditure formula (sex-specific Keytel-style equations)\n    to estimate calories burned. This leverages Heart_Rate, Weight, Age, Sex and Duration \u2014 all available columns \u2014\n    producing a single, continuous feature strongly correlated with total Calories. The computation is vectorized\n    and clipped at zero to avoid negative estimates.\n    \"\"\"\n    hr = df['Heart_Rate']\n    weight = df['Weight']\n    age = df['Age']\n    duration = df['Duration']\n\n    # per-minute calorie estimates (sex-specific formulas)\n    cal_min_m = (-55.0969 + 0.6309 * hr + 0.1988 * weight + 0.2017 * age) / 4.184\n    cal_min_f = (-20.4022 + 0.4472 * hr - 0.1263 * weight + 0.074 * age) / 4.184\n\n    # choose male formula where Sex==1, else female formula\n    per_min = cal_min_m.where(df['Sex'] == 1, cal_min_f)\n\n    # total estimated calories for the duration\n    total_cal_est = per_min * duration\n\n    # clip negatives (possible for very low activity / edge values)\n    return total_cal_est.clip(lower=0)", "operator": "mutate"}
{"type": "mutation", "generation": 1, "score": 0.1380218282686343, "text": "def build_feature(df):\n    \"\"\"\n    Reasoning: Use a validated heart-rate based energy-expenditure formula (Keytel et al.) to estimate\n    calories burned per minute from Heart_Rate, Weight and Age, with separate equations for males and females.\n    Multiply by Duration to get total estimated calories. Clip negatives to zero and slightly adjust by Body_Temp\n    (small multiplier) to capture intensity/physiology effects. Fill missing inputs with sensible medians/defaults\n    to keep the feature numeric for all rows. This engineered feature should correlate strongly with true Calories\n    while using only allowed columns.\n    \"\"\"\n    import numpy as np\n    # Fill missing sensible values\n    hr = df['Heart_Rate'].fillna(df['Heart_Rate'].median()).to_numpy(dtype=float)\n    w = df['Weight'].fillna(df['Weight'].median()).to_numpy(dtype=float)\n    age = df['Age'].fillna(df['Age'].median()).to_numpy(dtype=float)\n    dur = df['Duration'].fillna(0).to_numpy(dtype=float)\n    sex = df['Sex'].to_numpy(dtype=int)\n    bt = df['Body_Temp'].fillna(37.0).to_numpy(dtype=float)\n\n    # Keytel et al. energy expenditure estimates (kcal per minute)\n    kcal_min_men = (-55.0969 + 0.6309 * hr + 0.1988 * w + 0.2017 * age) / 4.184\n    kcal_min_women = (-20.4022 + 0.4472 * hr - 0.1263 * w + 0.074 * age) / 4.184\n\n    kcal_min = np.where(sex == 1, kcal_min_men, kcal_min_women)\n    kcal_min = np.maximum(kcal_min, 0.0)\n\n    # Small adjustment from body temperature to capture relative physiological stress/intensity\n    temp_adj = 1.0 + 0.05 * (bt - 37.0)\n    temp_adj = np.clip(temp_adj, 0.9, 1.1)\n\n    calories_est = kcal_min * dur * temp_adj\n\n    # Return as pandas Series aligned with df index\n    import pandas as pd\n    return pd.Series(calories_est, index=df.index)", "operator": "mutate"}
{"type": "mutation", "generation": 1, "score": -0.29485308639966945, "text": "def build_feature(df):\n    \"\"\"\n    Reasoning: Combine the strongest signals for energy expenditure present in the dataset.\n    Parents returned single raw columns (Heart_Rate or Duration). A better feature merges those\n    with Weight (mass affects energy cost), and adjusts for Age, Sex and Body_Temp which modulate\n    metabolic/exertion effects. This feature:\n      - fills missing values with column medians,\n      - clips each input to reasonable physiological ranges to reduce outlier noise,\n      - computes a compact, elementwise estimate that scales with Duration, Heart_Rate and sqrt(Weight),\n        and is tempered by Age (larger age reduces per-unit expenditure),\n      - modestly adjusts by Body_Temp (proxy for exertion) and Sex,\n      - normalizes the final value to keep magnitudes reasonable.\n    Operations are vectorized (O(n) memory/time) and safe for length ~100k.\n    \"\"\"\n    import numpy as np\n    # Safe extraction and filling\n    hr = df['Heart_Rate'].astype(float).fillna(df['Heart_Rate'].median())\n    dur = df['Duration'].astype(float).fillna(df['Duration'].median())\n    wt = df['Weight'].astype(float).fillna(df['Weight'].median())\n    age = df['Age'].astype(float).fillna(df['Age'].median())\n    bt = df['Body_Temp'].astype(float).fillna(df['Body_Temp'].median())\n    sex = df['Sex'].astype(float).fillna(0.0)  # 1 male, 0 female\n\n    # Clip to plausible physiological ranges to reduce influence of outliers\n    hr = hr.clip(lower=30.0, upper=210.0)\n    dur = dur.clip(lower=0.0, upper=600.0)\n    wt = wt.clip(lower=30.0, upper=250.0)\n    age = age.clip(lower=10.0, upper=90.0)\n    bt = bt.clip(lower=34.0, upper=42.0)\n\n    # Core composite: duration * heart_rate * sqrt(weight) scaled by age factor\n    base = dur * hr * np.sqrt(wt) / (age + 10.0)\n\n    # Adjustment factors\n    temp_factor = bt / 37.0              # >1 if body temp elevated\n    sex_factor = 1.0 + 0.08 * sex        # small boost for males (sex is 0/1)\n\n    # Final normalized feature\n    feature = base * temp_factor * sex_factor / 100.0\n\n    # Keep as a pandas Series aligned with the input index\n    feature = feature.rename('engineered_energy_estimate')\n    return feature", "operator": "cross"}
